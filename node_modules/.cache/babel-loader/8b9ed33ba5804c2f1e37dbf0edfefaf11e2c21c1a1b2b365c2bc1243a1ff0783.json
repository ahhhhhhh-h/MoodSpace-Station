{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  defaultContainer\n} = require('@nlpjs/core');\nconst {\n  Language\n} = require('@nlpjs/language-min');\nconst {\n  similarity\n} = require('@nlpjs/similarity');\nconst reduceEdges = require('./reduce-edges');\nclass ExtractorEnum {\n  constructor(container = defaultContainer) {\n    this.container = container.container || container;\n    this.name = 'extract-enum';\n  }\n  getScripts(str) {\n    const result = [];\n    const chars = str.split('');\n    for (let i = 0; i < chars.length; i += 1) {\n      result.push(Language.getTopScript(chars[i]));\n    }\n    return result;\n  }\n  isAlphanumeric(c) {\n    return /[\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w]/.test(c) && c !== '_';\n  }\n  getWordPositions(str) {\n    const scripts = this.getScripts(str);\n    let atWhiteSpace = true;\n    let lastIndex = 0;\n    let currentIndex = 0;\n    const strlen = str.length;\n    const result = [];\n    while (currentIndex < strlen) {\n      if (this.isAlphanumeric(str.charAt(currentIndex))) {\n        if (atWhiteSpace) {\n          if (scripts[currentIndex][0] === 'cmn') {\n            result.push({\n              start: currentIndex,\n              end: currentIndex,\n              len: 1\n            });\n            lastIndex = currentIndex;\n          } else {\n            lastIndex = currentIndex;\n            atWhiteSpace = false;\n          }\n        }\n      } else if (!atWhiteSpace) {\n        result.push({\n          start: lastIndex,\n          end: currentIndex - 1,\n          len: currentIndex - lastIndex\n        });\n        atWhiteSpace = true;\n      }\n      currentIndex += 1;\n    }\n    if (!atWhiteSpace) {\n      result.push({\n        start: lastIndex,\n        end: currentIndex - 1,\n        len: currentIndex - lastIndex\n      });\n    }\n    return result;\n  }\n  getBestSubstring(str1, str2, words1) {\n    const str1len = str1.length;\n    const str2len = str2.length;\n    if (str1len <= str2len) {\n      const result = {\n        start: 0,\n        end: str1len - 1,\n        len: str1len,\n        levenshtein: similarity(str1, str2, true)\n      };\n      result.accuracy = (str2len - result.levenshtein) / str2len;\n      return result;\n    }\n    const wordPositions = words1 || this.getWordPositions(str1);\n    const wordPositionsLen = wordPositions.length;\n    const best = {\n      start: 0,\n      end: 0,\n      len: 0,\n      levenshtein: undefined,\n      accuracy: 0\n    };\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str3 = str1.substring(wordPositions[i].start, wordPositions[j].end + 1);\n        const levenshtein = similarity(str3, str2, true);\n        if (best.levenshtein === undefined || levenshtein < best.levenshtein) {\n          best.levenshtein = levenshtein;\n          best.start = wordPositions[i].start;\n          best.end = wordPositions[j].end;\n          best.len = best.end - best.start + 1;\n        }\n      }\n    }\n    best.accuracy = (str2len - best.levenshtein) / str2len;\n    return best;\n  }\n  getBestSubstringList(str1, str2, words1, threshold = 1) {\n    const str1len = str1.length;\n    const str2len = str2.length;\n    const result = [];\n    if (str1len <= str2len) {\n      const levenshtein = similarity(str1, str2, true);\n      const accuracy = (str2len - levenshtein) / str2len;\n      if (accuracy >= threshold) {\n        result.push({\n          start: 0,\n          end: str1len - 1,\n          len: str1len,\n          levenshtein,\n          accuracy\n        });\n      }\n      return result;\n    }\n    const maxLevenshtein = str2len * (1 - threshold);\n    const wordPositions = words1 || this.getWordPositions(str1);\n    const wordPositionsLen = wordPositions.length;\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str3 = str1.substring(wordPositions[i].start, wordPositions[j].end + 1);\n        const levenshtein = similarity(str3, str2, true);\n        const accuracy = (str2len - levenshtein) / str2len;\n        if (accuracy >= threshold) {\n          result.push({\n            start: wordPositions[i].start,\n            end: wordPositions[j].end,\n            len: wordPositions[j].end - wordPositions[i].start + 1,\n            levenshtein,\n            accuracy\n          });\n        }\n        if (str3.length - wordPositions[0].len >= str2.length + maxLevenshtein) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n  normalize(str) {\n    return str.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase();\n  }\n  buildRuleDict(rule) {\n    const dict = {};\n    const inverse = {};\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const current = rule.rules[i];\n      for (let j = 0; j < current.texts.length; j += 1) {\n        const source = current.texts[j];\n        const key = this.normalize(current.texts[j]);\n        if (!dict[key]) {\n          dict[key] = [];\n        }\n        dict[key].push(current);\n        inverse[key] = source;\n      }\n    }\n    rule.dict = dict;\n    rule.inverseDict = inverse;\n  }\n  getBestExact(srcText, words, rule) {\n    const text = this.normalize(srcText);\n    const wordPositions = words || this.getWordPositions(text);\n    const wordPositionsLen = wordPositions.length;\n    const result = [];\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str = text.substring(wordPositions[i].start, wordPositions[j].end + 1);\n        if (rule.dict[str]) {\n          const subrule = rule.dict[str];\n          for (let k = 0; k < subrule.length; k += 1) {\n            result.push({\n              accuracy: 1,\n              start: wordPositions[i].start,\n              end: wordPositions[j].end,\n              len: wordPositions[j].end - wordPositions[i].start + 1,\n              levenshtein: 0,\n              entity: rule.name,\n              type: rule.type,\n              option: subrule[k].option,\n              sourceText: rule.inverseDict[str],\n              utteranceText: srcText.substring(wordPositions[i].start, wordPositions[j].end + 1)\n            });\n          }\n        }\n      }\n    }\n    return result;\n  }\n  extractFromRule(text, rule, words, threshold) {\n    if (rule.type === 'enum') {\n      const edges = [];\n      if (threshold >= 1) {\n        if (!rule.dict) {\n          this.buildRuleDict(rule);\n        }\n        const newEdges = this.getBestExact(text, words, rule);\n        for (let i = 0; i < newEdges.length; i += 1) {\n          edges.push(newEdges[i]);\n        }\n      } else {\n        for (let i = 0; i < rule.rules.length; i += 1) {\n          const current = rule.rules[i];\n          if (current && current.option && Array.isArray(current.texts)) {\n            for (let j = 0; j < current.texts.length; j += 1) {\n              const newEdges = this.getBestSubstringList(text, current.texts[j], words, current.threshold || threshold);\n              for (let k = 0; k < newEdges.length; k += 1) {\n                edges.push({\n                  ...newEdges[k],\n                  entity: rule.name,\n                  type: rule.type,\n                  option: rule.rules[i].option,\n                  sourceText: current.texts[j],\n                  utteranceText: text.substring(newEdges[k].start, newEdges[k].end + 1)\n                });\n              }\n            }\n          }\n        }\n      }\n      return edges;\n    }\n    return [];\n  }\n  async extract(srcInput) {\n    const input = srcInput;\n    const originalInputText = input.text || input.utterance;\n    let tokenizedText = originalInputText;\n    const originalPositionMap = [];\n    const tokenizer = this.container.get('tokenize');\n    if (tokenizer) {\n      const tokenizeResult = await tokenizer.run({\n        locale: input.locale,\n        text: tokenizedText\n      });\n      tokenizedText = tokenizeResult.tokens.join(' ');\n      if (tokenizedText !== originalInputText) {\n        let originalTextIndex = 0;\n        let tokenizedTextIndex = 0;\n        for (let i = 0; i < tokenizeResult.tokens.length; i += 1) {\n          const originaltextPos = originalInputText.indexOf(tokenizeResult.tokens[i], originalTextIndex);\n          for (let idx = 0; idx < tokenizeResult.tokens[i].length; idx += 1) {\n            originalPositionMap[tokenizedTextIndex + idx] = originaltextPos + idx;\n          }\n          originalTextIndex += tokenizeResult.tokens[i].length;\n          tokenizedTextIndex += tokenizeResult.tokens[i].length + 1;\n        }\n      }\n    }\n    const wordPositions = this.getWordPositions(tokenizedText);\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(tokenizedText, rules[i], wordPositions, input.threshold || 0.8);\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    if (originalPositionMap.length > 0) {\n      for (let i = 0; i < edges.length; i += 1) {\n        const edge = edges[i];\n        edge.start = originalPositionMap[edge.start];\n        edge.end = originalPositionMap[edge.end];\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false, input.intentEntities);\n    return input;\n  }\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-enum-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\nmodule.exports = ExtractorEnum;","map":{"version":3,"names":["defaultContainer","require","Language","similarity","reduceEdges","ExtractorEnum","constructor","container","name","getScripts","str","result","chars","split","i","length","push","getTopScript","isAlphanumeric","c","test","getWordPositions","scripts","atWhiteSpace","lastIndex","currentIndex","strlen","charAt","start","end","len","getBestSubstring","str1","str2","words1","str1len","str2len","levenshtein","accuracy","wordPositions","wordPositionsLen","best","undefined","j","str3","substring","getBestSubstringList","threshold","maxLevenshtein","getRules","input","allRules","nerRules","normalize","replace","toLowerCase","buildRuleDict","rule","dict","inverse","rules","current","texts","source","key","inverseDict","getBestExact","srcText","words","text","subrule","k","entity","type","option","sourceText","utteranceText","extractFromRule","edges","newEdges","Array","isArray","extract","srcInput","originalInputText","utterance","tokenizedText","originalPositionMap","tokenizer","get","tokenizeResult","run","locale","tokens","join","originalTextIndex","tokenizedTextIndex","originaltextPos","indexOf","idx","edge","sort","a","b","intentEntities","extractor","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/ner/src/extractor-enum.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { defaultContainer } = require('@nlpjs/core');\nconst { Language } = require('@nlpjs/language-min');\nconst { similarity } = require('@nlpjs/similarity');\nconst reduceEdges = require('./reduce-edges');\n\nclass ExtractorEnum {\n  constructor(container = defaultContainer) {\n    this.container = container.container || container;\n    this.name = 'extract-enum';\n  }\n\n  getScripts(str) {\n    const result = [];\n    const chars = str.split('');\n    for (let i = 0; i < chars.length; i += 1) {\n      result.push(Language.getTopScript(chars[i]));\n    }\n    return result;\n  }\n\n  isAlphanumeric(c) {\n    return /[\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w]/.test(c) && c !== '_';\n  }\n\n  getWordPositions(str) {\n    const scripts = this.getScripts(str);\n    let atWhiteSpace = true;\n    let lastIndex = 0;\n    let currentIndex = 0;\n    const strlen = str.length;\n    const result = [];\n    while (currentIndex < strlen) {\n      if (this.isAlphanumeric(str.charAt(currentIndex))) {\n        if (atWhiteSpace) {\n          if (scripts[currentIndex][0] === 'cmn') {\n            result.push({\n              start: currentIndex,\n              end: currentIndex,\n              len: 1,\n            });\n            lastIndex = currentIndex;\n          } else {\n            lastIndex = currentIndex;\n            atWhiteSpace = false;\n          }\n        }\n      } else if (!atWhiteSpace) {\n        result.push({\n          start: lastIndex,\n          end: currentIndex - 1,\n          len: currentIndex - lastIndex,\n        });\n        atWhiteSpace = true;\n      }\n      currentIndex += 1;\n    }\n    if (!atWhiteSpace) {\n      result.push({\n        start: lastIndex,\n        end: currentIndex - 1,\n        len: currentIndex - lastIndex,\n      });\n    }\n    return result;\n  }\n\n  getBestSubstring(str1, str2, words1) {\n    const str1len = str1.length;\n    const str2len = str2.length;\n    if (str1len <= str2len) {\n      const result = {\n        start: 0,\n        end: str1len - 1,\n        len: str1len,\n        levenshtein: similarity(str1, str2, true),\n      };\n      result.accuracy = (str2len - result.levenshtein) / str2len;\n      return result;\n    }\n    const wordPositions = words1 || this.getWordPositions(str1);\n    const wordPositionsLen = wordPositions.length;\n    const best = {\n      start: 0,\n      end: 0,\n      len: 0,\n      levenshtein: undefined,\n      accuracy: 0,\n    };\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str3 = str1.substring(\n          wordPositions[i].start,\n          wordPositions[j].end + 1\n        );\n        const levenshtein = similarity(str3, str2, true);\n        if (best.levenshtein === undefined || levenshtein < best.levenshtein) {\n          best.levenshtein = levenshtein;\n          best.start = wordPositions[i].start;\n          best.end = wordPositions[j].end;\n          best.len = best.end - best.start + 1;\n        }\n      }\n    }\n    best.accuracy = (str2len - best.levenshtein) / str2len;\n    return best;\n  }\n\n  getBestSubstringList(str1, str2, words1, threshold = 1) {\n    const str1len = str1.length;\n    const str2len = str2.length;\n    const result = [];\n    if (str1len <= str2len) {\n      const levenshtein = similarity(str1, str2, true);\n      const accuracy = (str2len - levenshtein) / str2len;\n      if (accuracy >= threshold) {\n        result.push({\n          start: 0,\n          end: str1len - 1,\n          len: str1len,\n          levenshtein,\n          accuracy,\n        });\n      }\n      return result;\n    }\n    const maxLevenshtein = str2len * (1 - threshold);\n    const wordPositions = words1 || this.getWordPositions(str1);\n    const wordPositionsLen = wordPositions.length;\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str3 = str1.substring(\n          wordPositions[i].start,\n          wordPositions[j].end + 1\n        );\n        const levenshtein = similarity(str3, str2, true);\n        const accuracy = (str2len - levenshtein) / str2len;\n        if (accuracy >= threshold) {\n          result.push({\n            start: wordPositions[i].start,\n            end: wordPositions[j].end,\n            len: wordPositions[j].end - wordPositions[i].start + 1,\n            levenshtein,\n            accuracy,\n          });\n        }\n        if (\n          str3.length - wordPositions[0].len >=\n          str2.length + maxLevenshtein\n        ) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n\n  normalize(str) {\n    return str\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .toLowerCase();\n  }\n\n  buildRuleDict(rule) {\n    const dict = {};\n    const inverse = {};\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const current = rule.rules[i];\n      for (let j = 0; j < current.texts.length; j += 1) {\n        const source = current.texts[j];\n        const key = this.normalize(current.texts[j]);\n        if (!dict[key]) {\n          dict[key] = [];\n        }\n        dict[key].push(current);\n        inverse[key] = source;\n      }\n    }\n    rule.dict = dict;\n    rule.inverseDict = inverse;\n  }\n\n  getBestExact(srcText, words, rule) {\n    const text = this.normalize(srcText);\n    const wordPositions = words || this.getWordPositions(text);\n    const wordPositionsLen = wordPositions.length;\n    const result = [];\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str = text.substring(\n          wordPositions[i].start,\n          wordPositions[j].end + 1\n        );\n        if (rule.dict[str]) {\n          const subrule = rule.dict[str];\n          for (let k = 0; k < subrule.length; k += 1) {\n            result.push({\n              accuracy: 1,\n              start: wordPositions[i].start,\n              end: wordPositions[j].end,\n              len: wordPositions[j].end - wordPositions[i].start + 1,\n              levenshtein: 0,\n              entity: rule.name,\n              type: rule.type,\n              option: subrule[k].option,\n              sourceText: rule.inverseDict[str],\n              utteranceText: srcText.substring(\n                wordPositions[i].start,\n                wordPositions[j].end + 1\n              ),\n            });\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  extractFromRule(text, rule, words, threshold) {\n    if (rule.type === 'enum') {\n      const edges = [];\n      if (threshold >= 1) {\n        if (!rule.dict) {\n          this.buildRuleDict(rule);\n        }\n        const newEdges = this.getBestExact(text, words, rule);\n        for (let i = 0; i < newEdges.length; i += 1) {\n          edges.push(newEdges[i]);\n        }\n      } else {\n        for (let i = 0; i < rule.rules.length; i += 1) {\n          const current = rule.rules[i];\n          if (current && current.option && Array.isArray(current.texts)) {\n            for (let j = 0; j < current.texts.length; j += 1) {\n              const newEdges = this.getBestSubstringList(\n                text,\n                current.texts[j],\n                words,\n                current.threshold || threshold\n              );\n              for (let k = 0; k < newEdges.length; k += 1) {\n                edges.push({\n                  ...newEdges[k],\n                  entity: rule.name,\n                  type: rule.type,\n                  option: rule.rules[i].option,\n                  sourceText: current.texts[j],\n                  utteranceText: text.substring(\n                    newEdges[k].start,\n                    newEdges[k].end + 1\n                  ),\n                });\n              }\n            }\n          }\n        }\n      }\n      return edges;\n    }\n    return [];\n  }\n\n  async extract(srcInput) {\n    const input = srcInput;\n    const originalInputText = input.text || input.utterance;\n    let tokenizedText = originalInputText;\n    const originalPositionMap = [];\n    const tokenizer = this.container.get('tokenize');\n    if (tokenizer) {\n      const tokenizeResult = await tokenizer.run({\n        locale: input.locale,\n        text: tokenizedText,\n      });\n      tokenizedText = tokenizeResult.tokens.join(' ');\n      if (tokenizedText !== originalInputText) {\n        let originalTextIndex = 0;\n        let tokenizedTextIndex = 0;\n        for (let i = 0; i < tokenizeResult.tokens.length; i += 1) {\n          const originaltextPos = originalInputText.indexOf(\n            tokenizeResult.tokens[i],\n            originalTextIndex\n          );\n          for (let idx = 0; idx < tokenizeResult.tokens[i].length; idx += 1) {\n            originalPositionMap[tokenizedTextIndex + idx] =\n              originaltextPos + idx;\n          }\n          originalTextIndex += tokenizeResult.tokens[i].length;\n          tokenizedTextIndex += tokenizeResult.tokens[i].length + 1;\n        }\n      }\n    }\n    const wordPositions = this.getWordPositions(tokenizedText);\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(\n        tokenizedText,\n        rules[i],\n        wordPositions,\n        input.threshold || 0.8\n      );\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    if (originalPositionMap.length > 0) {\n      for (let i = 0; i < edges.length; i += 1) {\n        const edge = edges[i];\n        edge.start = originalPositionMap[edge.start];\n        edge.end = originalPositionMap[edge.end];\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false, input.intentEntities);\n    return input;\n  }\n\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-enum-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\n\nmodule.exports = ExtractorEnum;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}