{"ast":null,"code":"/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar doublearray = require(\"doublearray\");\nvar DynamicDictionaries = require(\"../DynamicDictionaries\");\nvar TokenInfoDictionary = require(\"../TokenInfoDictionary\");\nvar ConnectionCostsBuilder = require(\"./ConnectionCostsBuilder\");\nvar CharacterDefinitionBuilder = require(\"./CharacterDefinitionBuilder\");\nvar UnknownDictionary = require(\"../UnknownDictionary\");\n\n/**\n * Build dictionaries (token info, connection costs)\n *\n * Generates from matrix.def\n * cc.dat: Connection costs\n *\n * Generates from *.csv\n * dat.dat: Double array\n * tid.dat: Token info dictionary\n * tid_map.dat: targetMap\n * tid_pos.dat: posList (part of speech)\n */\nfunction DictionaryBuilder() {\n  // Array of entries, each entry in Mecab form\n  // (0: surface form, 1: left id, 2: right id, 3: word cost, 4: part of speech id, 5-: other features)\n  this.tid_entries = [];\n  this.unk_entries = [];\n  this.cc_builder = new ConnectionCostsBuilder();\n  this.cd_builder = new CharacterDefinitionBuilder();\n}\nDictionaryBuilder.prototype.addTokenInfoDictionary = function (line) {\n  var new_entry = line.split(\",\");\n  this.tid_entries.push(new_entry);\n  return this;\n};\n\n/**\n * Put one line of \"matrix.def\" file for building ConnectionCosts object\n * @param {string} line is a line of \"matrix.def\"\n */\nDictionaryBuilder.prototype.putCostMatrixLine = function (line) {\n  this.cc_builder.putLine(line);\n  return this;\n};\nDictionaryBuilder.prototype.putCharDefLine = function (line) {\n  this.cd_builder.putLine(line);\n  return this;\n};\n\n/**\n * Put one line of \"unk.def\" file for building UnknownDictionary object\n * @param {string} line is a line of \"unk.def\"\n */\nDictionaryBuilder.prototype.putUnkDefLine = function (line) {\n  this.unk_entries.push(line.split(\",\"));\n  return this;\n};\nDictionaryBuilder.prototype.build = function () {\n  var dictionaries = this.buildTokenInfoDictionary();\n  var unknown_dictionary = this.buildUnknownDictionary();\n  return new DynamicDictionaries(dictionaries.trie, dictionaries.token_info_dictionary, this.cc_builder.build(), unknown_dictionary);\n};\n\n/**\n * Build TokenInfoDictionary\n *\n * @returns {{trie: *, token_info_dictionary: *}}\n */\nDictionaryBuilder.prototype.buildTokenInfoDictionary = function () {\n  var token_info_dictionary = new TokenInfoDictionary();\n\n  // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n  var dictionary_entries = token_info_dictionary.buildDictionary(this.tid_entries);\n  var trie = this.buildDoubleArray();\n  for (var token_info_id in dictionary_entries) {\n    var surface_form = dictionary_entries[token_info_id];\n    var trie_id = trie.lookup(surface_form);\n\n    // Assertion\n    // if (trie_id < 0) {\n    //     console.log(\"Not Found:\" + surface_form);\n    // }\n\n    token_info_dictionary.addMapping(trie_id, token_info_id);\n  }\n  return {\n    trie: trie,\n    token_info_dictionary: token_info_dictionary\n  };\n};\nDictionaryBuilder.prototype.buildUnknownDictionary = function () {\n  var unk_dictionary = new UnknownDictionary();\n\n  // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n  var dictionary_entries = unk_dictionary.buildDictionary(this.unk_entries);\n  var char_def = this.cd_builder.build(); // Create CharacterDefinition\n\n  unk_dictionary.characterDefinition(char_def);\n  for (var token_info_id in dictionary_entries) {\n    var class_name = dictionary_entries[token_info_id];\n    var class_id = char_def.invoke_definition_map.lookup(class_name);\n\n    // Assertion\n    // if (trie_id < 0) {\n    //     console.log(\"Not Found:\" + surface_form);\n    // }\n\n    unk_dictionary.addMapping(class_id, token_info_id);\n  }\n  return unk_dictionary;\n};\n\n/**\n * Build double array trie\n *\n * @returns {DoubleArray} Double-Array trie\n */\nDictionaryBuilder.prototype.buildDoubleArray = function () {\n  var trie_id = 0;\n  var words = this.tid_entries.map(function (entry) {\n    var surface_form = entry[0];\n    return {\n      k: surface_form,\n      v: trie_id++\n    };\n  });\n  var builder = doublearray.builder(1024 * 1024);\n  return builder.build(words);\n};\nmodule.exports = DictionaryBuilder;","map":{"version":3,"names":["doublearray","require","DynamicDictionaries","TokenInfoDictionary","ConnectionCostsBuilder","CharacterDefinitionBuilder","UnknownDictionary","DictionaryBuilder","tid_entries","unk_entries","cc_builder","cd_builder","prototype","addTokenInfoDictionary","line","new_entry","split","push","putCostMatrixLine","putLine","putCharDefLine","putUnkDefLine","build","dictionaries","buildTokenInfoDictionary","unknown_dictionary","buildUnknownDictionary","trie","token_info_dictionary","dictionary_entries","buildDictionary","buildDoubleArray","token_info_id","surface_form","trie_id","lookup","addMapping","unk_dictionary","char_def","characterDefinition","class_name","class_id","invoke_definition_map","words","map","entry","k","v","builder","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/kuromoji/src/dict/builder/DictionaryBuilder.js"],"sourcesContent":["/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar doublearray = require(\"doublearray\");\nvar DynamicDictionaries = require(\"../DynamicDictionaries\");\nvar TokenInfoDictionary = require(\"../TokenInfoDictionary\");\nvar ConnectionCostsBuilder = require(\"./ConnectionCostsBuilder\");\nvar CharacterDefinitionBuilder = require(\"./CharacterDefinitionBuilder\");\nvar UnknownDictionary = require(\"../UnknownDictionary\");\n\n/**\n * Build dictionaries (token info, connection costs)\n *\n * Generates from matrix.def\n * cc.dat: Connection costs\n *\n * Generates from *.csv\n * dat.dat: Double array\n * tid.dat: Token info dictionary\n * tid_map.dat: targetMap\n * tid_pos.dat: posList (part of speech)\n */\nfunction DictionaryBuilder() {\n    // Array of entries, each entry in Mecab form\n    // (0: surface form, 1: left id, 2: right id, 3: word cost, 4: part of speech id, 5-: other features)\n    this.tid_entries = [];\n    this.unk_entries = [];\n    this.cc_builder = new ConnectionCostsBuilder();\n    this.cd_builder = new CharacterDefinitionBuilder();\n}\n\nDictionaryBuilder.prototype.addTokenInfoDictionary = function (line) {\n    var new_entry = line.split(\",\");\n    this.tid_entries.push(new_entry);\n    return this;\n};\n\n/**\n * Put one line of \"matrix.def\" file for building ConnectionCosts object\n * @param {string} line is a line of \"matrix.def\"\n */\nDictionaryBuilder.prototype.putCostMatrixLine = function (line) {\n    this.cc_builder.putLine(line);\n    return this;\n};\n\nDictionaryBuilder.prototype.putCharDefLine = function (line) {\n    this.cd_builder.putLine(line);\n    return this;\n};\n\n/**\n * Put one line of \"unk.def\" file for building UnknownDictionary object\n * @param {string} line is a line of \"unk.def\"\n */\nDictionaryBuilder.prototype.putUnkDefLine = function (line) {\n    this.unk_entries.push(line.split(\",\"));\n    return this;\n};\n\nDictionaryBuilder.prototype.build = function () {\n    var dictionaries = this.buildTokenInfoDictionary();\n    var unknown_dictionary = this.buildUnknownDictionary();\n\n    return new DynamicDictionaries(dictionaries.trie, dictionaries.token_info_dictionary, this.cc_builder.build(), unknown_dictionary);\n};\n\n/**\n * Build TokenInfoDictionary\n *\n * @returns {{trie: *, token_info_dictionary: *}}\n */\nDictionaryBuilder.prototype.buildTokenInfoDictionary = function () {\n\n    var token_info_dictionary = new TokenInfoDictionary();\n\n    // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n    var dictionary_entries = token_info_dictionary.buildDictionary(this.tid_entries);\n\n    var trie = this.buildDoubleArray();\n\n    for (var token_info_id in dictionary_entries) {\n        var surface_form = dictionary_entries[token_info_id];\n        var trie_id = trie.lookup(surface_form);\n\n        // Assertion\n        // if (trie_id < 0) {\n        //     console.log(\"Not Found:\" + surface_form);\n        // }\n\n        token_info_dictionary.addMapping(trie_id, token_info_id);\n    }\n\n    return {\n        trie: trie,\n        token_info_dictionary: token_info_dictionary\n    };\n};\n\nDictionaryBuilder.prototype.buildUnknownDictionary = function () {\n\n    var unk_dictionary = new UnknownDictionary();\n\n    // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n    var dictionary_entries = unk_dictionary.buildDictionary(this.unk_entries);\n\n    var char_def = this.cd_builder.build(); // Create CharacterDefinition\n\n    unk_dictionary.characterDefinition(char_def);\n\n    for (var token_info_id in dictionary_entries) {\n        var class_name = dictionary_entries[token_info_id];\n        var class_id = char_def.invoke_definition_map.lookup(class_name);\n\n        // Assertion\n        // if (trie_id < 0) {\n        //     console.log(\"Not Found:\" + surface_form);\n        // }\n\n        unk_dictionary.addMapping(class_id, token_info_id);\n    }\n\n    return unk_dictionary;\n};\n\n/**\n * Build double array trie\n *\n * @returns {DoubleArray} Double-Array trie\n */\nDictionaryBuilder.prototype.buildDoubleArray = function () {\n    var trie_id = 0;\n    var words = this.tid_entries.map(function (entry) {\n        var surface_form = entry[0];\n        return { k: surface_form, v: trie_id++ };\n    });\n\n    var builder = doublearray.builder(1024 * 1024);\n    return builder.build(words);\n};\n\nmodule.exports = DictionaryBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}