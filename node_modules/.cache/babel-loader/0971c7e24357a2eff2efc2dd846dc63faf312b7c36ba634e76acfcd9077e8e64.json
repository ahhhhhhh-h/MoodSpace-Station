{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  Clonable,\n  compareWildcars\n} = require('@nlpjs/core');\nconst defaultDomainName = 'master_domain';\nclass DomainManager extends Clonable {\n  constructor(settings = {}, container) {\n    super({\n      settings: {},\n      container: settings.container || container\n    }, container);\n    this.applySettings(this.settings, settings);\n    this.applySettings(this.settings, {\n      locale: 'en'\n    });\n    if (!this.settings.tag) {\n      this.settings.tag = `domain-manager-${this.settings.locale}`;\n    }\n    this.registerDefault();\n    this.applySettings(this.settings, this.container.getConfiguration(this.settings.tag));\n    this.domains = {};\n    this.addDomain(defaultDomainName);\n    this.stemDict = {};\n    this.intentDict = {};\n    this.sentences = [];\n    this.applySettings(this, {\n      pipelineTrain: this.getPipeline(`${this.settings.tag}-train`),\n      pipelineProcess: this.getPipeline(`${this.settings.tag}-process`)\n    });\n  }\n  registerDefault() {\n    this.container.registerConfiguration('domain-manager-??', {\n      nluByDomain: {\n        default: {\n          className: 'NeuralNlu',\n          settings: {}\n        }\n      },\n      trainByDomain: false,\n      useStemDict: true\n    }, false);\n    this.container.registerPipeline('domain-manager-??-train', ['.trainStemmer', '.generateCorpus', '.fillStemDict', '.innerTrain', 'output.status'], false);\n  }\n  getDomainInstance(domainName) {\n    if (!this.settings.nluByDomain) {\n      this.settings.nluByDomain = {};\n    }\n    const domainSettings = this.settings.nluByDomain[domainName] || this.settings.nluByDomain.default || {\n      className: 'NeuralNlu',\n      settings: {}\n    };\n    return this.container.get(domainSettings.className || 'NeuralNlu', this.applySettings({\n      locale: this.settings.locale\n    }, domainSettings.settings || {}));\n  }\n  addDomain(name) {\n    if (!this.domains[name]) {\n      this.domains[name] = this.getDomainInstance(name);\n    }\n    return this.domains[name];\n  }\n  removeDomain(name) {\n    delete this.domains[name];\n  }\n  async generateStemKey(srcTokens) {\n    let tokens;\n    if (typeof srcTokens !== 'string') {\n      tokens = srcTokens;\n    } else {\n      const input = await this.prepare({\n        utterance: srcTokens\n      });\n      tokens = await input.stems;\n    }\n    if (!Array.isArray(tokens)) {\n      tokens = Object.keys(tokens);\n    }\n    return tokens.slice().sort().join();\n  }\n  add(domain, utterance, intent) {\n    if (!intent) {\n      this.sentences.push({\n        domain: defaultDomainName,\n        utterance: domain,\n        intent: utterance\n      });\n    } else {\n      this.sentences.push({\n        domain,\n        utterance,\n        intent\n      });\n    }\n  }\n  getSentences() {\n    return this.sentences;\n  }\n  remove(srcDomain, srcUtterance, srcIntent) {\n    const domain = srcIntent ? srcDomain : defaultDomainName;\n    const utterance = srcIntent ? srcUtterance : srcDomain;\n    const intent = srcIntent || srcUtterance;\n    for (let i = 0; i < this.sentences.length; i += 1) {\n      const sentence = this.sentences[i];\n      if (sentence.domain === domain && sentence.utterance === utterance && sentence.intent === intent) {\n        this.sentences.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n  async trainStemmer(srcInput) {\n    const input = srcInput;\n    if (!this.cache) {\n      this.cache = {\n        stem: this.container.get('stem')\n      };\n    }\n    for (let i = 0; i < this.sentences.length; i += 1) {\n      const current = this.sentences[i];\n      const subInput = {\n        ...current,\n        ...input\n      };\n      await this.cache.stem.addForTraining(subInput);\n    }\n    await this.cache.stem.train(input);\n    return input;\n  }\n  innerGenerateCorpus(domainName) {\n    this.intentDict = {};\n    const result = {};\n    result[defaultDomainName] = [];\n    for (let i = 0; i < this.sentences.length; i += 1) {\n      const sentence = this.sentences[i];\n      this.intentDict[sentence.intent] = sentence.domain;\n      const domain = domainName || sentence.domain;\n      if (!result[domain]) {\n        result[domain] = [];\n      }\n      const domainObj = result[domain];\n      domainObj.push({\n        utterance: sentence.utterance,\n        intent: sentence.intent\n      });\n      if (!domainName) {\n        result[defaultDomainName].push({\n          utterance: sentence.utterance,\n          intent: sentence.domain\n        });\n      }\n    }\n    return result;\n  }\n  async generateCorpus(srcInput) {\n    const input = srcInput;\n    input.corpus = this.innerGenerateCorpus(this.settings.trainByDomain ? undefined : defaultDomainName);\n    return input;\n  }\n  async prepare(srcInput) {\n    const input = srcInput;\n    const isString = typeof input === 'string';\n    const utterance = isString ? input : input.utterance;\n    const nlu = this.addDomain(defaultDomainName);\n    const tokens = nlu.prepare(utterance);\n    if (isString) {\n      return tokens;\n    }\n    input.stems = tokens;\n    return input;\n  }\n  async fillStemDict(srcInput) {\n    this.stemDict = {};\n    for (let i = 0; i < this.sentences.length; i += 1) {\n      const {\n        utterance,\n        intent,\n        domain\n      } = this.sentences[i];\n      const key = await this.generateStemKey(utterance);\n      if (!key || key === '') {\n        this.container.get('logger').warn(`This utterance: \"${utterance}\" contains only stop words`);\n      }\n      this.stemDict[key] = {\n        intent,\n        domain\n      };\n    }\n    return srcInput;\n  }\n  async innerTrain(srcInput) {\n    const input = srcInput;\n    const {\n      corpus\n    } = input;\n    const keys = Object.keys(corpus);\n    const status = {};\n    for (let i = 0; i < keys.length; i += 1) {\n      const nlu = this.addDomain(keys[i]);\n      const options = {\n        useNoneFeature: this.settings.useNoneFeature\n      };\n      if (srcInput.settings && srcInput.settings.log !== undefined) {\n        options.log = srcInput.settings.log;\n      }\n      const result = await nlu.train(corpus[keys[i]], options);\n      status[keys[i]] = result.status;\n    }\n    input.status = status;\n    return input;\n  }\n  async train(settings) {\n    const input = {\n      domainManager: this,\n      settings: settings || this.settings\n    };\n    return this.runPipeline(input, this.pipelineTrain);\n  }\n  matchAllowList(intent, allowList) {\n    for (let i = 0; i < allowList.length; i += 1) {\n      if (compareWildcars(intent, allowList[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async classifyByStemDict(utterance, domainName, allowList) {\n    const key = await this.generateStemKey(utterance);\n    const resolved = this.stemDict[key];\n    if (resolved && (!domainName || resolved.domain === domainName)) {\n      if (allowList && !this.matchAllowList(resolved.intent, allowList)) {\n        return undefined;\n      }\n      const classifications = [];\n      classifications.push({\n        intent: resolved.intent,\n        score: 1\n      });\n      const intents = Object.keys(this.intentDict);\n      for (let i = 0; i < intents.length; i += 1) {\n        if (intents[i] !== resolved.intent) {\n          classifications.push({\n            intent: intents[i],\n            score: 0\n          });\n        }\n      }\n      return {\n        domain: resolved.domain,\n        classifications\n      };\n    }\n    return undefined;\n  }\n  async innerClassify(srcInput, domainName) {\n    const input = srcInput;\n    const settings = this.applySettings({\n      ...input.settings\n    }, this.settings);\n    if (settings.useStemDict) {\n      const result = await this.classifyByStemDict(input.utterance, domainName, srcInput.settings ? srcInput.settings.allowList : undefined);\n      if (result) {\n        input.classification = result;\n        input.explanation = [{\n          token: '',\n          stem: '##exact',\n          weight: 1\n        }];\n        return input;\n      }\n    }\n    if (domainName) {\n      const nlu = this.domains[domainName];\n      if (!nlu) {\n        input.classification = {\n          domain: 'default',\n          classifications: [{\n            intent: 'None',\n            score: 1\n          }]\n        };\n        return input;\n      }\n      const nluAnswer = await nlu.process(input.utterance, input.settings || this.settings);\n      let classifications;\n      if (Array.isArray(nluAnswer)) {\n        classifications = nluAnswer;\n      } else {\n        classifications = nluAnswer.classifications;\n        input.nluAnswer = nluAnswer;\n      }\n      let finalDomain;\n      if (domainName === defaultDomainName) {\n        if (classifications && classifications.length) {\n          finalDomain = this.intentDict[classifications[0].intent];\n        } else {\n          finalDomain = defaultDomainName;\n        }\n      } else {\n        finalDomain = domainName;\n      }\n      input.classification = {\n        domain: finalDomain,\n        classifications\n      };\n      return input;\n    }\n    let domain = defaultDomainName;\n    if (input.settings.trainByDomain === undefined && this.settings.trainByDomain || input.settings.trainByDomain) {\n      const nlu = this.domains[defaultDomainName];\n      let classifications = await nlu.process(input.utterance);\n      if (classifications.classifications) {\n        classifications = classifications.classifications;\n      }\n      if (Object.keys(this.domains).length === 1) {\n        input.classification = {\n          domain: 'default',\n          classifications\n        };\n        return input;\n      }\n      domain = classifications[0].intent;\n      if (domain === 'None') {\n        input.classification = {\n          domain: 'default',\n          classifications: [{\n            intent: 'None',\n            score: 1\n          }]\n        };\n        return input;\n      }\n    }\n    return this.innerClassify(input, domain);\n  }\n  async defaultPipelineProcess(input) {\n    const output = await this.innerClassify(input);\n    return output.classification;\n  }\n  async process(utterance, settings) {\n    const input = typeof utterance === 'string' ? {\n      utterance,\n      settings: settings || this.settings\n    } : utterance;\n    if (this.pipelineProcess) {\n      return this.runPipeline(input, this.pipelineProcess);\n    }\n    return this.defaultPipelineProcess(input);\n  }\n  toJSON() {\n    const result = {\n      settings: this.settings,\n      stemDict: this.stemDict,\n      intentDict: this.intentDict,\n      sentences: this.sentences,\n      domains: {}\n    };\n    delete result.settings.container;\n    const keys = Object.keys(this.domains);\n    for (let i = 0; i < keys.length; i += 1) {\n      result.domains[keys[i]] = this.domains[keys[i]].toJSON();\n    }\n    return result;\n  }\n  fromJSON(json) {\n    this.applySettings(this.settings, json.settings);\n    this.stemDict = json.stemDict;\n    this.intentDict = json.intentDict;\n    this.sentences = json.sentences;\n    const keys = Object.keys(json.domains);\n    for (let i = 0; i < keys.length; i += 1) {\n      const domain = this.addDomain(keys[i]);\n      domain.fromJSON(json.domains[keys[i]]);\n    }\n  }\n}\nmodule.exports = DomainManager;","map":{"version":3,"names":["Clonable","compareWildcars","require","defaultDomainName","DomainManager","constructor","settings","container","applySettings","locale","tag","registerDefault","getConfiguration","domains","addDomain","stemDict","intentDict","sentences","pipelineTrain","getPipeline","pipelineProcess","registerConfiguration","nluByDomain","default","className","trainByDomain","useStemDict","registerPipeline","getDomainInstance","domainName","domainSettings","get","name","removeDomain","generateStemKey","srcTokens","tokens","input","prepare","utterance","stems","Array","isArray","Object","keys","slice","sort","join","add","domain","intent","push","getSentences","remove","srcDomain","srcUtterance","srcIntent","i","length","sentence","splice","trainStemmer","srcInput","cache","stem","current","subInput","addForTraining","train","innerGenerateCorpus","result","domainObj","generateCorpus","corpus","undefined","isString","nlu","fillStemDict","key","warn","innerTrain","status","options","useNoneFeature","log","domainManager","runPipeline","matchAllowList","allowList","classifyByStemDict","resolved","classifications","score","intents","innerClassify","classification","explanation","token","weight","nluAnswer","process","finalDomain","defaultPipelineProcess","output","toJSON","fromJSON","json","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/nlu/src/domain-manager.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { Clonable, compareWildcars } = require('@nlpjs/core');\n\nconst defaultDomainName = 'master_domain';\n\nclass DomainManager extends Clonable {\n  constructor(settings = {}, container) {\n    super(\n      {\n        settings: {},\n        container: settings.container || container,\n      },\n      container\n    );\n    this.applySettings(this.settings, settings);\n    this.applySettings(this.settings, { locale: 'en' });\n    if (!this.settings.tag) {\n      this.settings.tag = `domain-manager-${this.settings.locale}`;\n    }\n    this.registerDefault();\n    this.applySettings(\n      this.settings,\n      this.container.getConfiguration(this.settings.tag)\n    );\n    this.domains = {};\n    this.addDomain(defaultDomainName);\n    this.stemDict = {};\n    this.intentDict = {};\n    this.sentences = [];\n    this.applySettings(this, {\n      pipelineTrain: this.getPipeline(`${this.settings.tag}-train`),\n      pipelineProcess: this.getPipeline(`${this.settings.tag}-process`),\n    });\n  }\n\n  registerDefault() {\n    this.container.registerConfiguration(\n      'domain-manager-??',\n      {\n        nluByDomain: {\n          default: {\n            className: 'NeuralNlu',\n            settings: {},\n          },\n        },\n        trainByDomain: false,\n        useStemDict: true,\n      },\n      false\n    );\n    this.container.registerPipeline(\n      'domain-manager-??-train',\n      [\n        '.trainStemmer',\n        '.generateCorpus',\n        '.fillStemDict',\n        '.innerTrain',\n        'output.status',\n      ],\n      false\n    );\n  }\n\n  getDomainInstance(domainName) {\n    if (!this.settings.nluByDomain) {\n      this.settings.nluByDomain = {};\n    }\n    const domainSettings = this.settings.nluByDomain[domainName] ||\n      this.settings.nluByDomain.default || {\n        className: 'NeuralNlu',\n        settings: {},\n      };\n    return this.container.get(\n      domainSettings.className || 'NeuralNlu',\n      this.applySettings(\n        { locale: this.settings.locale },\n        domainSettings.settings || {}\n      )\n    );\n  }\n\n  addDomain(name) {\n    if (!this.domains[name]) {\n      this.domains[name] = this.getDomainInstance(name);\n    }\n    return this.domains[name];\n  }\n\n  removeDomain(name) {\n    delete this.domains[name];\n  }\n\n  async generateStemKey(srcTokens) {\n    let tokens;\n    if (typeof srcTokens !== 'string') {\n      tokens = srcTokens;\n    } else {\n      const input = await this.prepare({ utterance: srcTokens });\n      tokens = await input.stems;\n    }\n    if (!Array.isArray(tokens)) {\n      tokens = Object.keys(tokens);\n    }\n    return tokens.slice().sort().join();\n  }\n\n  add(domain, utterance, intent) {\n    if (!intent) {\n      this.sentences.push({\n        domain: defaultDomainName,\n        utterance: domain,\n        intent: utterance,\n      });\n    } else {\n      this.sentences.push({ domain, utterance, intent });\n    }\n  }\n\n  getSentences() {\n    return this.sentences;\n  }\n\n  remove(srcDomain, srcUtterance, srcIntent) {\n    const domain = srcIntent ? srcDomain : defaultDomainName;\n    const utterance = srcIntent ? srcUtterance : srcDomain;\n    const intent = srcIntent || srcUtterance;\n    for (let i = 0; i < this.sentences.length; i += 1) {\n      const sentence = this.sentences[i];\n      if (\n        sentence.domain === domain &&\n        sentence.utterance === utterance &&\n        sentence.intent === intent\n      ) {\n        this.sentences.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async trainStemmer(srcInput) {\n    const input = srcInput;\n    if (!this.cache) {\n      this.cache = {\n        stem: this.container.get('stem'),\n      };\n    }\n    for (let i = 0; i < this.sentences.length; i += 1) {\n      const current = this.sentences[i];\n      const subInput = { ...current, ...input };\n      await this.cache.stem.addForTraining(subInput);\n    }\n    await this.cache.stem.train(input);\n    return input;\n  }\n\n  innerGenerateCorpus(domainName) {\n    this.intentDict = {};\n    const result = {};\n    result[defaultDomainName] = [];\n    for (let i = 0; i < this.sentences.length; i += 1) {\n      const sentence = this.sentences[i];\n      this.intentDict[sentence.intent] = sentence.domain;\n      const domain = domainName || sentence.domain;\n      if (!result[domain]) {\n        result[domain] = [];\n      }\n      const domainObj = result[domain];\n      domainObj.push({\n        utterance: sentence.utterance,\n        intent: sentence.intent,\n      });\n      if (!domainName) {\n        result[defaultDomainName].push({\n          utterance: sentence.utterance,\n          intent: sentence.domain,\n        });\n      }\n    }\n    return result;\n  }\n\n  async generateCorpus(srcInput) {\n    const input = srcInput;\n    input.corpus = this.innerGenerateCorpus(\n      this.settings.trainByDomain ? undefined : defaultDomainName\n    );\n    return input;\n  }\n\n  async prepare(srcInput) {\n    const input = srcInput;\n    const isString = typeof input === 'string';\n    const utterance = isString ? input : input.utterance;\n    const nlu = this.addDomain(defaultDomainName);\n    const tokens = nlu.prepare(utterance);\n    if (isString) {\n      return tokens;\n    }\n    input.stems = tokens;\n    return input;\n  }\n\n  async fillStemDict(srcInput) {\n    this.stemDict = {};\n    for (let i = 0; i < this.sentences.length; i += 1) {\n      const { utterance, intent, domain } = this.sentences[i];\n      const key = await this.generateStemKey(utterance);\n      if (!key || key === '') {\n        this.container\n          .get('logger')\n          .warn(`This utterance: \"${utterance}\" contains only stop words`);\n      }\n      this.stemDict[key] = {\n        intent,\n        domain,\n      };\n    }\n    return srcInput;\n  }\n\n  async innerTrain(srcInput) {\n    const input = srcInput;\n    const { corpus } = input;\n    const keys = Object.keys(corpus);\n    const status = {};\n    for (let i = 0; i < keys.length; i += 1) {\n      const nlu = this.addDomain(keys[i]);\n      const options = { useNoneFeature: this.settings.useNoneFeature };\n      if (srcInput.settings && srcInput.settings.log !== undefined) {\n        options.log = srcInput.settings.log;\n      }\n      const result = await nlu.train(corpus[keys[i]], options);\n      status[keys[i]] = result.status;\n    }\n    input.status = status;\n    return input;\n  }\n\n  async train(settings) {\n    const input = {\n      domainManager: this,\n      settings: settings || this.settings,\n    };\n    return this.runPipeline(input, this.pipelineTrain);\n  }\n\n  matchAllowList(intent, allowList) {\n    for (let i = 0; i < allowList.length; i += 1) {\n      if (compareWildcars(intent, allowList[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async classifyByStemDict(utterance, domainName, allowList) {\n    const key = await this.generateStemKey(utterance);\n    const resolved = this.stemDict[key];\n    if (resolved && (!domainName || resolved.domain === domainName)) {\n      if (allowList && !this.matchAllowList(resolved.intent, allowList)) {\n        return undefined;\n      }\n      const classifications = [];\n      classifications.push({\n        intent: resolved.intent,\n        score: 1,\n      });\n      const intents = Object.keys(this.intentDict);\n      for (let i = 0; i < intents.length; i += 1) {\n        if (intents[i] !== resolved.intent) {\n          classifications.push({ intent: intents[i], score: 0 });\n        }\n      }\n      return { domain: resolved.domain, classifications };\n    }\n    return undefined;\n  }\n\n  async innerClassify(srcInput, domainName) {\n    const input = srcInput;\n    const settings = this.applySettings({ ...input.settings }, this.settings);\n    if (settings.useStemDict) {\n      const result = await this.classifyByStemDict(\n        input.utterance,\n        domainName,\n        srcInput.settings ? srcInput.settings.allowList : undefined\n      );\n      if (result) {\n        input.classification = result;\n        input.explanation = [\n          {\n            token: '',\n            stem: '##exact',\n            weight: 1,\n          },\n        ];\n        return input;\n      }\n    }\n    if (domainName) {\n      const nlu = this.domains[domainName];\n      if (!nlu) {\n        input.classification = {\n          domain: 'default',\n          classifications: [{ intent: 'None', score: 1 }],\n        };\n        return input;\n      }\n      const nluAnswer = await nlu.process(\n        input.utterance,\n        input.settings || this.settings\n      );\n      let classifications;\n      if (Array.isArray(nluAnswer)) {\n        classifications = nluAnswer;\n      } else {\n        classifications = nluAnswer.classifications;\n        input.nluAnswer = nluAnswer;\n      }\n      let finalDomain;\n      if (domainName === defaultDomainName) {\n        if (classifications && classifications.length) {\n          finalDomain = this.intentDict[classifications[0].intent];\n        } else {\n          finalDomain = defaultDomainName;\n        }\n      } else {\n        finalDomain = domainName;\n      }\n      input.classification = {\n        domain: finalDomain,\n        classifications,\n      };\n      return input;\n    }\n    let domain = defaultDomainName;\n    if (\n      (input.settings.trainByDomain === undefined &&\n        this.settings.trainByDomain) ||\n      input.settings.trainByDomain\n    ) {\n      const nlu = this.domains[defaultDomainName];\n      let classifications = await nlu.process(input.utterance);\n      if (classifications.classifications) {\n        classifications = classifications.classifications;\n      }\n      if (Object.keys(this.domains).length === 1) {\n        input.classification = {\n          domain: 'default',\n          classifications,\n        };\n        return input;\n      }\n      domain = classifications[0].intent;\n      if (domain === 'None') {\n        input.classification = {\n          domain: 'default',\n          classifications: [{ intent: 'None', score: 1 }],\n        };\n        return input;\n      }\n    }\n    return this.innerClassify(input, domain);\n  }\n\n  async defaultPipelineProcess(input) {\n    const output = await this.innerClassify(input);\n    return output.classification;\n  }\n\n  async process(utterance, settings) {\n    const input =\n      typeof utterance === 'string'\n        ? {\n            utterance,\n            settings: settings || this.settings,\n          }\n        : utterance;\n    if (this.pipelineProcess) {\n      return this.runPipeline(input, this.pipelineProcess);\n    }\n    return this.defaultPipelineProcess(input);\n  }\n\n  toJSON() {\n    const result = {\n      settings: this.settings,\n      stemDict: this.stemDict,\n      intentDict: this.intentDict,\n      sentences: this.sentences,\n      domains: {},\n    };\n    delete result.settings.container;\n    const keys = Object.keys(this.domains);\n    for (let i = 0; i < keys.length; i += 1) {\n      result.domains[keys[i]] = this.domains[keys[i]].toJSON();\n    }\n    return result;\n  }\n\n  fromJSON(json) {\n    this.applySettings(this.settings, json.settings);\n    this.stemDict = json.stemDict;\n    this.intentDict = json.intentDict;\n    this.sentences = json.sentences;\n    const keys = Object.keys(json.domains);\n    for (let i = 0; i < keys.length; i += 1) {\n      const domain = this.addDomain(keys[i]);\n      domain.fromJSON(json.domains[keys[i]]);\n    }\n  }\n}\n\nmodule.exports = DomainManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}