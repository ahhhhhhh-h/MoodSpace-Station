{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst dictionary = require('./dictionary.json');\nclass TranslateZh {\n  constructor() {\n    this.both = {};\n    for (let i = 0; i < dictionary.both.length; i += 1) {\n      this.both[dictionary.both[i]] = true;\n    }\n    this.st = {};\n    this.ts = {};\n    for (let i = 0; i < dictionary.simplified.length; i += 1) {\n      this.st[dictionary.simplified[i]] = dictionary.traditional[i];\n      this.ts[dictionary.traditional[i]] = dictionary.simplified[i];\n    }\n    for (let i = 0; i < dictionary.simplified2.length; i += 1) {\n      this.ts[dictionary.traditional2[i]] = dictionary.simplified2[i];\n    }\n    this.stPhrases = dictionary.stphrases;\n    this.tsPhrases = dictionary.tsphrases;\n    this.hkVariants = dictionary.hkvariants;\n    this.hkVariantsInverse = this.inversify(this.hkVariants);\n    this.hkPhrases = dictionary.hkphrases;\n    this.hkPhrasesInverse = this.inversify(this.hkPhrases);\n    this.hkRevPhrases = dictionary.hkrevphrases;\n    this.twVariants = dictionary.twvariants;\n    this.twVariantsInverse = this.inversify(this.twVariants);\n    this.twPhrases = dictionary.twphrases;\n    this.twPhrasesInverse = this.inversify(this.twPhrases);\n    this.twRevPhrases = dictionary.twrevphrases;\n  }\n  inversify(dict) {\n    const keys = Object.keys(dict);\n    const result = {};\n    for (let i = 0; i < keys.length; i += 1) {\n      result[dict[keys[i]]] = keys[i];\n    }\n    return result;\n  }\n  canGetSlice(processedPositions, start, currentLength) {\n    for (let i = 0; i < currentLength; i += 1) {\n      if (processedPositions[start + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  createToken(text, processedPositions, start, currentLength, dialect, variant) {\n    for (let i = 0; i < currentLength; i += 1) {\n      processedPositions[start + i] = true;\n    }\n    return {\n      text,\n      start,\n      end: start + currentLength - 1,\n      length: currentLength,\n      dialect,\n      variant\n    };\n  }\n  identifyByLength(sentence, processedPositions, currentLength) {\n    const result = [];\n    for (let i = 0; i < sentence.length - currentLength; i += 1) {\n      if (this.canGetSlice(processedPositions, i, currentLength)) {\n        const slice = sentence.slice(i, i + currentLength);\n        if (this.hkPhrasesInverse[slice] || this.hkRevPhrases[slice]) {\n          result.push(this.createToken(slice, processedPositions, i, currentLength, 'traditional', 'hk'));\n        } else if (this.twPhrasesInverse[slice] || this.twRevPhrases[slice]) {\n          result.push(this.createToken(slice, processedPositions, i, currentLength, 'traditional', 'tw'));\n        } else if (this.stPhrases[slice]) {\n          result.push(this.createToken(slice, processedPositions, i, currentLength, 'simplified', undefined));\n        } else if (this.tsPhrases[slice]) {\n          result.push(this.createToken(slice, processedPositions, i, currentLength, 'traditional', undefined));\n        }\n      }\n    }\n    return result;\n  }\n  isChineseChar(ch) {\n    const regex = /[\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/g;\n    return regex.test(ch);\n  }\n  identifyByChar(sentence, processedPositions) {\n    const tokens = [];\n    for (let i = 0; i < sentence.length; i += 1) {\n      if (!processedPositions[i]) {\n        const char = sentence[i];\n        if (this.both[char]) {\n          tokens.push(this.createToken(char, processedPositions, i, 1, 'both', undefined));\n        } else if (this.hkVariantsInverse[char]) {\n          tokens.push(this.createToken(char, processedPositions, i, 1, 'traditional', 'hk'));\n        } else if (this.twVariantsInverse[char]) {\n          tokens.push(this.createToken(char, processedPositions, i, 1, 'traditional', 'tw'));\n        } else if (this.st[char]) {\n          tokens.push(this.createToken(char, processedPositions, i, 1, 'simplified', undefined));\n        } else if (this.ts[char]) {\n          tokens.push(this.createToken(char, processedPositions, i, 1, 'traditional', undefined));\n        } else {\n          tokens.push(this.createToken(char, processedPositions, i, 1, this.isChineseChar(char) ? 'both' : 'none', undefined));\n        }\n      }\n    }\n    const result = [];\n    if (tokens.length > 0) {\n      let currentToken = tokens[0];\n      for (let i = 1; i < tokens.length; i += 1) {\n        const token = tokens[i];\n        if (token.dialect === currentToken.dialect && token.variant === currentToken.variant) {\n          currentToken.text += token.text;\n          currentToken.end += 1;\n          currentToken.length += 1;\n        } else {\n          result.push(currentToken);\n          currentToken = token;\n        }\n      }\n      result.push(currentToken);\n    }\n    return result;\n  }\n  identify(sentence) {\n    const processedPositions = [];\n    for (let i = 0; i < sentence.length; i += 1) {\n      processedPositions.push(false);\n    }\n    const tokens = [];\n    for (let i = 10; i >= 2; i -= 1) {\n      const current = this.identifyByLength(sentence, processedPositions, i);\n      for (let j = 0; j < current.length; j += 1) {\n        tokens.push(current[j]);\n      }\n    }\n    const byChar = this.identifyByChar(sentence, processedPositions);\n    for (let j = 0; j < byChar.length; j += 1) {\n      tokens.push(byChar[j]);\n    }\n    const result = {\n      tokens,\n      simplifiedCount: 0,\n      traditionalCount: 0,\n      hkCount: 0,\n      twCount: 0,\n      noneCount: 0,\n      bothCount: 0\n    };\n    for (let i = 0; i < tokens.length; i += 1) {\n      const token = tokens[i];\n      if (token.dialect === 'none') {\n        result.noneCount += token.length;\n      } else if (token.dialect === 'both') {\n        result.bothCount += token.length;\n      } else if (token.dialect === 'traditional') {\n        result.traditionalCount += token.length;\n        if (token.variant === 'hk') {\n          result.hkCount += token.length;\n        } else if (token.variant === 'tw') {\n          result.twCount += token.length;\n        }\n      } else if (token.dialect === 'simplified') {\n        result.simplifiedCount += token.length;\n      }\n    }\n    if (result.simplifiedCount > result.traditionalCount) {\n      result.dialect = 'simplified';\n      result.variant = 'none';\n    } else if (result.traditionalCount > result.simplifiedCount) {\n      result.dialect = 'traditional';\n      if (result.hkCount > result.twCount) {\n        result.variant = 'hk';\n      } else if (result.twCount > result.hkCount) {\n        result.variant = 'tw';\n      } else if (result.hkCount > 0) {\n        result.variant = 'both';\n      } else {\n        result.variant = 'none';\n      }\n    } else if (result.bothCount > 0 || result.simplifiedCount > 0) {\n      result.dialect = 'both';\n      result.variant = 'none';\n    } else {\n      result.dialect = 'none';\n      result.variant = 'none';\n    }\n    return result;\n  }\n  findIndDict(text, start, dictionaries) {\n    if (!Array.isArray(dictionaries)) {\n      dictionaries = [dictionaries];\n    }\n    for (let i = 10; i > 0; i -= 1) {\n      const slice = text.substr(start, i);\n      for (let j = 0; j < dictionaries.length; j += 1) {\n        const dict = dictionaries[j];\n        if (dict[slice]) {\n          return {\n            source: slice,\n            target: dict[slice]\n          };\n        }\n      }\n    }\n    return undefined;\n  }\n  translateByDict(text, dict) {\n    const translated = [];\n    for (let i = 0; i < text.length; i += 1) {\n      const token = this.findIndDict(text, i, dict);\n      if (token) {\n        translated.push(token.target);\n        i += token.source.length - 1;\n      } else {\n        translated.push(text[i]);\n      }\n    }\n    return translated.join('');\n  }\n  translateChain(text, dictionaries) {\n    let result = text;\n    for (let i = 0; i < dictionaries.length; i += 1) {\n      result = this.translateByDict(result, dictionaries[i]);\n    }\n    return result;\n  }\n  simplifiedToTraditional(text) {\n    return this.translateChain(text, [[this.stPhrases, this.st]]);\n  }\n  simplifiedToHongKong(text) {\n    return this.translateChain(text, [[this.stPhrases, this.st], [this.hkPhrases, this.hkVariants]]);\n  }\n  simplifiedToTaiwan(text) {\n    return this.translateChain(text, [[this.stPhrases, this.st], [this.twPhrases, this.twVariants]]);\n  }\n  hongKongToSimplified(text) {\n    return this.translateChain(text, [[this.hkRevPhrases, this.hkVariantsInverse], [this.tsPhrases, this.ts]]);\n  }\n  traditionalToHongKong(text) {\n    return this.translateChain(text, [this.hkVariants]);\n  }\n  hongKongToTraditional(text) {\n    return this.translateChain(text, [this.hkVariantsInverse]);\n  }\n  traditionalToSimplified(text) {\n    return this.translateChain(text, [[this.tsPhrases, this.ts]]);\n  }\n  traditionalToTaiwan(text) {\n    return this.translateChain(text, [this.twVariants]);\n  }\n  taiwanToTraditional(text) {\n    return this.translateChain(text, [this.twVariantsInverse]);\n  }\n  taiwanToSimplified(text) {\n    return this.translateChain(text, [[this.twRevPhrases, this.twVariantsInverse], [this.twPhrasesInverse], [this.tsPhrases, this.ts]]);\n  }\n  simplifiedTo(text, target) {\n    switch (target) {\n      case 'simplified':\n        return text;\n      case 'traditional':\n        return this.simplifiedToTraditional(text);\n      case 'hk':\n        return this.simplifiedToHongKong(text);\n      case 'tw':\n        return this.simplifiedToTaiwan(text);\n      default:\n        throw new Error(`Cannot convert to \"${target}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`);\n    }\n  }\n  traditionalTo(text, target) {\n    switch (target) {\n      case 'simplified':\n        return this.traditionalToSimplified(text);\n      case 'traditional':\n        return text;\n      case 'hk':\n        return this.traditionalToHongKong(text);\n      case 'tw':\n        return this.traditionalToTaiwan(text);\n      default:\n        throw new Error(`Cannot convert to \"${target}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`);\n    }\n  }\n  hkTo(text, target) {\n    switch (target) {\n      case 'simplified':\n        return this.hongKongToSimplified(text);\n      case 'traditional':\n        return this.hongKongToTraditional(text);\n      case 'hk':\n        return text;\n      case 'tw':\n        return this.traditionalToTaiwan(this.hongKongToTraditional(text));\n      default:\n        throw new Error(`Cannot convert to \"${target}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`);\n    }\n  }\n  twTo(text, target) {\n    switch (target) {\n      case 'simplified':\n        return this.taiwanToSimplified(text);\n      case 'traditional':\n        return this.taiwanToTraditional(text);\n      case 'hk':\n        return this.traditionalToHongKong(this.taiwanToTraditional(text));\n      case 'tw':\n        return text;\n      default:\n        throw new Error(`Cannot convert to \"${target}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`);\n    }\n  }\n  translate(text, source, target) {\n    if (!target) {\n      target = source;\n      const identification = this.identify(text);\n      if (identification.dialect === 'none') {\n        return text;\n      }\n      if (identification.dialect === 'simplified' || identification.dialect === 'both') {\n        source = 'simplified';\n      } else if (identification.variant === 'hk') {\n        source = 'hk';\n      } else if (identification.variant === 'tw') {\n        source = 'tw';\n      } else {\n        source = 'traditional';\n      }\n    }\n    switch (source) {\n      case 'simplified':\n        return this.simplifiedTo(text, target);\n      case 'traditional':\n        return this.traditionalTo(text, target);\n      case 'hk':\n        return this.hkTo(text, target);\n      case 'tw':\n        return this.twTo(text, target);\n      default:\n        throw new Error(`Cannot convert from \"${source}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`);\n    }\n  }\n}\nmodule.exports = TranslateZh;","map":{"version":3,"names":["dictionary","require","TranslateZh","constructor","both","i","length","st","ts","simplified","traditional","simplified2","traditional2","stPhrases","stphrases","tsPhrases","tsphrases","hkVariants","hkvariants","hkVariantsInverse","inversify","hkPhrases","hkphrases","hkPhrasesInverse","hkRevPhrases","hkrevphrases","twVariants","twvariants","twVariantsInverse","twPhrases","twphrases","twPhrasesInverse","twRevPhrases","twrevphrases","dict","keys","Object","result","canGetSlice","processedPositions","start","currentLength","createToken","text","dialect","variant","end","identifyByLength","sentence","slice","push","undefined","isChineseChar","ch","regex","test","identifyByChar","tokens","char","currentToken","token","identify","current","j","byChar","simplifiedCount","traditionalCount","hkCount","twCount","noneCount","bothCount","findIndDict","dictionaries","Array","isArray","substr","source","target","translateByDict","translated","join","translateChain","simplifiedToTraditional","simplifiedToHongKong","simplifiedToTaiwan","hongKongToSimplified","traditionalToHongKong","hongKongToTraditional","traditionalToSimplified","traditionalToTaiwan","taiwanToTraditional","taiwanToSimplified","simplifiedTo","Error","traditionalTo","hkTo","twTo","translate","identification","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/lang-zh/src/translate-zh.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst dictionary = require('./dictionary.json');\n\nclass TranslateZh {\n  constructor() {\n    this.both = {};\n    for (let i = 0; i < dictionary.both.length; i += 1) {\n      this.both[dictionary.both[i]] = true;\n    }\n    this.st = {};\n    this.ts = {};\n    for (let i = 0; i < dictionary.simplified.length; i += 1) {\n      this.st[dictionary.simplified[i]] = dictionary.traditional[i];\n      this.ts[dictionary.traditional[i]] = dictionary.simplified[i];\n    }\n    for (let i = 0; i < dictionary.simplified2.length; i += 1) {\n      this.ts[dictionary.traditional2[i]] = dictionary.simplified2[i];\n    }\n    this.stPhrases = dictionary.stphrases;\n    this.tsPhrases = dictionary.tsphrases;\n\n    this.hkVariants = dictionary.hkvariants;\n    this.hkVariantsInverse = this.inversify(this.hkVariants);\n    this.hkPhrases = dictionary.hkphrases;\n    this.hkPhrasesInverse = this.inversify(this.hkPhrases);\n    this.hkRevPhrases = dictionary.hkrevphrases;\n\n    this.twVariants = dictionary.twvariants;\n    this.twVariantsInverse = this.inversify(this.twVariants);\n    this.twPhrases = dictionary.twphrases;\n    this.twPhrasesInverse = this.inversify(this.twPhrases);\n    this.twRevPhrases = dictionary.twrevphrases;\n  }\n\n  inversify(dict) {\n    const keys = Object.keys(dict);\n    const result = {};\n    for (let i = 0; i < keys.length; i += 1) {\n      result[dict[keys[i]]] = keys[i];\n    }\n    return result;\n  }\n\n  canGetSlice(processedPositions, start, currentLength) {\n    for (let i = 0; i < currentLength; i += 1) {\n      if (processedPositions[start + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  createToken(\n    text,\n    processedPositions,\n    start,\n    currentLength,\n    dialect,\n    variant\n  ) {\n    for (let i = 0; i < currentLength; i += 1) {\n      processedPositions[start + i] = true;\n    }\n    return {\n      text,\n      start,\n      end: start + currentLength - 1,\n      length: currentLength,\n      dialect,\n      variant,\n    };\n  }\n\n  identifyByLength(sentence, processedPositions, currentLength) {\n    const result = [];\n    for (let i = 0; i < sentence.length - currentLength; i += 1) {\n      if (this.canGetSlice(processedPositions, i, currentLength)) {\n        const slice = sentence.slice(i, i + currentLength);\n        if (this.hkPhrasesInverse[slice] || this.hkRevPhrases[slice]) {\n          result.push(\n            this.createToken(\n              slice,\n              processedPositions,\n              i,\n              currentLength,\n              'traditional',\n              'hk'\n            )\n          );\n        } else if (this.twPhrasesInverse[slice] || this.twRevPhrases[slice]) {\n          result.push(\n            this.createToken(\n              slice,\n              processedPositions,\n              i,\n              currentLength,\n              'traditional',\n              'tw'\n            )\n          );\n        } else if (this.stPhrases[slice]) {\n          result.push(\n            this.createToken(\n              slice,\n              processedPositions,\n              i,\n              currentLength,\n              'simplified',\n              undefined\n            )\n          );\n        } else if (this.tsPhrases[slice]) {\n          result.push(\n            this.createToken(\n              slice,\n              processedPositions,\n              i,\n              currentLength,\n              'traditional',\n              undefined\n            )\n          );\n        }\n      }\n    }\n    return result;\n  }\n\n  isChineseChar(ch) {\n    const regex =\n      /[\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/g;\n    return regex.test(ch);\n  }\n\n  identifyByChar(sentence, processedPositions) {\n    const tokens = [];\n    for (let i = 0; i < sentence.length; i += 1) {\n      if (!processedPositions[i]) {\n        const char = sentence[i];\n        if (this.both[char]) {\n          tokens.push(\n            this.createToken(char, processedPositions, i, 1, 'both', undefined)\n          );\n        } else if (this.hkVariantsInverse[char]) {\n          tokens.push(\n            this.createToken(\n              char,\n              processedPositions,\n              i,\n              1,\n              'traditional',\n              'hk'\n            )\n          );\n        } else if (this.twVariantsInverse[char]) {\n          tokens.push(\n            this.createToken(\n              char,\n              processedPositions,\n              i,\n              1,\n              'traditional',\n              'tw'\n            )\n          );\n        } else if (this.st[char]) {\n          tokens.push(\n            this.createToken(\n              char,\n              processedPositions,\n              i,\n              1,\n              'simplified',\n              undefined\n            )\n          );\n        } else if (this.ts[char]) {\n          tokens.push(\n            this.createToken(\n              char,\n              processedPositions,\n              i,\n              1,\n              'traditional',\n              undefined\n            )\n          );\n        } else {\n          tokens.push(\n            this.createToken(\n              char,\n              processedPositions,\n              i,\n              1,\n              this.isChineseChar(char) ? 'both' : 'none',\n              undefined\n            )\n          );\n        }\n      }\n    }\n    const result = [];\n    if (tokens.length > 0) {\n      let currentToken = tokens[0];\n      for (let i = 1; i < tokens.length; i += 1) {\n        const token = tokens[i];\n        if (\n          token.dialect === currentToken.dialect &&\n          token.variant === currentToken.variant\n        ) {\n          currentToken.text += token.text;\n          currentToken.end += 1;\n          currentToken.length += 1;\n        } else {\n          result.push(currentToken);\n          currentToken = token;\n        }\n      }\n      result.push(currentToken);\n    }\n    return result;\n  }\n\n  identify(sentence) {\n    const processedPositions = [];\n    for (let i = 0; i < sentence.length; i += 1) {\n      processedPositions.push(false);\n    }\n    const tokens = [];\n    for (let i = 10; i >= 2; i -= 1) {\n      const current = this.identifyByLength(sentence, processedPositions, i);\n      for (let j = 0; j < current.length; j += 1) {\n        tokens.push(current[j]);\n      }\n    }\n    const byChar = this.identifyByChar(sentence, processedPositions);\n    for (let j = 0; j < byChar.length; j += 1) {\n      tokens.push(byChar[j]);\n    }\n    const result = {\n      tokens,\n      simplifiedCount: 0,\n      traditionalCount: 0,\n      hkCount: 0,\n      twCount: 0,\n      noneCount: 0,\n      bothCount: 0,\n    };\n    for (let i = 0; i < tokens.length; i += 1) {\n      const token = tokens[i];\n      if (token.dialect === 'none') {\n        result.noneCount += token.length;\n      } else if (token.dialect === 'both') {\n        result.bothCount += token.length;\n      } else if (token.dialect === 'traditional') {\n        result.traditionalCount += token.length;\n        if (token.variant === 'hk') {\n          result.hkCount += token.length;\n        } else if (token.variant === 'tw') {\n          result.twCount += token.length;\n        }\n      } else if (token.dialect === 'simplified') {\n        result.simplifiedCount += token.length;\n      }\n    }\n    if (result.simplifiedCount > result.traditionalCount) {\n      result.dialect = 'simplified';\n      result.variant = 'none';\n    } else if (result.traditionalCount > result.simplifiedCount) {\n      result.dialect = 'traditional';\n      if (result.hkCount > result.twCount) {\n        result.variant = 'hk';\n      } else if (result.twCount > result.hkCount) {\n        result.variant = 'tw';\n      } else if (result.hkCount > 0) {\n        result.variant = 'both';\n      } else {\n        result.variant = 'none';\n      }\n    } else if (result.bothCount > 0 || result.simplifiedCount > 0) {\n      result.dialect = 'both';\n      result.variant = 'none';\n    } else {\n      result.dialect = 'none';\n      result.variant = 'none';\n    }\n    return result;\n  }\n\n  findIndDict(text, start, dictionaries) {\n    if (!Array.isArray(dictionaries)) {\n      dictionaries = [dictionaries];\n    }\n    for (let i = 10; i > 0; i -= 1) {\n      const slice = text.substr(start, i);\n      for (let j = 0; j < dictionaries.length; j += 1) {\n        const dict = dictionaries[j];\n        if (dict[slice]) {\n          return {\n            source: slice,\n            target: dict[slice],\n          };\n        }\n      }\n    }\n    return undefined;\n  }\n\n  translateByDict(text, dict) {\n    const translated = [];\n    for (let i = 0; i < text.length; i += 1) {\n      const token = this.findIndDict(text, i, dict);\n      if (token) {\n        translated.push(token.target);\n        i += token.source.length - 1;\n      } else {\n        translated.push(text[i]);\n      }\n    }\n    return translated.join('');\n  }\n\n  translateChain(text, dictionaries) {\n    let result = text;\n    for (let i = 0; i < dictionaries.length; i += 1) {\n      result = this.translateByDict(result, dictionaries[i]);\n    }\n    return result;\n  }\n\n  simplifiedToTraditional(text) {\n    return this.translateChain(text, [[this.stPhrases, this.st]]);\n  }\n\n  simplifiedToHongKong(text) {\n    return this.translateChain(text, [\n      [this.stPhrases, this.st],\n      [this.hkPhrases, this.hkVariants],\n    ]);\n  }\n\n  simplifiedToTaiwan(text) {\n    return this.translateChain(text, [\n      [this.stPhrases, this.st],\n      [this.twPhrases, this.twVariants],\n    ]);\n  }\n\n  hongKongToSimplified(text) {\n    return this.translateChain(text, [\n      [this.hkRevPhrases, this.hkVariantsInverse],\n      [this.tsPhrases, this.ts],\n    ]);\n  }\n\n  traditionalToHongKong(text) {\n    return this.translateChain(text, [this.hkVariants]);\n  }\n\n  hongKongToTraditional(text) {\n    return this.translateChain(text, [this.hkVariantsInverse]);\n  }\n\n  traditionalToSimplified(text) {\n    return this.translateChain(text, [[this.tsPhrases, this.ts]]);\n  }\n\n  traditionalToTaiwan(text) {\n    return this.translateChain(text, [this.twVariants]);\n  }\n\n  taiwanToTraditional(text) {\n    return this.translateChain(text, [this.twVariantsInverse]);\n  }\n\n  taiwanToSimplified(text) {\n    return this.translateChain(text, [\n      [this.twRevPhrases, this.twVariantsInverse],\n      [this.twPhrasesInverse],\n      [this.tsPhrases, this.ts],\n    ]);\n  }\n\n  simplifiedTo(text, target) {\n    switch (target) {\n      case 'simplified':\n        return text;\n      case 'traditional':\n        return this.simplifiedToTraditional(text);\n      case 'hk':\n        return this.simplifiedToHongKong(text);\n      case 'tw':\n        return this.simplifiedToTaiwan(text);\n      default:\n        throw new Error(\n          `Cannot convert to \"${target}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`\n        );\n    }\n  }\n\n  traditionalTo(text, target) {\n    switch (target) {\n      case 'simplified':\n        return this.traditionalToSimplified(text);\n      case 'traditional':\n        return text;\n      case 'hk':\n        return this.traditionalToHongKong(text);\n      case 'tw':\n        return this.traditionalToTaiwan(text);\n      default:\n        throw new Error(\n          `Cannot convert to \"${target}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`\n        );\n    }\n  }\n\n  hkTo(text, target) {\n    switch (target) {\n      case 'simplified':\n        return this.hongKongToSimplified(text);\n      case 'traditional':\n        return this.hongKongToTraditional(text);\n      case 'hk':\n        return text;\n      case 'tw':\n        return this.traditionalToTaiwan(this.hongKongToTraditional(text));\n      default:\n        throw new Error(\n          `Cannot convert to \"${target}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`\n        );\n    }\n  }\n\n  twTo(text, target) {\n    switch (target) {\n      case 'simplified':\n        return this.taiwanToSimplified(text);\n      case 'traditional':\n        return this.taiwanToTraditional(text);\n      case 'hk':\n        return this.traditionalToHongKong(this.taiwanToTraditional(text));\n      case 'tw':\n        return text;\n      default:\n        throw new Error(\n          `Cannot convert to \"${target}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`\n        );\n    }\n  }\n\n  translate(text, source, target) {\n    if (!target) {\n      target = source;\n      const identification = this.identify(text);\n      if (identification.dialect === 'none') {\n        return text;\n      }\n      if (\n        identification.dialect === 'simplified' ||\n        identification.dialect === 'both'\n      ) {\n        source = 'simplified';\n      } else if (identification.variant === 'hk') {\n        source = 'hk';\n      } else if (identification.variant === 'tw') {\n        source = 'tw';\n      } else {\n        source = 'traditional';\n      }\n    }\n    switch (source) {\n      case 'simplified':\n        return this.simplifiedTo(text, target);\n      case 'traditional':\n        return this.traditionalTo(text, target);\n      case 'hk':\n        return this.hkTo(text, target);\n      case 'tw':\n        return this.twTo(text, target);\n      default:\n        throw new Error(\n          `Cannot convert from \"${source}\". Available options are \"simplified\", \"traditional\", \"hk\" and \"tw\"`\n        );\n    }\n  }\n}\n\nmodule.exports = TranslateZh;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}