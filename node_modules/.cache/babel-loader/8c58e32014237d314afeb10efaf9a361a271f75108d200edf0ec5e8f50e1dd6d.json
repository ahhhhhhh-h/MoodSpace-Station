{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  defaultContainer\n} = require('@nlpjs/core');\nconst reduceEdges = require('./reduce-edges');\nclass ExtractorRegex {\n  constructor(container = defaultContainer) {\n    this.container = container.container || container;\n    this.name = 'extract-regex';\n  }\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n  getMatchs(utterance, regex) {\n    const result = [];\n    let matchFound;\n    do {\n      const match = regex instanceof RegExp ? regex.exec(utterance) : null;\n      if (match) {\n        if (match.length === 1) {\n          result.push({\n            start: match.index,\n            end: regex.lastIndex - 1,\n            accuracy: 1,\n            sourceText: match[0]\n          });\n        } else {\n          const index = utterance.indexOf(match[1]);\n          result.push({\n            start: index,\n            end: index + match[1].length - 1,\n            accuracy: 1,\n            sourceText: match[1]\n          });\n        }\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    return result;\n  }\n  extractFromRule(text, rule) {\n    const edges = [];\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const newEdges = this.getMatchs(text, rule.rules[i]);\n      for (let j = 0; j < newEdges.length; j += 1) {\n        const edge = newEdges[j];\n        edge.entity = rule.name;\n        edge.type = rule.type;\n        edge.utteranceText = text.substring(edge.start, edge.end + 1);\n        edge.len = edge.utteranceText.length;\n        edges.push(edge);\n      }\n    }\n    return edges;\n  }\n  extract(srcInput) {\n    const input = srcInput;\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(input.text || input.utterance, rules[i]);\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false);\n    return input;\n  }\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-regex-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\nmodule.exports = ExtractorRegex;","map":{"version":3,"names":["defaultContainer","require","reduceEdges","ExtractorRegex","constructor","container","name","getRules","input","allRules","nerRules","getMatchs","utterance","regex","result","matchFound","match","RegExp","exec","length","push","start","index","end","lastIndex","accuracy","sourceText","indexOf","extractFromRule","text","rule","edges","i","rules","newEdges","j","edge","entity","type","utteranceText","substring","len","extract","srcInput","sort","a","b","run","locale","extractor","get","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/ner/src/extractor-regex.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { defaultContainer } = require('@nlpjs/core');\nconst reduceEdges = require('./reduce-edges');\n\nclass ExtractorRegex {\n  constructor(container = defaultContainer) {\n    this.container = container.container || container;\n    this.name = 'extract-regex';\n  }\n\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n\n  getMatchs(utterance, regex) {\n    const result = [];\n    let matchFound;\n    do {\n      const match = regex instanceof RegExp ? regex.exec(utterance) : null;\n      if (match) {\n        if (match.length === 1) {\n          result.push({\n            start: match.index,\n            end: regex.lastIndex - 1,\n            accuracy: 1,\n            sourceText: match[0],\n          });\n        } else {\n          const index = utterance.indexOf(match[1]);\n          result.push({\n            start: index,\n            end: index + match[1].length - 1,\n            accuracy: 1,\n            sourceText: match[1],\n          });\n        }\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    return result;\n  }\n\n  extractFromRule(text, rule) {\n    const edges = [];\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const newEdges = this.getMatchs(text, rule.rules[i]);\n      for (let j = 0; j < newEdges.length; j += 1) {\n        const edge = newEdges[j];\n        edge.entity = rule.name;\n        edge.type = rule.type;\n        edge.utteranceText = text.substring(edge.start, edge.end + 1);\n        edge.len = edge.utteranceText.length;\n        edges.push(edge);\n      }\n    }\n    return edges;\n  }\n\n  extract(srcInput) {\n    const input = srcInput;\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(\n        input.text || input.utterance,\n        rules[i]\n      );\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false);\n    return input;\n  }\n\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-regex-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\n\nmodule.exports = ExtractorRegex;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}