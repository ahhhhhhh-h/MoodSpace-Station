{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  compareWildcars\n} = require('./helper');\nconst DefaultCompiler = require('./default-compiler');\nconst logger = require('./logger');\n\n/**\n * Container class\n */\nclass Container {\n  /**\n   * Constructor of the class.\n   */\n  constructor(hasPreffix = false) {\n    this.classes = {};\n    this.factory = {};\n    this.pipelines = {};\n    this.configurations = {};\n    this.compilers = {};\n    this.cache = {\n      bestKeys: {},\n      pipelines: {}\n    };\n    this.registerCompiler(DefaultCompiler);\n    if (!hasPreffix) {\n      this.use(logger);\n    }\n  }\n  registerCompiler(Compiler, name) {\n    const instance = new Compiler(this);\n    this.compilers[name || instance.name] = instance;\n  }\n  addClass(clazz, name) {\n    this.classes[name || clazz.name] = clazz;\n  }\n  toJSON(instance) {\n    const result = instance.toJSON ? instance.toJSON() : {\n      ...instance\n    };\n    result.className = instance.constructor.name;\n    return result;\n  }\n  fromJSON(obj, settings) {\n    const Clazz = this.classes[obj.className];\n    let instance;\n    if (Clazz) {\n      instance = new Clazz(settings);\n      if (instance.fromJSON) {\n        instance.fromJSON(obj);\n      } else {\n        Object.assign(instance, obj);\n      }\n    } else {\n      instance = {\n        ...obj\n      };\n    }\n    delete instance.className;\n    return instance;\n  }\n  register(name, Clazz, isSingleton = true) {\n    this.cache.bestKeys = {};\n    const isClass = typeof Clazz === 'function';\n    const item = {\n      name,\n      isSingleton\n    };\n    if (isSingleton) {\n      item.instance = isClass ? new Clazz() : Clazz;\n    } else {\n      item.instance = isClass ? Clazz : Clazz.constructor;\n    }\n    this.factory[name] = item;\n  }\n  getBestKey(name) {\n    if (this.cache.bestKeys[name] !== undefined) {\n      return this.cache.bestKeys[name];\n    }\n    const keys = Object.keys(this.factory);\n    for (let i = 0; i < keys.length; i += 1) {\n      if (compareWildcars(name, keys[i])) {\n        this.cache.bestKeys[name] = keys[i];\n        return keys[i];\n      }\n    }\n    this.cache.bestKeys[name] = null;\n    return undefined;\n  }\n  get(name, settings) {\n    let item = this.factory[name];\n    if (!item) {\n      if (this.parent) {\n        return this.parent.get(name, settings);\n      }\n      const key = this.getBestKey(name);\n      if (key) {\n        item = this.factory[key];\n      }\n      if (!item) {\n        return undefined;\n      }\n    }\n    if (item.isSingleton) {\n      if (item.instance && item.instance.applySettings) {\n        item.instance.applySettings(item.instance.settings, settings);\n      }\n      return item.instance;\n    }\n    const Clazz = item.instance;\n    return new Clazz(settings, this);\n  }\n  buildLiteral(subtype, step, value, context) {\n    return {\n      type: 'literal',\n      subtype,\n      src: step,\n      value,\n      context,\n      container: this\n    };\n  }\n  resolvePathWithType(step, context, input, srcObject) {\n    const tokens = step.split('.');\n    let token = tokens[0].trim();\n    if (!token) {\n      token = step.startsWith('.') ? 'this' : 'context';\n    }\n    const isnum = /^\\d+$/.test(token);\n    if (isnum) {\n      return this.buildLiteral('number', step, parseFloat(token), context);\n    }\n    if (token.startsWith('\"')) {\n      return this.buildLiteral('string', step, token.replace(/^\"(.+(?=\"$))\"$/, '$1'), context);\n    }\n    if (token.startsWith(\"'\")) {\n      return this.buildLiteral('string', step, token.replace(/^'(.+(?='$))'$/, '$1'), context);\n    }\n    if (token === 'true') {\n      return this.buildLiteral('boolean', step, true, context);\n    }\n    if (token === 'false') {\n      return this.buildLiteral('boolean', step, false, context);\n    }\n    let currentObject = context;\n    if (token === 'input' || token === 'output') {\n      currentObject = input;\n    } else if (token && token !== 'context' && token !== 'this') {\n      currentObject = this.get(token) || currentObject[token];\n    } else if (token === 'this') {\n      currentObject = srcObject;\n    }\n    for (let i = 1; i < tokens.length; i += 1) {\n      const currentToken = tokens[i];\n      if (!currentObject || !currentObject[currentToken]) {\n        if (i < tokens.length - 1) {\n          throw Error(`Path not found in pipeline \"${step}\"`);\n        }\n      }\n      const prevCurrentObject = currentObject;\n      currentObject = currentObject[currentToken];\n      if (typeof currentObject === 'function') {\n        currentObject = currentObject.bind(prevCurrentObject);\n      }\n    }\n    if (typeof currentObject === 'function') {\n      return {\n        type: 'function',\n        src: step,\n        value: currentObject,\n        context,\n        container: this\n      };\n    }\n    return {\n      type: 'reference',\n      src: step,\n      value: currentObject,\n      context,\n      container: this\n    };\n  }\n  resolvePath(step, context, input, srcObject) {\n    const result = this.resolvePathWithType(step, context, input, srcObject);\n    return result ? result.value : result;\n  }\n  setValue(path, valuePath, context, input, srcObject) {\n    const value = this.resolvePath(valuePath, context, input, srcObject);\n    const tokens = path.split('.');\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    currentObject[tokens[tokens.length - 1]] = value;\n  }\n  incValue(path, valuePath, context, input, srcObject) {\n    const value = this.resolvePath(valuePath, context, input, srcObject);\n    const tokens = path.split('.');\n    if (path.startsWith('.')) {\n      tokens.push('this');\n    }\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    currentObject[tokens[tokens.length - 1]] += value;\n  }\n  decValue(path, valuePath, context, input, srcObject) {\n    const value = this.resolvePath(valuePath, context, input, srcObject);\n    const tokens = path.split('.');\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    currentObject[tokens[tokens.length - 1]] -= value;\n  }\n  eqValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA === valueB;\n  }\n  neqValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA !== valueB;\n  }\n  gtValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA > valueB;\n  }\n  geValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA >= valueB;\n  }\n  ltValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA < valueB;\n  }\n  leValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA <= valueB;\n  }\n  deleteValue(path, context, input, srcObject) {\n    const tokens = path.split('.');\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    delete currentObject[tokens[tokens.length - 1]];\n  }\n  getValue(srcPath, context, input, srcObject) {\n    const path = srcPath || 'floating';\n    const tokens = path.split('.');\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    return currentObject[tokens[tokens.length - 1]];\n  }\n  async runPipeline(srcPipeline, input, srcObject, depth = 0) {\n    if (depth > 10) {\n      throw new Error('Pipeline depth is too high: perhaps you are using recursive pipelines?');\n    }\n    const pipeline = typeof srcPipeline === 'string' ? this.getPipeline(srcPipeline) : srcPipeline;\n    if (!pipeline) {\n      throw new Error(`Pipeline not found ${srcPipeline}`);\n    }\n    if (!pipeline.compiler) {\n      const tag = JSON.stringify(pipeline);\n      this.registerPipeline(tag, pipeline, false);\n      const built = this.getPipeline(tag);\n      return built.compiler.execute(built.compiled, input, srcObject, depth);\n    }\n    return pipeline.compiler.execute(pipeline.compiled, input, srcObject, depth);\n  }\n  use(item, name, isSingleton, onlyIfNotExists = false) {\n    let instance;\n    if (typeof item === 'function') {\n      if (item.name.endsWith('Compiler')) {\n        this.registerCompiler(item);\n        return item.name;\n      }\n      const Clazz = item;\n      instance = new Clazz({\n        container: this\n      });\n    } else {\n      instance = item;\n    }\n    if (instance.register) {\n      instance.register(this);\n    }\n    const tag = instance.settings ? instance.settings.tag : undefined;\n    const itemName = name || instance.name || tag || item.name || instance.constructor.name;\n    if (!onlyIfNotExists || !this.get(itemName)) {\n      this.register(itemName, instance, isSingleton);\n    }\n    return itemName;\n  }\n  getCompiler(name) {\n    const compiler = this.compilers[name];\n    if (compiler) {\n      return compiler;\n    }\n    if (this.parent) {\n      return this.parent.getCompiler(name);\n    }\n    return this.compilers.default;\n  }\n  buildPipeline(srcPipeline, prevPipeline = []) {\n    const pipeline = [];\n    if (srcPipeline && srcPipeline.length > 0) {\n      for (let i = 0; i < srcPipeline.length; i += 1) {\n        const line = srcPipeline[i];\n        if (line.trim() === '$super') {\n          for (let j = 0; j < prevPipeline.length; j += 1) {\n            const s = prevPipeline[j].trim();\n            if (!s.startsWith('->')) {\n              pipeline.push(prevPipeline[j]);\n            }\n          }\n        } else {\n          pipeline.push(line);\n        }\n      }\n    }\n    const compilerName = !pipeline.length || !pipeline[0].startsWith('// compiler=') ? 'default' : pipeline[0].slice(12);\n    const compiler = this.getCompiler(compilerName);\n    const compiled = compiler.compile(pipeline);\n    return {\n      pipeline,\n      compiler,\n      compiled\n    };\n  }\n  registerPipeline(tag, pipeline, overwrite = true) {\n    if (overwrite || !this.pipelines[tag]) {\n      this.cache.pipelines = {};\n      const prev = this.getPipeline(tag);\n      this.pipelines[tag] = this.buildPipeline(pipeline, prev ? prev.pipeline : []);\n    }\n  }\n  registerPipelineForChilds(childName, tag, pipeline, overwrite = true) {\n    if (!this.childPipelines) {\n      this.childPipelines = {};\n    }\n    if (!this.childPipelines[childName]) {\n      this.childPipelines[childName] = [];\n    }\n    this.childPipelines[childName].push({\n      tag,\n      pipeline,\n      overwrite\n    });\n  }\n  getPipeline(tag) {\n    if (this.pipelines[tag]) {\n      return this.pipelines[tag];\n    }\n    if (this.cache.pipelines[tag] !== undefined) {\n      return this.cache.pipelines[tag] || undefined;\n    }\n    const keys = Object.keys(this.pipelines);\n    for (let i = 0; i < keys.length; i += 1) {\n      if (compareWildcars(tag, keys[i])) {\n        this.cache.pipelines[tag] = this.pipelines[keys[i]];\n        return this.pipelines[keys[i]];\n      }\n    }\n    this.cache.pipelines[tag] = null;\n    return undefined;\n  }\n  registerConfiguration(tag, configuration, overwrite = true) {\n    if (overwrite || !this.configurations[tag]) {\n      this.configurations[tag] = configuration;\n    }\n  }\n  getConfiguration(tag) {\n    if (this.configurations[tag]) {\n      return this.configurations[tag];\n    }\n    const keys = Object.keys(this.configurations);\n    for (let i = 0; i < keys.length; i += 1) {\n      if (compareWildcars(tag, keys[i])) {\n        return this.configurations[keys[i]];\n      }\n    }\n    return undefined;\n  }\n  loadPipelinesFromString(str = '') {\n    const lines = str.split(/\\n|\\r|\\r\\n/);\n    let currentName = '';\n    let currentPipeline = [];\n    let currentTitle = '';\n    for (let i = 0; i < lines.length; i += 1) {\n      const line = lines[i];\n      if (line !== '') {\n        if (line.startsWith('# ')) {\n          if (currentName) {\n            if (currentTitle && !['default', 'pipelines'].includes(currentTitle.toLowerCase())) {\n              this.registerPipelineForChilds(currentTitle, currentName, currentPipeline);\n            } else {\n              this.registerPipeline(currentName, currentPipeline);\n            }\n          }\n          currentTitle = line.slice(1).trim();\n          currentName = '';\n          currentPipeline = [];\n        } else if (line.startsWith('## ')) {\n          if (currentName) {\n            if (currentTitle && !['default', 'pipelines'].includes(currentTitle.toLowerCase())) {\n              this.registerPipelineForChilds(currentTitle, currentName, currentPipeline);\n            } else {\n              this.registerPipeline(currentName, currentPipeline);\n            }\n          }\n          currentName = line.slice(2).trim();\n          currentPipeline = [];\n        } else if (currentName) {\n          currentPipeline.push(line);\n        }\n      }\n    }\n    if (currentName) {\n      if (currentTitle && !['default', 'pipelines'].includes(currentTitle.toLowerCase())) {\n        this.registerPipelineForChilds(currentTitle, currentName, currentPipeline);\n      } else {\n        this.registerPipeline(currentName, currentPipeline);\n      }\n    }\n  }\n  async start(pipelineName = 'main') {\n    const keys = Object.keys(this.factory);\n    for (let i = 0; i < keys.length; i += 1) {\n      const current = this.factory[keys[i]];\n      if (current.isSingleton && current.instance && current.instance.start) {\n        await current.instance.start();\n      }\n    }\n    if (this.getPipeline(pipelineName)) {\n      await this.runPipeline(pipelineName, {}, this);\n    }\n  }\n}\nconst defaultContainer = new Container();\nmodule.exports = {\n  Container,\n  defaultContainer\n};","map":{"version":3,"names":["compareWildcars","require","DefaultCompiler","logger","Container","constructor","hasPreffix","classes","factory","pipelines","configurations","compilers","cache","bestKeys","registerCompiler","use","Compiler","name","instance","addClass","clazz","toJSON","result","className","fromJSON","obj","settings","Clazz","Object","assign","register","isSingleton","isClass","item","getBestKey","undefined","keys","i","length","get","parent","key","applySettings","buildLiteral","subtype","step","value","context","type","src","container","resolvePathWithType","input","srcObject","tokens","split","token","trim","startsWith","isnum","test","parseFloat","replace","currentObject","currentToken","Error","prevCurrentObject","bind","resolvePath","setValue","path","valuePath","newPath","slice","join","incValue","push","decValue","eqValue","pathA","pathB","srcContext","valueA","valueB","floating","neqValue","gtValue","geValue","ltValue","leValue","deleteValue","getValue","srcPath","runPipeline","srcPipeline","depth","pipeline","getPipeline","compiler","tag","JSON","stringify","registerPipeline","built","execute","compiled","onlyIfNotExists","endsWith","itemName","getCompiler","default","buildPipeline","prevPipeline","line","j","s","compilerName","compile","overwrite","prev","registerPipelineForChilds","childName","childPipelines","registerConfiguration","configuration","getConfiguration","loadPipelinesFromString","str","lines","currentName","currentPipeline","currentTitle","includes","toLowerCase","start","pipelineName","current","defaultContainer","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/core/src/container.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { compareWildcars } = require('./helper');\nconst DefaultCompiler = require('./default-compiler');\nconst logger = require('./logger');\n\n/**\n * Container class\n */\nclass Container {\n  /**\n   * Constructor of the class.\n   */\n  constructor(hasPreffix = false) {\n    this.classes = {};\n    this.factory = {};\n    this.pipelines = {};\n    this.configurations = {};\n    this.compilers = {};\n    this.cache = {\n      bestKeys: {},\n      pipelines: {},\n    };\n    this.registerCompiler(DefaultCompiler);\n    if (!hasPreffix) {\n      this.use(logger);\n    }\n  }\n\n  registerCompiler(Compiler, name) {\n    const instance = new Compiler(this);\n    this.compilers[name || instance.name] = instance;\n  }\n\n  addClass(clazz, name) {\n    this.classes[name || clazz.name] = clazz;\n  }\n\n  toJSON(instance) {\n    const result = instance.toJSON ? instance.toJSON() : { ...instance };\n    result.className = instance.constructor.name;\n    return result;\n  }\n\n  fromJSON(obj, settings) {\n    const Clazz = this.classes[obj.className];\n    let instance;\n    if (Clazz) {\n      instance = new Clazz(settings);\n      if (instance.fromJSON) {\n        instance.fromJSON(obj);\n      } else {\n        Object.assign(instance, obj);\n      }\n    } else {\n      instance = { ...obj };\n    }\n    delete instance.className;\n    return instance;\n  }\n\n  register(name, Clazz, isSingleton = true) {\n    this.cache.bestKeys = {};\n    const isClass = typeof Clazz === 'function';\n    const item = { name, isSingleton };\n    if (isSingleton) {\n      item.instance = isClass ? new Clazz() : Clazz;\n    } else {\n      item.instance = isClass ? Clazz : Clazz.constructor;\n    }\n    this.factory[name] = item;\n  }\n\n  getBestKey(name) {\n    if (this.cache.bestKeys[name] !== undefined) {\n      return this.cache.bestKeys[name];\n    }\n    const keys = Object.keys(this.factory);\n    for (let i = 0; i < keys.length; i += 1) {\n      if (compareWildcars(name, keys[i])) {\n        this.cache.bestKeys[name] = keys[i];\n        return keys[i];\n      }\n    }\n    this.cache.bestKeys[name] = null;\n    return undefined;\n  }\n\n  get(name, settings) {\n    let item = this.factory[name];\n    if (!item) {\n      if (this.parent) {\n        return this.parent.get(name, settings);\n      }\n      const key = this.getBestKey(name);\n      if (key) {\n        item = this.factory[key];\n      }\n      if (!item) {\n        return undefined;\n      }\n    }\n    if (item.isSingleton) {\n      if (item.instance && item.instance.applySettings) {\n        item.instance.applySettings(item.instance.settings, settings);\n      }\n      return item.instance;\n    }\n    const Clazz = item.instance;\n    return new Clazz(settings, this);\n  }\n\n  buildLiteral(subtype, step, value, context) {\n    return {\n      type: 'literal',\n      subtype,\n      src: step,\n      value,\n      context,\n      container: this,\n    };\n  }\n\n  resolvePathWithType(step, context, input, srcObject) {\n    const tokens = step.split('.');\n    let token = tokens[0].trim();\n    if (!token) {\n      token = step.startsWith('.') ? 'this' : 'context';\n    }\n    const isnum = /^\\d+$/.test(token);\n    if (isnum) {\n      return this.buildLiteral('number', step, parseFloat(token), context);\n    }\n    if (token.startsWith('\"')) {\n      return this.buildLiteral(\n        'string',\n        step,\n        token.replace(/^\"(.+(?=\"$))\"$/, '$1'),\n        context\n      );\n    }\n    if (token.startsWith(\"'\")) {\n      return this.buildLiteral(\n        'string',\n        step,\n        token.replace(/^'(.+(?='$))'$/, '$1'),\n        context\n      );\n    }\n    if (token === 'true') {\n      return this.buildLiteral('boolean', step, true, context);\n    }\n    if (token === 'false') {\n      return this.buildLiteral('boolean', step, false, context);\n    }\n    let currentObject = context;\n    if (token === 'input' || token === 'output') {\n      currentObject = input;\n    } else if (token && token !== 'context' && token !== 'this') {\n      currentObject = this.get(token) || currentObject[token];\n    } else if (token === 'this') {\n      currentObject = srcObject;\n    }\n    for (let i = 1; i < tokens.length; i += 1) {\n      const currentToken = tokens[i];\n      if (!currentObject || !currentObject[currentToken]) {\n        if (i < tokens.length - 1) {\n          throw Error(`Path not found in pipeline \"${step}\"`);\n        }\n      }\n      const prevCurrentObject = currentObject;\n      currentObject = currentObject[currentToken];\n      if (typeof currentObject === 'function') {\n        currentObject = currentObject.bind(prevCurrentObject);\n      }\n    }\n    if (typeof currentObject === 'function') {\n      return {\n        type: 'function',\n        src: step,\n        value: currentObject,\n        context,\n        container: this,\n      };\n    }\n    return {\n      type: 'reference',\n      src: step,\n      value: currentObject,\n      context,\n      container: this,\n    };\n  }\n\n  resolvePath(step, context, input, srcObject) {\n    const result = this.resolvePathWithType(step, context, input, srcObject);\n    return result ? result.value : result;\n  }\n\n  setValue(path, valuePath, context, input, srcObject) {\n    const value = this.resolvePath(valuePath, context, input, srcObject);\n    const tokens = path.split('.');\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    currentObject[tokens[tokens.length - 1]] = value;\n  }\n\n  incValue(path, valuePath, context, input, srcObject) {\n    const value = this.resolvePath(valuePath, context, input, srcObject);\n    const tokens = path.split('.');\n    if (path.startsWith('.')) {\n      tokens.push('this');\n    }\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    currentObject[tokens[tokens.length - 1]] += value;\n  }\n\n  decValue(path, valuePath, context, input, srcObject) {\n    const value = this.resolvePath(valuePath, context, input, srcObject);\n    const tokens = path.split('.');\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    currentObject[tokens[tokens.length - 1]] -= value;\n  }\n\n  eqValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA === valueB;\n  }\n\n  neqValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA !== valueB;\n  }\n\n  gtValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA > valueB;\n  }\n\n  geValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA >= valueB;\n  }\n\n  ltValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA < valueB;\n  }\n\n  leValue(pathA, pathB, srcContext, input, srcObject) {\n    const context = srcContext;\n    const valueA = this.resolvePath(pathA, context, input, srcObject);\n    const valueB = this.resolvePath(pathB, context, input, srcObject);\n    context.floating = valueA <= valueB;\n  }\n\n  deleteValue(path, context, input, srcObject) {\n    const tokens = path.split('.');\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    delete currentObject[tokens[tokens.length - 1]];\n  }\n\n  getValue(srcPath, context, input, srcObject) {\n    const path = srcPath || 'floating';\n    const tokens = path.split('.');\n    const newPath = tokens.slice(0, -1).join('.');\n    const currentObject = this.resolvePath(newPath, context, input, srcObject);\n    return currentObject[tokens[tokens.length - 1]];\n  }\n\n  async runPipeline(srcPipeline, input, srcObject, depth = 0) {\n    if (depth > 10) {\n      throw new Error(\n        'Pipeline depth is too high: perhaps you are using recursive pipelines?'\n      );\n    }\n    const pipeline =\n      typeof srcPipeline === 'string'\n        ? this.getPipeline(srcPipeline)\n        : srcPipeline;\n    if (!pipeline) {\n      throw new Error(`Pipeline not found ${srcPipeline}`);\n    }\n    if (!pipeline.compiler) {\n      const tag = JSON.stringify(pipeline);\n      this.registerPipeline(tag, pipeline, false);\n      const built = this.getPipeline(tag);\n      return built.compiler.execute(built.compiled, input, srcObject, depth);\n    }\n    return pipeline.compiler.execute(\n      pipeline.compiled,\n      input,\n      srcObject,\n      depth\n    );\n  }\n\n  use(item, name, isSingleton, onlyIfNotExists = false) {\n    let instance;\n    if (typeof item === 'function') {\n      if (item.name.endsWith('Compiler')) {\n        this.registerCompiler(item);\n        return item.name;\n      }\n      const Clazz = item;\n      instance = new Clazz({ container: this });\n    } else {\n      instance = item;\n    }\n    if (instance.register) {\n      instance.register(this);\n    }\n    const tag = instance.settings ? instance.settings.tag : undefined;\n    const itemName =\n      name || instance.name || tag || item.name || instance.constructor.name;\n    if (!onlyIfNotExists || !this.get(itemName)) {\n      this.register(itemName, instance, isSingleton);\n    }\n    return itemName;\n  }\n\n  getCompiler(name) {\n    const compiler = this.compilers[name];\n    if (compiler) {\n      return compiler;\n    }\n    if (this.parent) {\n      return this.parent.getCompiler(name);\n    }\n    return this.compilers.default;\n  }\n\n  buildPipeline(srcPipeline, prevPipeline = []) {\n    const pipeline = [];\n    if (srcPipeline && srcPipeline.length > 0) {\n      for (let i = 0; i < srcPipeline.length; i += 1) {\n        const line = srcPipeline[i];\n        if (line.trim() === '$super') {\n          for (let j = 0; j < prevPipeline.length; j += 1) {\n            const s = prevPipeline[j].trim();\n            if (!s.startsWith('->')) {\n              pipeline.push(prevPipeline[j]);\n            }\n          }\n        } else {\n          pipeline.push(line);\n        }\n      }\n    }\n    const compilerName =\n      !pipeline.length || !pipeline[0].startsWith('// compiler=')\n        ? 'default'\n        : pipeline[0].slice(12);\n    const compiler = this.getCompiler(compilerName);\n    const compiled = compiler.compile(pipeline);\n    return {\n      pipeline,\n      compiler,\n      compiled,\n    };\n  }\n\n  registerPipeline(tag, pipeline, overwrite = true) {\n    if (overwrite || !this.pipelines[tag]) {\n      this.cache.pipelines = {};\n      const prev = this.getPipeline(tag);\n      this.pipelines[tag] = this.buildPipeline(\n        pipeline,\n        prev ? prev.pipeline : []\n      );\n    }\n  }\n\n  registerPipelineForChilds(childName, tag, pipeline, overwrite = true) {\n    if (!this.childPipelines) {\n      this.childPipelines = {};\n    }\n    if (!this.childPipelines[childName]) {\n      this.childPipelines[childName] = [];\n    }\n    this.childPipelines[childName].push({ tag, pipeline, overwrite });\n  }\n\n  getPipeline(tag) {\n    if (this.pipelines[tag]) {\n      return this.pipelines[tag];\n    }\n    if (this.cache.pipelines[tag] !== undefined) {\n      return this.cache.pipelines[tag] || undefined;\n    }\n    const keys = Object.keys(this.pipelines);\n    for (let i = 0; i < keys.length; i += 1) {\n      if (compareWildcars(tag, keys[i])) {\n        this.cache.pipelines[tag] = this.pipelines[keys[i]];\n        return this.pipelines[keys[i]];\n      }\n    }\n    this.cache.pipelines[tag] = null;\n    return undefined;\n  }\n\n  registerConfiguration(tag, configuration, overwrite = true) {\n    if (overwrite || !this.configurations[tag]) {\n      this.configurations[tag] = configuration;\n    }\n  }\n\n  getConfiguration(tag) {\n    if (this.configurations[tag]) {\n      return this.configurations[tag];\n    }\n    const keys = Object.keys(this.configurations);\n    for (let i = 0; i < keys.length; i += 1) {\n      if (compareWildcars(tag, keys[i])) {\n        return this.configurations[keys[i]];\n      }\n    }\n    return undefined;\n  }\n\n  loadPipelinesFromString(str = '') {\n    const lines = str.split(/\\n|\\r|\\r\\n/);\n    let currentName = '';\n    let currentPipeline = [];\n    let currentTitle = '';\n    for (let i = 0; i < lines.length; i += 1) {\n      const line = lines[i];\n      if (line !== '') {\n        if (line.startsWith('# ')) {\n          if (currentName) {\n            if (\n              currentTitle &&\n              !['default', 'pipelines'].includes(currentTitle.toLowerCase())\n            ) {\n              this.registerPipelineForChilds(\n                currentTitle,\n                currentName,\n                currentPipeline\n              );\n            } else {\n              this.registerPipeline(currentName, currentPipeline);\n            }\n          }\n          currentTitle = line.slice(1).trim();\n          currentName = '';\n          currentPipeline = [];\n        } else if (line.startsWith('## ')) {\n          if (currentName) {\n            if (\n              currentTitle &&\n              !['default', 'pipelines'].includes(currentTitle.toLowerCase())\n            ) {\n              this.registerPipelineForChilds(\n                currentTitle,\n                currentName,\n                currentPipeline\n              );\n            } else {\n              this.registerPipeline(currentName, currentPipeline);\n            }\n          }\n          currentName = line.slice(2).trim();\n          currentPipeline = [];\n        } else if (currentName) {\n          currentPipeline.push(line);\n        }\n      }\n    }\n    if (currentName) {\n      if (\n        currentTitle &&\n        !['default', 'pipelines'].includes(currentTitle.toLowerCase())\n      ) {\n        this.registerPipelineForChilds(\n          currentTitle,\n          currentName,\n          currentPipeline\n        );\n      } else {\n        this.registerPipeline(currentName, currentPipeline);\n      }\n    }\n  }\n\n  async start(pipelineName = 'main') {\n    const keys = Object.keys(this.factory);\n    for (let i = 0; i < keys.length; i += 1) {\n      const current = this.factory[keys[i]];\n      if (current.isSingleton && current.instance && current.instance.start) {\n        await current.instance.start();\n      }\n    }\n    if (this.getPipeline(pipelineName)) {\n      await this.runPipeline(pipelineName, {}, this);\n    }\n  }\n}\n\nconst defaultContainer = new Container();\n\nmodule.exports = {\n  Container,\n  defaultContainer,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}