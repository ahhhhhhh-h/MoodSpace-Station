{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  defaultContainer\n} = require('@nlpjs/core');\nconst reduceEdges = require('./reduce-edges');\nconst {\n  TrimType\n} = require('./trim-types');\nclass ExtractorTrim {\n  constructor(container = defaultContainer) {\n    this.container = container.container || container;\n    this.name = 'extract-trim';\n  }\n  mustSkip(word, condition) {\n    if (condition.options && condition.options.skip && condition.options.skip.length > 0) {\n      for (let i = 0; i < condition.options.skip.length; i += 1) {\n        const skipWord = condition.options.skip[i];\n        if (condition.options.caseSensitive) {\n          if (skipWord === word) {\n            return true;\n          }\n        } else if (skipWord.toLowerCase() === word.toLowerCase()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  matchBetween(utterance, condition, name) {\n    const result = [];\n    let matchFound;\n    do {\n      const match = condition.regex.exec(` ${utterance} `);\n      if (match) {\n        let matchIndex;\n        let startIndex;\n        let endIndex;\n        if (condition && condition.options && condition.options.closest) {\n          matchIndex = 1;\n          if (!match[matchIndex]) {\n            matchFound = false;\n            break;\n          }\n          const leftWordIndex = match[0].indexOf(match[matchIndex]);\n          startIndex = match.index - 1 + leftWordIndex;\n          endIndex = startIndex + match[matchIndex].length - 1;\n        } else {\n          matchIndex = 0;\n          startIndex = match.index - 1;\n          endIndex = condition.regex.lastIndex - 2;\n        }\n        result.push({\n          type: 'trim',\n          subtype: TrimType.Between,\n          start: startIndex,\n          end: endIndex,\n          len: match[matchIndex].length,\n          accuracy: 1,\n          sourceText: match[matchIndex],\n          utteranceText: match[matchIndex],\n          entity: name\n        });\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    const filteredResult = [];\n    for (let i = 0; i < result.length; i += 1) {\n      if (!this.mustSkip(result[i].utteranceText, condition)) {\n        filteredResult.push(result[i]);\n      }\n    }\n    return filteredResult;\n  }\n  findWord(utterance, word, caseSensitive = false, noSpaces = false) {\n    const result = [];\n    let matchFound;\n    const regex = new RegExp(noSpaces ? word : ` ${word} | ${word}|${word} `, caseSensitive ? 'g' : 'ig');\n    do {\n      const match = regex.exec(utterance);\n      if (match) {\n        result.push({\n          start: match.index,\n          end: regex.lastIndex\n        });\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    return result;\n  }\n  getBeforeResults(utterance, wordPositions, name) {\n    const result = [];\n    let startPos = 0;\n    let endPos = 0;\n    for (let i = 0; i < wordPositions.length; i += 1) {\n      endPos = wordPositions[i].start;\n      const text = utterance.substring(startPos, endPos);\n      result.push({\n        type: 'trim',\n        subtype: TrimType.Before,\n        start: startPos,\n        end: endPos - 1,\n        len: text.length,\n        accuracy: 0.99,\n        sourceText: text,\n        utteranceText: text,\n        entity: name\n      });\n      startPos = wordPositions[i].end;\n    }\n    return result;\n  }\n  getBeforeFirstResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = 0;\n    const endPos = wordPositions[0].start;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.BeforeFirst,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name\n    });\n    return result;\n  }\n  getBeforeLastResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = 0;\n    const endPos = wordPositions[wordPositions.length - 1].start;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.BeforeLast,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name\n    });\n    return result;\n  }\n  getAfterResults(utterance, wordPositions, name) {\n    const result = [];\n    let startPos = 0;\n    let endPos = utterance.length;\n    for (let i = wordPositions.length - 1; i >= 0; i -= 1) {\n      startPos = wordPositions[i].end;\n      const text = utterance.substring(startPos, endPos);\n      result.unshift({\n        type: 'trim',\n        subtype: TrimType.After,\n        start: startPos,\n        end: endPos - 1,\n        len: text.length,\n        accuracy: 0.99,\n        sourceText: text,\n        utteranceText: text,\n        entity: name\n      });\n      endPos = wordPositions[i].start;\n    }\n    return result;\n  }\n  getAfterFirstResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = wordPositions[0].end;\n    const endPos = utterance.length;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.AfterFirst,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name\n    });\n    return result;\n  }\n  getAfterLastResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = wordPositions[wordPositions.length - 1].end;\n    const endPos = utterance.length;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.AfterLast,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name\n    });\n    return result;\n  }\n  getResults(utterance, wordPositions, type, name) {\n    switch (type) {\n      case TrimType.Before:\n        return this.getBeforeResults(utterance, wordPositions, name);\n      case TrimType.BeforeFirst:\n        return this.getBeforeFirstResults(utterance, wordPositions, name);\n      case TrimType.BeforeLast:\n        return this.getBeforeLastResults(utterance, wordPositions, name);\n      case TrimType.After:\n        return this.getAfterResults(utterance, wordPositions, name);\n      case TrimType.AfterFirst:\n        return this.getAfterFirstResults(utterance, wordPositions, name);\n      case TrimType.AfterLast:\n        return this.getAfterLastResults(utterance, wordPositions, name);\n      default:\n        return [];\n    }\n  }\n  match(utterance, condition, type, name) {\n    const result = [];\n    if (condition && Array.isArray(condition.words)) {\n      for (let i = 0; i < condition.words.length; i += 1) {\n        const word = condition.options.noSpaces ? condition.words[i] : ` ${condition.words[i]}`;\n        const wordPositions = this.findWord(utterance, word);\n        if (!condition.options.noSpaces) {\n          const wordPositions2 = this.findWord(utterance, condition.words[i]);\n          if (wordPositions2.length > 0 && wordPositions2[0].start === 0) {\n            wordPositions.unshift(wordPositions2[0]);\n          }\n        }\n        if (wordPositions.length > 0) {\n          result.push(...this.getResults(utterance, wordPositions, type, name));\n        }\n      }\n    }\n    const filteredResult = [];\n    for (let i = 0; i < result.length; i += 1) {\n      // Remove common whitespace characters\n      result[i].sourceText = result[i].sourceText.replace(/^[\\s,.!?;:([\\]'\"¡¿)/]+|[\\s,.!?;:([\\]'\"¡¿)/]+$/, '');\n      if (!this.mustSkip(result[i].utteranceText, condition)) {\n        filteredResult.push(result[i]);\n      }\n    }\n    return filteredResult;\n  }\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n  extractFromRule(utterance, rule) {\n    const edges = [];\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const current = rule.rules[i];\n      if (current.type === TrimType.Between) {\n        edges.push(...this.matchBetween(utterance, current, rule.name));\n      } else {\n        edges.push(...this.match(utterance, current, current.type, rule.name));\n      }\n    }\n    return edges;\n  }\n  extract(srcInput) {\n    const input = srcInput;\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(input.text || input.utterance, rules[i]);\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false);\n    return input;\n  }\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-trim-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\nmodule.exports = ExtractorTrim;","map":{"version":3,"names":["defaultContainer","require","reduceEdges","TrimType","ExtractorTrim","constructor","container","name","mustSkip","word","condition","options","skip","length","i","skipWord","caseSensitive","toLowerCase","matchBetween","utterance","result","matchFound","match","regex","exec","matchIndex","startIndex","endIndex","closest","leftWordIndex","indexOf","index","lastIndex","push","type","subtype","Between","start","end","len","accuracy","sourceText","utteranceText","entity","filteredResult","findWord","noSpaces","RegExp","getBeforeResults","wordPositions","startPos","endPos","text","substring","Before","getBeforeFirstResults","BeforeFirst","getBeforeLastResults","BeforeLast","getAfterResults","unshift","After","getAfterFirstResults","AfterFirst","getAfterLastResults","AfterLast","getResults","Array","isArray","words","wordPositions2","replace","getRules","input","allRules","nerRules","extractFromRule","rule","edges","rules","current","extract","srcInput","newEdges","j","sort","a","b","run","locale","extractor","get","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/ner/src/extractor-trim.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { defaultContainer } = require('@nlpjs/core');\nconst reduceEdges = require('./reduce-edges');\nconst { TrimType } = require('./trim-types');\n\nclass ExtractorTrim {\n  constructor(container = defaultContainer) {\n    this.container = container.container || container;\n    this.name = 'extract-trim';\n  }\n\n  mustSkip(word, condition) {\n    if (\n      condition.options &&\n      condition.options.skip &&\n      condition.options.skip.length > 0\n    ) {\n      for (let i = 0; i < condition.options.skip.length; i += 1) {\n        const skipWord = condition.options.skip[i];\n        if (condition.options.caseSensitive) {\n          if (skipWord === word) {\n            return true;\n          }\n        } else if (skipWord.toLowerCase() === word.toLowerCase()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  matchBetween(utterance, condition, name) {\n    const result = [];\n    let matchFound;\n    do {\n      const match = condition.regex.exec(` ${utterance} `);\n      if (match) {\n        let matchIndex;\n        let startIndex;\n        let endIndex;\n        if (condition && condition.options && condition.options.closest) {\n          matchIndex = 1;\n          if (!match[matchIndex]) {\n            matchFound = false;\n            break;\n          }\n          const leftWordIndex = match[0].indexOf(match[matchIndex]);\n          startIndex = match.index - 1 + leftWordIndex;\n          endIndex = startIndex + match[matchIndex].length - 1;\n        } else {\n          matchIndex = 0;\n          startIndex = match.index - 1;\n          endIndex = condition.regex.lastIndex - 2;\n        }\n        result.push({\n          type: 'trim',\n          subtype: TrimType.Between,\n          start: startIndex,\n          end: endIndex,\n          len: match[matchIndex].length,\n          accuracy: 1,\n          sourceText: match[matchIndex],\n          utteranceText: match[matchIndex],\n          entity: name,\n        });\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    const filteredResult = [];\n    for (let i = 0; i < result.length; i += 1) {\n      if (!this.mustSkip(result[i].utteranceText, condition)) {\n        filteredResult.push(result[i]);\n      }\n    }\n    return filteredResult;\n  }\n\n  findWord(utterance, word, caseSensitive = false, noSpaces = false) {\n    const result = [];\n    let matchFound;\n    const regex = new RegExp(\n      noSpaces ? word : ` ${word} | ${word}|${word} `,\n      caseSensitive ? 'g' : 'ig'\n    );\n    do {\n      const match = regex.exec(utterance);\n      if (match) {\n        result.push({\n          start: match.index,\n          end: regex.lastIndex,\n        });\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    return result;\n  }\n\n  getBeforeResults(utterance, wordPositions, name) {\n    const result = [];\n    let startPos = 0;\n    let endPos = 0;\n    for (let i = 0; i < wordPositions.length; i += 1) {\n      endPos = wordPositions[i].start;\n      const text = utterance.substring(startPos, endPos);\n      result.push({\n        type: 'trim',\n        subtype: TrimType.Before,\n        start: startPos,\n        end: endPos - 1,\n        len: text.length,\n        accuracy: 0.99,\n        sourceText: text,\n        utteranceText: text,\n        entity: name,\n      });\n      startPos = wordPositions[i].end;\n    }\n    return result;\n  }\n\n  getBeforeFirstResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = 0;\n    const endPos = wordPositions[0].start;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.BeforeFirst,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name,\n    });\n    return result;\n  }\n\n  getBeforeLastResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = 0;\n    const endPos = wordPositions[wordPositions.length - 1].start;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.BeforeLast,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name,\n    });\n    return result;\n  }\n\n  getAfterResults(utterance, wordPositions, name) {\n    const result = [];\n    let startPos = 0;\n    let endPos = utterance.length;\n    for (let i = wordPositions.length - 1; i >= 0; i -= 1) {\n      startPos = wordPositions[i].end;\n      const text = utterance.substring(startPos, endPos);\n      result.unshift({\n        type: 'trim',\n        subtype: TrimType.After,\n        start: startPos,\n        end: endPos - 1,\n        len: text.length,\n        accuracy: 0.99,\n        sourceText: text,\n        utteranceText: text,\n        entity: name,\n      });\n      endPos = wordPositions[i].start;\n    }\n    return result;\n  }\n\n  getAfterFirstResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = wordPositions[0].end;\n    const endPos = utterance.length;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.AfterFirst,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name,\n    });\n    return result;\n  }\n\n  getAfterLastResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = wordPositions[wordPositions.length - 1].end;\n    const endPos = utterance.length;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.AfterLast,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name,\n    });\n    return result;\n  }\n\n  getResults(utterance, wordPositions, type, name) {\n    switch (type) {\n      case TrimType.Before:\n        return this.getBeforeResults(utterance, wordPositions, name);\n      case TrimType.BeforeFirst:\n        return this.getBeforeFirstResults(utterance, wordPositions, name);\n      case TrimType.BeforeLast:\n        return this.getBeforeLastResults(utterance, wordPositions, name);\n      case TrimType.After:\n        return this.getAfterResults(utterance, wordPositions, name);\n      case TrimType.AfterFirst:\n        return this.getAfterFirstResults(utterance, wordPositions, name);\n      case TrimType.AfterLast:\n        return this.getAfterLastResults(utterance, wordPositions, name);\n      default:\n        return [];\n    }\n  }\n\n  match(utterance, condition, type, name) {\n    const result = [];\n    if (condition && Array.isArray(condition.words)) {\n      for (let i = 0; i < condition.words.length; i += 1) {\n        const word = condition.options.noSpaces\n          ? condition.words[i]\n          : ` ${condition.words[i]}`;\n        const wordPositions = this.findWord(utterance, word);\n        if (!condition.options.noSpaces) {\n          const wordPositions2 = this.findWord(utterance, condition.words[i]);\n          if (wordPositions2.length > 0 && wordPositions2[0].start === 0) {\n            wordPositions.unshift(wordPositions2[0]);\n          }\n        }\n        if (wordPositions.length > 0) {\n          result.push(...this.getResults(utterance, wordPositions, type, name));\n        }\n      }\n    }\n    const filteredResult = [];\n    for (let i = 0; i < result.length; i += 1) {\n      // Remove common whitespace characters\n      result[i].sourceText = result[i].sourceText.replace(\n        /^[\\s,.!?;:([\\]'\"¡¿)/]+|[\\s,.!?;:([\\]'\"¡¿)/]+$/,\n        ''\n      );\n      if (!this.mustSkip(result[i].utteranceText, condition)) {\n        filteredResult.push(result[i]);\n      }\n    }\n    return filteredResult;\n  }\n\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n\n  extractFromRule(utterance, rule) {\n    const edges = [];\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const current = rule.rules[i];\n      if (current.type === TrimType.Between) {\n        edges.push(...this.matchBetween(utterance, current, rule.name));\n      } else {\n        edges.push(...this.match(utterance, current, current.type, rule.name));\n      }\n    }\n    return edges;\n  }\n\n  extract(srcInput) {\n    const input = srcInput;\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(\n        input.text || input.utterance,\n        rules[i]\n      );\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false);\n    return input;\n  }\n\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-trim-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\n\nmodule.exports = ExtractorTrim;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}