{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nclass Dictionary {\n  getElement(line) {\n    if (!line) {\n      return {\n        traditional: '',\n        simplified: ''\n      };\n    }\n    if (this.cache[line]) {\n      return this.cache[line];\n    }\n    const tokens = line.split(' ');\n    const element = {\n      traditional: tokens[0],\n      simplified: tokens[1],\n      pinyin: line.substring(line.indexOf('[') + 1, line.indexOf(']')),\n      definition: line.substring(line.indexOf('/') + 1, line.lastIndexOf('/'))\n    };\n    this.cache[line] = element;\n    return element;\n  }\n  start() {\n    if (!this.cedict) {\n      // eslint-disable-next-line global-require\n      this.cedict = require('./cedict_ts.u8');\n      console.log('Compiling dictionary');\n      this.cache = {};\n      this.simplified = {};\n      this.traditional = {};\n      const lines = this.cedict.split(/\\r?\\n/);\n      for (let i = 0; i < lines.length; i += 1) {\n        const line = lines[i];\n        if (!line.startsWith('#')) {\n          const current = this.getElement(line);\n          const definitions = [current];\n          let nextDefinition = this.getElement(lines[i + 1]);\n          while (nextDefinition.traditional === current.traditional && nextDefinition.simplified === current.simplified) {\n            i += 1;\n            definitions.push(nextDefinition);\n            nextDefinition = this.getElement(lines[i + 1]);\n          }\n          if (!this.simplified[current.simplified]) {\n            this.simplified[current.simplified] = [];\n          }\n          for (let j = 0; j < definitions.length; j += 1) {\n            this.simplified[current.simplified].push(definitions[j]);\n          }\n          if (!this.traditional[current.traditional]) {\n            this.traditional[current.traditional] = [];\n          }\n          for (let j = 0; j < definitions.length; j += 1) {\n            this.traditional[current.traditional].push(definitions[j]);\n          }\n        }\n      }\n      this.cache = undefined;\n    }\n  }\n  search(word) {\n    this.start();\n    return this.simplified[word] || this.traditional[word];\n  }\n  getPinyin(char) {\n    const definitions = this.search(char);\n    return definitions ? definitions.map(x => x.pinyin) : char;\n  }\n  getLongestMatch(text) {\n    const max = Math.min(8, text.length);\n    for (let i = max; i >= 0; i -= 1) {\n      const slice = text.substr(0, i);\n      if (this.search(slice)) {\n        return slice;\n      }\n    }\n    return undefined;\n  }\n  segment(text) {\n    const result = [];\n    while (text) {\n      const seg = this.getLongestMatch(text) || text.substr(0, 1);\n      result.push(seg);\n      text = text.slice(seg.length);\n    }\n    return result;\n  }\n}\nconst instance = new Dictionary();\nmodule.exports = instance;","map":{"version":3,"names":["Dictionary","getElement","line","traditional","simplified","cache","tokens","split","element","pinyin","substring","indexOf","definition","lastIndexOf","start","cedict","require","console","log","lines","i","length","startsWith","current","definitions","nextDefinition","push","j","undefined","search","word","getPinyin","char","map","x","getLongestMatch","text","max","Math","min","slice","substr","segment","result","seg","instance","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/lang-zh/src/dictionary.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nclass Dictionary {\n  getElement(line) {\n    if (!line) {\n      return {\n        traditional: '',\n        simplified: '',\n      };\n    }\n    if (this.cache[line]) {\n      return this.cache[line];\n    }\n    const tokens = line.split(' ');\n    const element = {\n      traditional: tokens[0],\n      simplified: tokens[1],\n      pinyin: line.substring(line.indexOf('[') + 1, line.indexOf(']')),\n      definition: line.substring(line.indexOf('/') + 1, line.lastIndexOf('/')),\n    };\n    this.cache[line] = element;\n    return element;\n  }\n\n  start() {\n    if (!this.cedict) {\n      // eslint-disable-next-line global-require\n      this.cedict = require('./cedict_ts.u8');\n      console.log('Compiling dictionary');\n      this.cache = {};\n      this.simplified = {};\n      this.traditional = {};\n      const lines = this.cedict.split(/\\r?\\n/);\n      for (let i = 0; i < lines.length; i += 1) {\n        const line = lines[i];\n        if (!line.startsWith('#')) {\n          const current = this.getElement(line);\n          const definitions = [current];\n          let nextDefinition = this.getElement(lines[i + 1]);\n          while (\n            nextDefinition.traditional === current.traditional &&\n            nextDefinition.simplified === current.simplified\n          ) {\n            i += 1;\n            definitions.push(nextDefinition);\n            nextDefinition = this.getElement(lines[i + 1]);\n          }\n          if (!this.simplified[current.simplified]) {\n            this.simplified[current.simplified] = [];\n          }\n          for (let j = 0; j < definitions.length; j += 1) {\n            this.simplified[current.simplified].push(definitions[j]);\n          }\n          if (!this.traditional[current.traditional]) {\n            this.traditional[current.traditional] = [];\n          }\n          for (let j = 0; j < definitions.length; j += 1) {\n            this.traditional[current.traditional].push(definitions[j]);\n          }\n        }\n      }\n      this.cache = undefined;\n    }\n  }\n\n  search(word) {\n    this.start();\n    return this.simplified[word] || this.traditional[word];\n  }\n\n  getPinyin(char) {\n    const definitions = this.search(char);\n    return definitions ? definitions.map((x) => x.pinyin) : char;\n  }\n\n  getLongestMatch(text) {\n    const max = Math.min(8, text.length);\n    for (let i = max; i >= 0; i -= 1) {\n      const slice = text.substr(0, i);\n      if (this.search(slice)) {\n        return slice;\n      }\n    }\n    return undefined;\n  }\n\n  segment(text) {\n    const result = [];\n    while (text) {\n      const seg = this.getLongestMatch(text) || text.substr(0, 1);\n      result.push(seg);\n      text = text.slice(seg.length);\n    }\n    return result;\n  }\n}\n\nconst instance = new Dictionary();\nmodule.exports = instance;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}