{"ast":null,"code":"/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar path = require(\"path\");\nvar async = require(\"async\");\nvar DynamicDictionaries = require(\"../dict/DynamicDictionaries\");\n\n/**\n * DictionaryLoader base constructor\n * @param {string} dic_path Dictionary path\n * @constructor\n */\nfunction DictionaryLoader(dic_path) {\n  this.dic = new DynamicDictionaries();\n  this.dic_path = dic_path;\n}\nDictionaryLoader.prototype.loadArrayBuffer = function (file, callback) {\n  throw new Error(\"DictionaryLoader#loadArrayBuffer should be overwrite\");\n};\n\n/**\n * Load dictionary files\n * @param {DictionaryLoader~onLoad} load_callback Callback function called after loaded\n */\nDictionaryLoader.prototype.load = function (load_callback) {\n  var dic = this.dic;\n  var dic_path = this.dic_path;\n  var loadArrayBuffer = this.loadArrayBuffer;\n  async.parallel([\n  // Trie\n  function (callback) {\n    async.map([\"base.dat.gz\", \"check.dat.gz\"], function (filename, _callback) {\n      loadArrayBuffer(path.join(dic_path, filename), function (err, buffer) {\n        if (err) {\n          return _callback(err);\n        }\n        _callback(null, buffer);\n      });\n    }, function (err, buffers) {\n      if (err) {\n        return callback(err);\n      }\n      var base_buffer = new Int32Array(buffers[0]);\n      var check_buffer = new Int32Array(buffers[1]);\n      dic.loadTrie(base_buffer, check_buffer);\n      callback(null);\n    });\n  },\n  // Token info dictionaries\n  function (callback) {\n    async.map([\"tid.dat.gz\", \"tid_pos.dat.gz\", \"tid_map.dat.gz\"], function (filename, _callback) {\n      loadArrayBuffer(path.join(dic_path, filename), function (err, buffer) {\n        if (err) {\n          return _callback(err);\n        }\n        _callback(null, buffer);\n      });\n    }, function (err, buffers) {\n      if (err) {\n        return callback(err);\n      }\n      var token_info_buffer = new Uint8Array(buffers[0]);\n      var pos_buffer = new Uint8Array(buffers[1]);\n      var target_map_buffer = new Uint8Array(buffers[2]);\n      dic.loadTokenInfoDictionaries(token_info_buffer, pos_buffer, target_map_buffer);\n      callback(null);\n    });\n  },\n  // Connection cost matrix\n  function (callback) {\n    loadArrayBuffer(path.join(dic_path, \"cc.dat.gz\"), function (err, buffer) {\n      if (err) {\n        return callback(err);\n      }\n      var cc_buffer = new Int16Array(buffer);\n      dic.loadConnectionCosts(cc_buffer);\n      callback(null);\n    });\n  },\n  // Unknown dictionaries\n  function (callback) {\n    async.map([\"unk.dat.gz\", \"unk_pos.dat.gz\", \"unk_map.dat.gz\", \"unk_char.dat.gz\", \"unk_compat.dat.gz\", \"unk_invoke.dat.gz\"], function (filename, _callback) {\n      loadArrayBuffer(path.join(dic_path, filename), function (err, buffer) {\n        if (err) {\n          return _callback(err);\n        }\n        _callback(null, buffer);\n      });\n    }, function (err, buffers) {\n      if (err) {\n        return callback(err);\n      }\n      var unk_buffer = new Uint8Array(buffers[0]);\n      var unk_pos_buffer = new Uint8Array(buffers[1]);\n      var unk_map_buffer = new Uint8Array(buffers[2]);\n      var cat_map_buffer = new Uint8Array(buffers[3]);\n      var compat_cat_map_buffer = new Uint32Array(buffers[4]);\n      var invoke_def_buffer = new Uint8Array(buffers[5]);\n      dic.loadUnknownDictionaries(unk_buffer, unk_pos_buffer, unk_map_buffer, cat_map_buffer, compat_cat_map_buffer, invoke_def_buffer);\n      // dic.loadUnknownDictionaries(char_buffer, unk_buffer);\n      callback(null);\n    });\n  }], function (err) {\n    load_callback(err, dic);\n  });\n};\n\n/**\n * Callback\n * @callback DictionaryLoader~onLoad\n * @param {Object} err Error object\n * @param {DynamicDictionaries} dic Loaded dictionary\n */\n\nmodule.exports = DictionaryLoader;","map":{"version":3,"names":["path","require","async","DynamicDictionaries","DictionaryLoader","dic_path","dic","prototype","loadArrayBuffer","file","callback","Error","load","load_callback","parallel","map","filename","_callback","join","err","buffer","buffers","base_buffer","Int32Array","check_buffer","loadTrie","token_info_buffer","Uint8Array","pos_buffer","target_map_buffer","loadTokenInfoDictionaries","cc_buffer","Int16Array","loadConnectionCosts","unk_buffer","unk_pos_buffer","unk_map_buffer","cat_map_buffer","compat_cat_map_buffer","Uint32Array","invoke_def_buffer","loadUnknownDictionaries","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/kuromoji/src/loader/DictionaryLoader.js"],"sourcesContent":["/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar path = require(\"path\");\nvar async = require(\"async\");\nvar DynamicDictionaries = require(\"../dict/DynamicDictionaries\");\n\n/**\n * DictionaryLoader base constructor\n * @param {string} dic_path Dictionary path\n * @constructor\n */\nfunction DictionaryLoader(dic_path) {\n    this.dic = new DynamicDictionaries();\n    this.dic_path = dic_path;\n}\n\nDictionaryLoader.prototype.loadArrayBuffer = function (file, callback) {\n    throw new Error(\"DictionaryLoader#loadArrayBuffer should be overwrite\");\n};\n\n/**\n * Load dictionary files\n * @param {DictionaryLoader~onLoad} load_callback Callback function called after loaded\n */\nDictionaryLoader.prototype.load = function (load_callback) {\n    var dic = this.dic;\n    var dic_path = this.dic_path;\n    var loadArrayBuffer = this.loadArrayBuffer;\n\n    async.parallel([\n        // Trie\n        function (callback) {\n            async.map([ \"base.dat.gz\", \"check.dat.gz\" ], function (filename, _callback) {\n                loadArrayBuffer(path.join(dic_path, filename), function (err, buffer) {\n                    if(err) {\n                        return _callback(err);\n                    }\n                    _callback(null, buffer);\n                });\n            }, function (err, buffers) {\n                if(err) {\n                    return callback(err);\n                }\n                var base_buffer = new Int32Array(buffers[0]);\n                var check_buffer = new Int32Array(buffers[1]);\n\n                dic.loadTrie(base_buffer, check_buffer);\n                callback(null);\n            });\n        },\n        // Token info dictionaries\n        function (callback) {\n            async.map([ \"tid.dat.gz\", \"tid_pos.dat.gz\", \"tid_map.dat.gz\" ], function (filename, _callback) {\n                loadArrayBuffer(path.join(dic_path, filename), function (err, buffer) {\n                    if(err) {\n                        return _callback(err);\n                    }\n                    _callback(null, buffer);\n                });\n            }, function (err, buffers) {\n                if(err) {\n                    return callback(err);\n                }\n                var token_info_buffer = new Uint8Array(buffers[0]);\n                var pos_buffer = new Uint8Array(buffers[1]);\n                var target_map_buffer = new Uint8Array(buffers[2]);\n\n                dic.loadTokenInfoDictionaries(token_info_buffer, pos_buffer, target_map_buffer);\n                callback(null);\n            });\n        },\n        // Connection cost matrix\n        function (callback) {\n            loadArrayBuffer(path.join(dic_path, \"cc.dat.gz\"), function (err, buffer) {\n                if(err) {\n                    return callback(err);\n                }\n                var cc_buffer = new Int16Array(buffer);\n                dic.loadConnectionCosts(cc_buffer);\n                callback(null);\n            });\n        },\n        // Unknown dictionaries\n        function (callback) {\n            async.map([ \"unk.dat.gz\", \"unk_pos.dat.gz\", \"unk_map.dat.gz\", \"unk_char.dat.gz\", \"unk_compat.dat.gz\", \"unk_invoke.dat.gz\" ], function (filename, _callback) {\n                loadArrayBuffer(path.join(dic_path, filename), function (err, buffer) {\n                    if(err) {\n                        return _callback(err);\n                    }\n                    _callback(null, buffer);\n                });\n            }, function (err, buffers) {\n                if(err) {\n                    return callback(err);\n                }\n                var unk_buffer = new Uint8Array(buffers[0]);\n                var unk_pos_buffer = new Uint8Array(buffers[1]);\n                var unk_map_buffer = new Uint8Array(buffers[2]);\n                var cat_map_buffer = new Uint8Array(buffers[3]);\n                var compat_cat_map_buffer = new Uint32Array(buffers[4]);\n                var invoke_def_buffer = new Uint8Array(buffers[5]);\n\n                dic.loadUnknownDictionaries(unk_buffer, unk_pos_buffer, unk_map_buffer, cat_map_buffer, compat_cat_map_buffer, invoke_def_buffer);\n                // dic.loadUnknownDictionaries(char_buffer, unk_buffer);\n                callback(null);\n            });\n        }\n    ], function (err) {\n        load_callback(err, dic);\n    });\n};\n\n/**\n * Callback\n * @callback DictionaryLoader~onLoad\n * @param {Object} err Error object\n * @param {DynamicDictionaries} dic Loaded dictionary\n */\n\nmodule.exports = DictionaryLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}