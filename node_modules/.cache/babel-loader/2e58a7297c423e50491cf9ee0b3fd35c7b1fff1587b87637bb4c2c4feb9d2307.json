{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst {\n  TrimTypesList\n} = require('./trim-types');\nfunction runDiscard(srcEdge, srcOther, useMaxLength, intentEntities = []) {\n  let edge;\n  let other;\n  if (srcEdge.accuracy > srcOther.accuracy || srcEdge.accuracy === srcOther.accuracy && srcEdge.length > srcOther.length) {\n    edge = srcEdge;\n    other = srcOther;\n  } else {\n    edge = srcOther;\n    other = srcEdge;\n  }\n  if (other.start <= edge.end && other.end >= edge.start) {\n    if (other.accuracy < edge.accuracy) {\n      other.discarded = true;\n    } else if ((useMaxLength || other.entity === edge.entity || other.entity === 'number') && other.len <= edge.len) {\n      // Entities have same priority\n      if (other.start === edge.start && other.end === edge.end && other.type === edge.type && other.entity === edge.entity && other.option === edge.option) {\n        // same type and none of them is an enum or both are an enum\n        other.discarded = true;\n      } else if (other.start === edge.start && other.end === edge.end && other.entity === edge.entity && other.type !== edge.type) {\n        if (edge.type === 'trim' && other.type !== 'trim') {\n          edge.discarded = true;\n        } else if (edge.type !== 'trim' && other.type === 'trim') {\n          other.discarded = true;\n        } else {\n          other.discarded = true;\n        }\n      }\n    } else if ((useMaxLength || other.entity === edge.entity || edge.entity === 'number') && other.len > edge.len) {\n      edge.discarded = true;\n    } else if (edge.type === 'enum' && other.type === 'enum') {\n      const edgeIncludedInIntentEntities = intentEntities.includes(edge.entity);\n      const otherIncludedInIntentEntities = intentEntities.includes(other.entity);\n      if (edgeIncludedInIntentEntities && !otherIncludedInIntentEntities) {\n        other.discarded = true;\n      } else if (!edgeIncludedInIntentEntities && otherIncludedInIntentEntities) {\n        edge.discarded = true;\n      } else if (edge.len <= other.len && other.utteranceText.includes(edge.utteranceText)) {\n        edge.discarded = true;\n      } else if (edge.len > other.len && edge.utteranceText.includes(other.utteranceText)) {\n        other.discarded = true;\n      }\n    }\n  }\n}\n\n/**\n * Given an array of edges, detect the trim edges and find overlaps with\n * non-trim edges. When an overlap is detected, reduce the trim edged to\n * fit with the other edge. Only cases where it overlaps on beginning or\n * end are handled\n * @param {Object[]} edges Edges to be splitted\n * @returns {Object[]} Splitted edges.\n */\nfunction splitEdges(edges) {\n  for (let i = 0, l = edges.length; i < l; i += 1) {\n    const edge = edges[i];\n    if (edge.type === 'trim' && TrimTypesList.includes(edge.subtype)) {\n      for (let j = 0; j < edges.length; j += 1) {\n        const other = edges[j];\n        if (i !== j && other.start >= edge.start && other.end <= edge.end && other.type !== 'trim') {\n          const edgeLen = edge.end - edge.start;\n          const otherLen = other.end - other.start;\n          if (edge.end === other.end) {\n            // is at the end\n            const text = edge.sourceText.substring(0, edgeLen - otherLen - 1);\n            edge.sourceText = text;\n            edge.utteranceText = text;\n            edge.end = other.start - 1;\n            edge.len = text.length;\n          } else if (edge.start === other.start) {\n            // is at the start\n            const text = edge.sourceText.substring(otherLen + 1);\n            edge.sourceText = text;\n            edge.utteranceText = text;\n            edge.start = other.end + 1;\n            edge.len = text.length;\n          }\n        }\n      }\n    }\n  }\n  return edges;\n}\nfunction reduceEdges(edges, useMaxLength = true, intentEntities = []) {\n  edges = splitEdges(edges);\n  const edgeslen = edges.length;\n  for (let i = 0; i < edgeslen; i += 1) {\n    const edge = edges[i];\n    if (edge.len === 0) {\n      edge.discarded = true;\n    }\n    if (!edge.discarded) {\n      for (let j = i + 1; j < edgeslen; j += 1) {\n        const other = edges[j];\n        if (!other.discarded) {\n          runDiscard(edge, other, useMaxLength, intentEntities);\n        }\n        if (edge.discarded) {\n          break;\n        }\n      }\n    }\n    if (!edge.discarded) {\n      const knownEntityPos = intentEntities.indexOf(edge.entity);\n      if (knownEntityPos !== -1) {\n        intentEntities.splice(knownEntityPos, 1);\n      }\n    }\n  }\n  return edges.filter(x => !x.discarded);\n}\nmodule.exports = reduceEdges;","map":{"version":3,"names":["TrimTypesList","require","runDiscard","srcEdge","srcOther","useMaxLength","intentEntities","edge","other","accuracy","length","start","end","discarded","entity","len","type","option","edgeIncludedInIntentEntities","includes","otherIncludedInIntentEntities","utteranceText","splitEdges","edges","i","l","subtype","j","edgeLen","otherLen","text","sourceText","substring","reduceEdges","edgeslen","knownEntityPos","indexOf","splice","filter","x","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/ner/src/reduce-edges.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst { TrimTypesList } = require('./trim-types');\n\nfunction runDiscard(srcEdge, srcOther, useMaxLength, intentEntities = []) {\n  let edge;\n  let other;\n  if (\n    srcEdge.accuracy > srcOther.accuracy ||\n    (srcEdge.accuracy === srcOther.accuracy && srcEdge.length > srcOther.length)\n  ) {\n    edge = srcEdge;\n    other = srcOther;\n  } else {\n    edge = srcOther;\n    other = srcEdge;\n  }\n  if (other.start <= edge.end && other.end >= edge.start) {\n    if (other.accuracy < edge.accuracy) {\n      other.discarded = true;\n    } else if (\n      (useMaxLength ||\n        other.entity === edge.entity ||\n        other.entity === 'number') &&\n      other.len <= edge.len\n    ) {\n      // Entities have same priority\n      if (\n        other.start === edge.start &&\n        other.end === edge.end &&\n        other.type === edge.type &&\n        other.entity === edge.entity &&\n        other.option === edge.option\n      ) {\n        // same type and none of them is an enum or both are an enum\n        other.discarded = true;\n      } else if (\n        other.start === edge.start &&\n        other.end === edge.end &&\n        other.entity === edge.entity &&\n        other.type !== edge.type\n      ) {\n        if (edge.type === 'trim' && other.type !== 'trim') {\n          edge.discarded = true;\n        } else if (edge.type !== 'trim' && other.type === 'trim') {\n          other.discarded = true;\n        } else {\n          other.discarded = true;\n        }\n      }\n    } else if (\n      (useMaxLength ||\n        other.entity === edge.entity ||\n        edge.entity === 'number') &&\n      other.len > edge.len\n    ) {\n      edge.discarded = true;\n    } else if (edge.type === 'enum' && other.type === 'enum') {\n      const edgeIncludedInIntentEntities = intentEntities.includes(edge.entity);\n      const otherIncludedInIntentEntities = intentEntities.includes(\n        other.entity\n      );\n      if (edgeIncludedInIntentEntities && !otherIncludedInIntentEntities) {\n        other.discarded = true;\n      } else if (\n        !edgeIncludedInIntentEntities &&\n        otherIncludedInIntentEntities\n      ) {\n        edge.discarded = true;\n      } else if (\n        edge.len <= other.len &&\n        other.utteranceText.includes(edge.utteranceText)\n      ) {\n        edge.discarded = true;\n      } else if (\n        edge.len > other.len &&\n        edge.utteranceText.includes(other.utteranceText)\n      ) {\n        other.discarded = true;\n      }\n    }\n  }\n}\n\n/**\n * Given an array of edges, detect the trim edges and find overlaps with\n * non-trim edges. When an overlap is detected, reduce the trim edged to\n * fit with the other edge. Only cases where it overlaps on beginning or\n * end are handled\n * @param {Object[]} edges Edges to be splitted\n * @returns {Object[]} Splitted edges.\n */\nfunction splitEdges(edges) {\n  for (let i = 0, l = edges.length; i < l; i += 1) {\n    const edge = edges[i];\n    if (edge.type === 'trim' && TrimTypesList.includes(edge.subtype)) {\n      for (let j = 0; j < edges.length; j += 1) {\n        const other = edges[j];\n        if (\n          i !== j &&\n          other.start >= edge.start &&\n          other.end <= edge.end &&\n          other.type !== 'trim'\n        ) {\n          const edgeLen = edge.end - edge.start;\n          const otherLen = other.end - other.start;\n          if (edge.end === other.end) {\n            // is at the end\n            const text = edge.sourceText.substring(0, edgeLen - otherLen - 1);\n            edge.sourceText = text;\n            edge.utteranceText = text;\n            edge.end = other.start - 1;\n            edge.len = text.length;\n          } else if (edge.start === other.start) {\n            // is at the start\n            const text = edge.sourceText.substring(otherLen + 1);\n            edge.sourceText = text;\n            edge.utteranceText = text;\n            edge.start = other.end + 1;\n            edge.len = text.length;\n          }\n        }\n      }\n    }\n  }\n  return edges;\n}\n\nfunction reduceEdges(edges, useMaxLength = true, intentEntities = []) {\n  edges = splitEdges(edges);\n  const edgeslen = edges.length;\n  for (let i = 0; i < edgeslen; i += 1) {\n    const edge = edges[i];\n    if (edge.len === 0) {\n      edge.discarded = true;\n    }\n    if (!edge.discarded) {\n      for (let j = i + 1; j < edgeslen; j += 1) {\n        const other = edges[j];\n        if (!other.discarded) {\n          runDiscard(edge, other, useMaxLength, intentEntities);\n        }\n        if (edge.discarded) {\n          break;\n        }\n      }\n    }\n    if (!edge.discarded) {\n      const knownEntityPos = intentEntities.indexOf(edge.entity);\n      if (knownEntityPos !== -1) {\n        intentEntities.splice(knownEntityPos, 1);\n      }\n    }\n  }\n  return edges.filter((x) => !x.discarded);\n}\n\nmodule.exports = reduceEdges;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}