{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  NlpManager\n} = require('../nlp');\nconst MemoryConversationContext = require('./memory-conversation-context');\n\n/**\n * Microsoft Bot Framework compatible recognizer for nlp.js.\n */\nclass Recognizer {\n  /**\n   * Constructor of the class.\n   * @param {Object} settings Settings for the instance.\n   */\n  constructor(settings) {\n    this.settings = settings || {};\n    this.nlpManager = this.settings.nlpManager || new NlpManager({\n      container: this.settings.container,\n      ner: {\n        threshold: this.settings.nerThreshold || 1\n      }\n    });\n    this.threshold = this.settings.threshold || 0.7;\n    this.conversationContext = this.settings.conversationContext || new MemoryConversationContext();\n  }\n\n  /**\n   * Train the NLP manager.\n   */\n  async train() {\n    await this.nlpManager.train();\n  }\n\n  /**\n   * Loads the model from a file.\n   * @param {String} filename Name of the file.\n   */\n  load(filename) {\n    this.nlpManager.load(filename);\n  }\n\n  /**\n   * Saves the model into a file.\n   * @param {String} filename Name of the file.\n   */\n  save(filename) {\n    this.nlpManager.save(filename);\n  }\n\n  /**\n   * Loads the NLP manager from an excel.\n   * @param {String} filename Name of the file.\n   */\n  async loadExcel(filename) {\n    this.nlpManager.loadExcel(filename);\n    await this.train();\n    this.save();\n  }\n\n  /**\n   * Process an utterance using the NLP manager. This is done using a given context\n   * as the context object.\n   * @param {Object} srcContext Source context\n   * @param {String} locale Locale of the utterance.\n   * @param {Promise.String} Promise utterance Utterance to be recognized.\n   */\n  async process(srcContext, locale, utterance) {\n    const context = srcContext || {};\n    const response = await (locale ? this.nlpManager.process(locale, utterance, context) : this.nlpManager.process(utterance, undefined, context));\n    if (response.score < this.threshold || response.intent === 'None') {\n      response.answer = undefined;\n      return response;\n    }\n    for (let i = 0; i < response.entities.length; i += 1) {\n      const entity = response.entities[i];\n      context[entity.entity] = entity.option;\n    }\n    if (response.slotFill) {\n      context.slotFill = response.slotFill;\n    } else {\n      delete context.slotFill;\n    }\n    return response;\n  }\n\n  /**\n   * Given an utterance and the locale, returns the recognition of the utterance.\n   * @param {String} utterance Utterance to be recognized.\n   * @param {String} model Model of the utterance.\n   * @param {Function} cb Callback Function.\n   */\n  async recognizeUtterance(utterance, model, cb) {\n    const response = await this.process(model, model ? model.locale : undefined, utterance, {});\n    return cb(null, response);\n  }\n\n  /**\n   * Gets the last developer (not framework) dialogId on the stack.\n   * @param {Object} session Microsoft bot framework session.\n   * @returns {string} Last dialog id.\n   */\n  getDialogId(session) {\n    if (!session.dialogStack) {\n      return '';\n    }\n    const stack = session.dialogStack();\n    for (let i = 0; i < stack.length; i += 1) {\n      const dialogId = stack[i];\n      if (dialogId.startsWith('*:')) {\n        return dialogId.substring(2);\n      }\n    }\n    return '';\n  }\n  innerRecognize(session, cb) {\n    const result = {\n      score: 0.0,\n      intent: undefined\n    };\n    if (session && session.message && session.message.text) {\n      const utterance = session.message.text;\n      const {\n        locale\n      } = session;\n      this.conversationContext.getConversationContext(session).then(async srcContext => {\n        const context = srcContext;\n        context.dialogId = this.getDialogId(session);\n        const processResult = await this.process(context, locale, utterance);\n        context.lastRecognized = processResult;\n        this.conversationContext.setConversationContext(session, context).then(() => cb(null, processResult)).catch(() => cb(null, processResult));\n        return undefined;\n      }).catch(async () => {\n        const processResult = await this.process({}, locale, utterance);\n        return cb(null, processResult);\n      });\n      return undefined;\n    }\n    // eslint-disable-next-line no-underscore-dangle\n    if (session && session._activity && session._activity.type === 'message') {\n      // eslint-disable-next-line no-underscore-dangle\n      const message = session._activity;\n      const utterance = message.text;\n      const {\n        locale\n      } = message;\n      this.conversationContext.getConversationContext(session).then(async srcContext => {\n        const context = srcContext;\n        const processResult = await this.process(context, locale, utterance);\n        context.lastRecognized = processResult;\n        this.conversationContext.setConversationContext(session, context).then(() => cb(null, processResult)).catch(() => cb(null, processResult));\n        return undefined;\n      }).catch(async () => {\n        const processResult = await this.process({}, locale, utterance);\n        return cb(null, processResult);\n      });\n      return undefined;\n    }\n    return cb(null, result);\n  }\n\n  /**\n   * Given a session of a chatbot containing a message, recognize the utterance in the message.\n   * @param {Object} session Chatbot session of the message.\n   * @param {Function} cb Callback function.\n   */\n  recognize(session, cb) {\n    if (cb) {\n      return this.innerRecognize(session, cb);\n    }\n    return new Promise((resolve, reject) => {\n      this.innerRecognize(session, (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n        return resolve(result);\n      });\n    });\n  }\n\n  /**\n   * Given a session of a chatbot containing a message, recognize for second time\n   * the utterance in the message.\n   * @param {Object} session Chatbot session of the message.\n   * @param {Function} cb Callback function.\n   */\n  recognizeTwice(session, cb) {\n    this.conversationContext.getConversationContext(session).then(async srcContext => {\n      const context = srcContext;\n      if (context.lastRecognized) {\n        const processResult = context.lastRecognized;\n        delete context.lastRecognized;\n        this.conversationContext.setConversationContext(session, context).then(() => cb(null, processResult)).catch(() => cb(null, processResult));\n      } else {\n        return this.recognize(session, cb);\n      }\n      return undefined;\n    }).catch(async () => this.recognize(session, cb));\n  }\n\n  /**\n   * Route to a default route of the bot. First the route is calculated as the\n   * best route based on the results and the dialog stack. If no best route exists\n   * then is routed to the active dialog.\n   * @param {Object} bot Microsoft Bot Framework Universal Bot instance.\n   * @param {Object} session Microsoft bot framework session.\n   * @param {Object} results Results for the routing.\n   */\n  defaultRouting(bot, session, results) {\n    const route = bot.libraries.BotBuilder.constructor.bestRouteResult(results, session.dialogStack(), bot.name);\n    if (route) {\n      return bot.library(route.libraryName).selectRoute(session, route);\n    }\n    return session.routeToActiveDialog();\n  }\n  executeAction(name, parameters, context) {\n    return new Promise(resolve => {\n      const params = JSON.parse(`[${parameters}]`);\n      if (this.actions[name]) {\n        const action = this.actions[name](this, context, ...(params || []));\n        if (action.then) {\n          action.then(() => resolve());\n        } else {\n          resolve();\n        }\n      }\n      resolve();\n    });\n  }\n  processActions(session, response, cb) {\n    if (!response || !response.actions || response.actions.length === 0) {\n      return cb();\n    }\n    this.conversationContext.getConversationContext(session).then(async srcContext => {\n      const context = srcContext;\n      const {\n        actions\n      } = response;\n      const promises = actions.map(action => this.executeAction(action.action, action.parameters, context));\n      Promise.all(promises).then(() => cb()).catch(err => cb(err));\n    }).catch(async () => cb());\n    return undefined;\n  }\n\n  /**\n   * When an answer is received over the threshold, decide what to do with this answer.\n   * @param {Object} session Microsoft bot framework session.\n   * @param {string} answer Answer given by the NLP.\n   */\n  processAnswer(session, answer) {\n    if (answer[0] === '/') {\n      return session.beginDialog(answer);\n    }\n    return session.send(answer);\n  }\n\n  /**\n   * Sets the recognizer to a Microsoft bot framework universal bot instance.\n   * Also, the default bot routing can be overrided and replaced by the\n   * recognizer routing.\n   * @param {Object} bot Microsoft Bot Framework Universal Bot instance.\n   * @param {boolean} activateRouting True if default routing should be overrided.\n   * @param {number} routingThreshold Threshold for the score of the intent.\n   */\n  setBot(bot, activateRouting = false, routingThreshold = 0.7) {\n    bot.recognizer(this);\n    if (!activateRouting) {\n      return;\n    }\n    const self = this;\n    // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n    bot._onDisambiguateRoute = function disambiguate(session, results, cb = () => {}) {\n      if (self.onBeginRouting && !self.onBeginRouting(session)) {\n        return cb();\n      }\n      if (session.message && session.message.text) {\n        self.recognizeTwice(session, (err, result) => {\n          if (result.score > routingThreshold) {\n            if (self.onRecognizedRouting && !self.onRecognizedRouting(session, result)) {\n              return cb();\n            }\n            self.processActions(session, result, () => {\n              if (result.answer && result.answer !== '') {\n                self.processAnswer(session, result.answer);\n              }\n              return cb();\n            });\n            return undefined;\n          }\n          if (self.onUnrecognizedRouting && !self.onUnrecognizedRouting(session, result)) {\n            return cb();\n          }\n          self.defaultRouting(bot, session, results);\n          return cb();\n        });\n      } else {\n        if (self.onNoTextRouting && !self.onNoTextRouting(session)) {\n          return cb();\n        }\n        self.defaultRouting(bot, session, results);\n        return cb();\n      }\n      return undefined;\n    };\n  }\n}\nmodule.exports = Recognizer;","map":{"version":3,"names":["NlpManager","require","MemoryConversationContext","Recognizer","constructor","settings","nlpManager","container","ner","threshold","nerThreshold","conversationContext","train","load","filename","save","loadExcel","process","srcContext","locale","utterance","context","response","undefined","score","intent","answer","i","entities","length","entity","option","slotFill","recognizeUtterance","model","cb","getDialogId","session","dialogStack","stack","dialogId","startsWith","substring","innerRecognize","result","message","text","getConversationContext","then","processResult","lastRecognized","setConversationContext","catch","_activity","type","recognize","Promise","resolve","reject","err","recognizeTwice","defaultRouting","bot","results","route","libraries","BotBuilder","bestRouteResult","name","library","libraryName","selectRoute","routeToActiveDialog","executeAction","parameters","params","JSON","parse","actions","action","processActions","promises","map","all","processAnswer","beginDialog","send","setBot","activateRouting","routingThreshold","recognizer","self","_onDisambiguateRoute","disambiguate","onBeginRouting","onRecognizedRouting","onUnrecognizedRouting","onNoTextRouting","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/node-nlp/src/recognizer/recognizer.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { NlpManager } = require('../nlp');\nconst MemoryConversationContext = require('./memory-conversation-context');\n\n/**\n * Microsoft Bot Framework compatible recognizer for nlp.js.\n */\nclass Recognizer {\n  /**\n   * Constructor of the class.\n   * @param {Object} settings Settings for the instance.\n   */\n  constructor(settings) {\n    this.settings = settings || {};\n    this.nlpManager =\n      this.settings.nlpManager ||\n      new NlpManager({\n        container: this.settings.container,\n        ner: { threshold: this.settings.nerThreshold || 1 },\n      });\n    this.threshold = this.settings.threshold || 0.7;\n    this.conversationContext =\n      this.settings.conversationContext || new MemoryConversationContext();\n  }\n\n  /**\n   * Train the NLP manager.\n   */\n  async train() {\n    await this.nlpManager.train();\n  }\n\n  /**\n   * Loads the model from a file.\n   * @param {String} filename Name of the file.\n   */\n  load(filename) {\n    this.nlpManager.load(filename);\n  }\n\n  /**\n   * Saves the model into a file.\n   * @param {String} filename Name of the file.\n   */\n  save(filename) {\n    this.nlpManager.save(filename);\n  }\n\n  /**\n   * Loads the NLP manager from an excel.\n   * @param {String} filename Name of the file.\n   */\n  async loadExcel(filename) {\n    this.nlpManager.loadExcel(filename);\n    await this.train();\n    this.save();\n  }\n\n  /**\n   * Process an utterance using the NLP manager. This is done using a given context\n   * as the context object.\n   * @param {Object} srcContext Source context\n   * @param {String} locale Locale of the utterance.\n   * @param {Promise.String} Promise utterance Utterance to be recognized.\n   */\n  async process(srcContext, locale, utterance) {\n    const context = srcContext || {};\n    const response = await (locale\n      ? this.nlpManager.process(locale, utterance, context)\n      : this.nlpManager.process(utterance, undefined, context));\n    if (response.score < this.threshold || response.intent === 'None') {\n      response.answer = undefined;\n      return response;\n    }\n    for (let i = 0; i < response.entities.length; i += 1) {\n      const entity = response.entities[i];\n      context[entity.entity] = entity.option;\n    }\n    if (response.slotFill) {\n      context.slotFill = response.slotFill;\n    } else {\n      delete context.slotFill;\n    }\n    return response;\n  }\n\n  /**\n   * Given an utterance and the locale, returns the recognition of the utterance.\n   * @param {String} utterance Utterance to be recognized.\n   * @param {String} model Model of the utterance.\n   * @param {Function} cb Callback Function.\n   */\n  async recognizeUtterance(utterance, model, cb) {\n    const response = await this.process(\n      model,\n      model ? model.locale : undefined,\n      utterance,\n      {}\n    );\n    return cb(null, response);\n  }\n\n  /**\n   * Gets the last developer (not framework) dialogId on the stack.\n   * @param {Object} session Microsoft bot framework session.\n   * @returns {string} Last dialog id.\n   */\n  getDialogId(session) {\n    if (!session.dialogStack) {\n      return '';\n    }\n    const stack = session.dialogStack();\n    for (let i = 0; i < stack.length; i += 1) {\n      const dialogId = stack[i];\n      if (dialogId.startsWith('*:')) {\n        return dialogId.substring(2);\n      }\n    }\n    return '';\n  }\n\n  innerRecognize(session, cb) {\n    const result = { score: 0.0, intent: undefined };\n    if (session && session.message && session.message.text) {\n      const utterance = session.message.text;\n      const { locale } = session;\n      this.conversationContext\n        .getConversationContext(session)\n        .then(async (srcContext) => {\n          const context = srcContext;\n          context.dialogId = this.getDialogId(session);\n          const processResult = await this.process(context, locale, utterance);\n          context.lastRecognized = processResult;\n          this.conversationContext\n            .setConversationContext(session, context)\n            .then(() => cb(null, processResult))\n            .catch(() => cb(null, processResult));\n          return undefined;\n        })\n        .catch(async () => {\n          const processResult = await this.process({}, locale, utterance);\n          return cb(null, processResult);\n        });\n      return undefined;\n    }\n    // eslint-disable-next-line no-underscore-dangle\n    if (session && session._activity && session._activity.type === 'message') {\n      // eslint-disable-next-line no-underscore-dangle\n      const message = session._activity;\n      const utterance = message.text;\n      const { locale } = message;\n      this.conversationContext\n        .getConversationContext(session)\n        .then(async (srcContext) => {\n          const context = srcContext;\n          const processResult = await this.process(context, locale, utterance);\n          context.lastRecognized = processResult;\n          this.conversationContext\n            .setConversationContext(session, context)\n            .then(() => cb(null, processResult))\n            .catch(() => cb(null, processResult));\n          return undefined;\n        })\n        .catch(async () => {\n          const processResult = await this.process({}, locale, utterance);\n          return cb(null, processResult);\n        });\n      return undefined;\n    }\n    return cb(null, result);\n  }\n\n  /**\n   * Given a session of a chatbot containing a message, recognize the utterance in the message.\n   * @param {Object} session Chatbot session of the message.\n   * @param {Function} cb Callback function.\n   */\n  recognize(session, cb) {\n    if (cb) {\n      return this.innerRecognize(session, cb);\n    }\n    return new Promise((resolve, reject) => {\n      this.innerRecognize(session, (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n        return resolve(result);\n      });\n    });\n  }\n\n  /**\n   * Given a session of a chatbot containing a message, recognize for second time\n   * the utterance in the message.\n   * @param {Object} session Chatbot session of the message.\n   * @param {Function} cb Callback function.\n   */\n  recognizeTwice(session, cb) {\n    this.conversationContext\n      .getConversationContext(session)\n      .then(async (srcContext) => {\n        const context = srcContext;\n        if (context.lastRecognized) {\n          const processResult = context.lastRecognized;\n          delete context.lastRecognized;\n          this.conversationContext\n            .setConversationContext(session, context)\n            .then(() => cb(null, processResult))\n            .catch(() => cb(null, processResult));\n        } else {\n          return this.recognize(session, cb);\n        }\n        return undefined;\n      })\n      .catch(async () => this.recognize(session, cb));\n  }\n\n  /**\n   * Route to a default route of the bot. First the route is calculated as the\n   * best route based on the results and the dialog stack. If no best route exists\n   * then is routed to the active dialog.\n   * @param {Object} bot Microsoft Bot Framework Universal Bot instance.\n   * @param {Object} session Microsoft bot framework session.\n   * @param {Object} results Results for the routing.\n   */\n  defaultRouting(bot, session, results) {\n    const route = bot.libraries.BotBuilder.constructor.bestRouteResult(\n      results,\n      session.dialogStack(),\n      bot.name\n    );\n    if (route) {\n      return bot.library(route.libraryName).selectRoute(session, route);\n    }\n    return session.routeToActiveDialog();\n  }\n\n  executeAction(name, parameters, context) {\n    return new Promise((resolve) => {\n      const params = JSON.parse(`[${parameters}]`);\n      if (this.actions[name]) {\n        const action = this.actions[name](this, context, ...(params || []));\n        if (action.then) {\n          action.then(() => resolve());\n        } else {\n          resolve();\n        }\n      }\n      resolve();\n    });\n  }\n\n  processActions(session, response, cb) {\n    if (!response || !response.actions || response.actions.length === 0) {\n      return cb();\n    }\n    this.conversationContext\n      .getConversationContext(session)\n      .then(async (srcContext) => {\n        const context = srcContext;\n        const { actions } = response;\n        const promises = actions.map((action) =>\n          this.executeAction(action.action, action.parameters, context)\n        );\n        Promise.all(promises)\n          .then(() => cb())\n          .catch((err) => cb(err));\n      })\n      .catch(async () => cb());\n    return undefined;\n  }\n\n  /**\n   * When an answer is received over the threshold, decide what to do with this answer.\n   * @param {Object} session Microsoft bot framework session.\n   * @param {string} answer Answer given by the NLP.\n   */\n  processAnswer(session, answer) {\n    if (answer[0] === '/') {\n      return session.beginDialog(answer);\n    }\n    return session.send(answer);\n  }\n\n  /**\n   * Sets the recognizer to a Microsoft bot framework universal bot instance.\n   * Also, the default bot routing can be overrided and replaced by the\n   * recognizer routing.\n   * @param {Object} bot Microsoft Bot Framework Universal Bot instance.\n   * @param {boolean} activateRouting True if default routing should be overrided.\n   * @param {number} routingThreshold Threshold for the score of the intent.\n   */\n  setBot(bot, activateRouting = false, routingThreshold = 0.7) {\n    bot.recognizer(this);\n    if (!activateRouting) {\n      return;\n    }\n    const self = this;\n    // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n    bot._onDisambiguateRoute = function disambiguate(\n      session,\n      results,\n      cb = () => {}\n    ) {\n      if (self.onBeginRouting && !self.onBeginRouting(session)) {\n        return cb();\n      }\n      if (session.message && session.message.text) {\n        self.recognizeTwice(session, (err, result) => {\n          if (result.score > routingThreshold) {\n            if (\n              self.onRecognizedRouting &&\n              !self.onRecognizedRouting(session, result)\n            ) {\n              return cb();\n            }\n            self.processActions(session, result, () => {\n              if (result.answer && result.answer !== '') {\n                self.processAnswer(session, result.answer);\n              }\n              return cb();\n            });\n            return undefined;\n          }\n          if (\n            self.onUnrecognizedRouting &&\n            !self.onUnrecognizedRouting(session, result)\n          ) {\n            return cb();\n          }\n          self.defaultRouting(bot, session, results);\n          return cb();\n        });\n      } else {\n        if (self.onNoTextRouting && !self.onNoTextRouting(session)) {\n          return cb();\n        }\n        self.defaultRouting(bot, session, results);\n        return cb();\n      }\n      return undefined;\n    };\n  }\n}\n\nmodule.exports = Recognizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}