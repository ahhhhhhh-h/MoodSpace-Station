{"ast":null,"code":"/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar InvokeDefinitionMap = require(\"./InvokeDefinitionMap\");\nvar CharacterClass = require(\"./CharacterClass\");\nvar SurrogateAwareString = require(\"../util/SurrogateAwareString\");\nvar DEFAULT_CATEGORY = \"DEFAULT\";\n\n/**\n * CharacterDefinition represents char.def file and\n * defines behavior of unknown word processing\n * @constructor\n */\nfunction CharacterDefinition() {\n  this.character_category_map = new Uint8Array(65536); // for all UCS2 code points\n  this.compatible_category_map = new Uint32Array(65536); // for all UCS2 code points\n  this.invoke_definition_map = null;\n}\n\n/**\n * Load CharacterDefinition\n * @param {Uint8Array} cat_map_buffer\n * @param {Uint32Array} compat_cat_map_buffer\n * @param {InvokeDefinitionMap} invoke_def_buffer\n * @returns {CharacterDefinition}\n */\nCharacterDefinition.load = function (cat_map_buffer, compat_cat_map_buffer, invoke_def_buffer) {\n  var char_def = new CharacterDefinition();\n  char_def.character_category_map = cat_map_buffer;\n  char_def.compatible_category_map = compat_cat_map_buffer;\n  char_def.invoke_definition_map = InvokeDefinitionMap.load(invoke_def_buffer);\n  return char_def;\n};\nCharacterDefinition.parseCharCategory = function (class_id, parsed_category_def) {\n  var category = parsed_category_def[1];\n  var invoke = parseInt(parsed_category_def[2]);\n  var grouping = parseInt(parsed_category_def[3]);\n  var max_length = parseInt(parsed_category_def[4]);\n  if (!isFinite(invoke) || invoke !== 0 && invoke !== 1) {\n    console.log(\"char.def parse error. INVOKE is 0 or 1 in:\" + invoke);\n    return null;\n  }\n  if (!isFinite(grouping) || grouping !== 0 && grouping !== 1) {\n    console.log(\"char.def parse error. GROUP is 0 or 1 in:\" + grouping);\n    return null;\n  }\n  if (!isFinite(max_length) || max_length < 0) {\n    console.log(\"char.def parse error. LENGTH is 1 to n:\" + max_length);\n    return null;\n  }\n  var is_invoke = invoke === 1;\n  var is_grouping = grouping === 1;\n  return new CharacterClass(class_id, category, is_invoke, is_grouping, max_length);\n};\nCharacterDefinition.parseCategoryMapping = function (parsed_category_mapping) {\n  var start = parseInt(parsed_category_mapping[1]);\n  var default_category = parsed_category_mapping[2];\n  var compatible_category = 3 < parsed_category_mapping.length ? parsed_category_mapping.slice(3) : [];\n  if (!isFinite(start) || start < 0 || start > 0xFFFF) {\n    console.log(\"char.def parse error. CODE is invalid:\" + start);\n  }\n  return {\n    start: start,\n    default: default_category,\n    compatible: compatible_category\n  };\n};\nCharacterDefinition.parseRangeCategoryMapping = function (parsed_category_mapping) {\n  var start = parseInt(parsed_category_mapping[1]);\n  var end = parseInt(parsed_category_mapping[2]);\n  var default_category = parsed_category_mapping[3];\n  var compatible_category = 4 < parsed_category_mapping.length ? parsed_category_mapping.slice(4) : [];\n  if (!isFinite(start) || start < 0 || start > 0xFFFF) {\n    console.log(\"char.def parse error. CODE is invalid:\" + start);\n  }\n  if (!isFinite(end) || end < 0 || end > 0xFFFF) {\n    console.log(\"char.def parse error. CODE is invalid:\" + end);\n  }\n  return {\n    start: start,\n    end: end,\n    default: default_category,\n    compatible: compatible_category\n  };\n};\n\n/**\n * Initializing method\n * @param {Array} category_mapping Array of category mapping\n */\nCharacterDefinition.prototype.initCategoryMappings = function (category_mapping) {\n  // Initialize map by DEFAULT class\n  var code_point;\n  if (category_mapping != null) {\n    for (var i = 0; i < category_mapping.length; i++) {\n      var mapping = category_mapping[i];\n      var end = mapping.end || mapping.start;\n      for (code_point = mapping.start; code_point <= end; code_point++) {\n        // Default Category class ID\n        this.character_category_map[code_point] = this.invoke_definition_map.lookup(mapping.default);\n        for (var j = 0; j < mapping.compatible.length; j++) {\n          var bitset = this.compatible_category_map[code_point];\n          var compatible_category = mapping.compatible[j];\n          if (compatible_category == null) {\n            continue;\n          }\n          var class_id = this.invoke_definition_map.lookup(compatible_category); // Default Category\n          if (class_id == null) {\n            continue;\n          }\n          var class_id_bit = 1 << class_id;\n          bitset = bitset | class_id_bit; // Set a bit of class ID 例えば、class_idが3のとき、3ビット目に1を立てる\n          this.compatible_category_map[code_point] = bitset;\n        }\n      }\n    }\n  }\n  var default_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n  if (default_id == null) {\n    return;\n  }\n  for (code_point = 0; code_point < this.character_category_map.length; code_point++) {\n    // 他に何のクラスも定義されていなかったときだけ DEFAULT\n    if (this.character_category_map[code_point] === 0) {\n      // DEFAULT class ID に対応するビットだけ1を立てる\n      this.character_category_map[code_point] = 1 << default_id;\n    }\n  }\n};\n\n/**\n * Lookup compatible categories for a character (not included 1st category)\n * @param {string} ch UCS2 character (just 1st character is effective)\n * @returns {Array.<CharacterClass>} character classes\n */\nCharacterDefinition.prototype.lookupCompatibleCategory = function (ch) {\n  var classes = [];\n\n  /*\n   if (SurrogateAwareString.isSurrogatePair(ch)) {\n   // Surrogate pair character codes can not be defined by char.def\n   return classes;\n   }*/\n  var code = ch.charCodeAt(0);\n  var integer;\n  if (code < this.compatible_category_map.length) {\n    integer = this.compatible_category_map[code]; // Bitset\n  }\n  if (integer == null || integer === 0) {\n    return classes;\n  }\n  for (var bit = 0; bit < 32; bit++) {\n    // Treat \"bit\" as a class ID\n    if (integer << 31 - bit >>> 31 === 1) {\n      var character_class = this.invoke_definition_map.getCharacterClass(bit);\n      if (character_class == null) {\n        continue;\n      }\n      classes.push(character_class);\n    }\n  }\n  return classes;\n};\n\n/**\n * Lookup category for a character\n * @param {string} ch UCS2 character (just 1st character is effective)\n * @returns {CharacterClass} character class\n */\nCharacterDefinition.prototype.lookup = function (ch) {\n  var class_id;\n  var code = ch.charCodeAt(0);\n  if (SurrogateAwareString.isSurrogatePair(ch)) {\n    // Surrogate pair character codes can not be defined by char.def, so set DEFAULT category\n    class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n  } else if (code < this.character_category_map.length) {\n    class_id = this.character_category_map[code]; // Read as integer value\n  }\n  if (class_id == null) {\n    class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n  }\n  return this.invoke_definition_map.getCharacterClass(class_id);\n};\nmodule.exports = CharacterDefinition;","map":{"version":3,"names":["InvokeDefinitionMap","require","CharacterClass","SurrogateAwareString","DEFAULT_CATEGORY","CharacterDefinition","character_category_map","Uint8Array","compatible_category_map","Uint32Array","invoke_definition_map","load","cat_map_buffer","compat_cat_map_buffer","invoke_def_buffer","char_def","parseCharCategory","class_id","parsed_category_def","category","invoke","parseInt","grouping","max_length","isFinite","console","log","is_invoke","is_grouping","parseCategoryMapping","parsed_category_mapping","start","default_category","compatible_category","length","slice","default","compatible","parseRangeCategoryMapping","end","prototype","initCategoryMappings","category_mapping","code_point","i","mapping","lookup","j","bitset","class_id_bit","default_id","lookupCompatibleCategory","ch","classes","code","charCodeAt","integer","bit","character_class","getCharacterClass","push","isSurrogatePair","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/kuromoji/src/dict/CharacterDefinition.js"],"sourcesContent":["/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar InvokeDefinitionMap = require(\"./InvokeDefinitionMap\");\nvar CharacterClass = require(\"./CharacterClass\");\nvar SurrogateAwareString = require(\"../util/SurrogateAwareString\");\n\nvar DEFAULT_CATEGORY = \"DEFAULT\";\n\n/**\n * CharacterDefinition represents char.def file and\n * defines behavior of unknown word processing\n * @constructor\n */\nfunction CharacterDefinition() {\n    this.character_category_map = new Uint8Array(65536);  // for all UCS2 code points\n    this.compatible_category_map = new Uint32Array(65536);  // for all UCS2 code points\n    this.invoke_definition_map = null;\n}\n\n/**\n * Load CharacterDefinition\n * @param {Uint8Array} cat_map_buffer\n * @param {Uint32Array} compat_cat_map_buffer\n * @param {InvokeDefinitionMap} invoke_def_buffer\n * @returns {CharacterDefinition}\n */\nCharacterDefinition.load = function (cat_map_buffer, compat_cat_map_buffer, invoke_def_buffer) {\n    var char_def = new CharacterDefinition();\n    char_def.character_category_map = cat_map_buffer;\n    char_def.compatible_category_map = compat_cat_map_buffer;\n    char_def.invoke_definition_map = InvokeDefinitionMap.load(invoke_def_buffer);\n    return char_def;\n};\n\nCharacterDefinition.parseCharCategory = function (class_id, parsed_category_def) {\n    var category = parsed_category_def[1];\n    var invoke = parseInt(parsed_category_def[2]);\n    var grouping = parseInt(parsed_category_def[3]);\n    var max_length = parseInt(parsed_category_def[4]);\n    if (!isFinite(invoke) || (invoke !== 0 && invoke !== 1)) {\n        console.log(\"char.def parse error. INVOKE is 0 or 1 in:\" + invoke);\n        return null;\n    }\n    if (!isFinite(grouping) || (grouping !== 0 && grouping !== 1)) {\n        console.log(\"char.def parse error. GROUP is 0 or 1 in:\" + grouping);\n        return null;\n    }\n    if (!isFinite(max_length) || max_length < 0) {\n        console.log(\"char.def parse error. LENGTH is 1 to n:\" + max_length);\n        return null;\n    }\n    var is_invoke = (invoke === 1);\n    var is_grouping = (grouping === 1);\n\n    return new CharacterClass(class_id, category, is_invoke, is_grouping, max_length);\n};\n\nCharacterDefinition.parseCategoryMapping = function (parsed_category_mapping) {\n    var start = parseInt(parsed_category_mapping[1]);\n    var default_category = parsed_category_mapping[2];\n    var compatible_category = (3 < parsed_category_mapping.length) ? parsed_category_mapping.slice(3) : [];\n    if (!isFinite(start) || start < 0 || start > 0xFFFF) {\n        console.log(\"char.def parse error. CODE is invalid:\" + start);\n    }\n    return { start: start, default: default_category, compatible: compatible_category};\n};\n\nCharacterDefinition.parseRangeCategoryMapping = function (parsed_category_mapping) {\n    var start = parseInt(parsed_category_mapping[1]);\n    var end = parseInt(parsed_category_mapping[2]);\n    var default_category = parsed_category_mapping[3];\n    var compatible_category = (4 < parsed_category_mapping.length) ? parsed_category_mapping.slice(4) : [];\n    if (!isFinite(start) || start < 0 || start > 0xFFFF) {\n        console.log(\"char.def parse error. CODE is invalid:\" + start);\n    }\n    if (!isFinite(end) || end < 0 || end > 0xFFFF) {\n        console.log(\"char.def parse error. CODE is invalid:\" + end);\n    }\n    return { start: start, end: end, default: default_category, compatible: compatible_category};\n};\n\n/**\n * Initializing method\n * @param {Array} category_mapping Array of category mapping\n */\nCharacterDefinition.prototype.initCategoryMappings = function (category_mapping) {\n    // Initialize map by DEFAULT class\n    var code_point;\n    if (category_mapping != null) {\n        for (var i = 0; i < category_mapping.length; i++) {\n            var mapping = category_mapping[i];\n            var end = mapping.end || mapping.start;\n            for (code_point = mapping.start; code_point <= end; code_point++) {\n\n                // Default Category class ID\n                this.character_category_map[code_point] = this.invoke_definition_map.lookup(mapping.default);\n\n                for (var j = 0; j < mapping.compatible.length; j++) {\n                    var bitset = this.compatible_category_map[code_point];\n                    var compatible_category = mapping.compatible[j];\n                    if (compatible_category == null) {\n                        continue;\n                    }\n                    var class_id = this.invoke_definition_map.lookup(compatible_category);  // Default Category\n                    if (class_id == null) {\n                        continue;\n                    }\n                    var class_id_bit = 1 << class_id;\n                    bitset = bitset | class_id_bit;  // Set a bit of class ID 例えば、class_idが3のとき、3ビット目に1を立てる\n                    this.compatible_category_map[code_point] = bitset;\n                }\n            }\n        }\n    }\n    var default_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n    if (default_id == null) {\n        return;\n    }\n    for (code_point = 0; code_point < this.character_category_map.length; code_point++) {\n        // 他に何のクラスも定義されていなかったときだけ DEFAULT\n        if (this.character_category_map[code_point] === 0) {\n            // DEFAULT class ID に対応するビットだけ1を立てる\n            this.character_category_map[code_point] = 1 << default_id;\n        }\n    }\n};\n\n/**\n * Lookup compatible categories for a character (not included 1st category)\n * @param {string} ch UCS2 character (just 1st character is effective)\n * @returns {Array.<CharacterClass>} character classes\n */\nCharacterDefinition.prototype.lookupCompatibleCategory = function (ch) {\n    var classes = [];\n\n    /*\n     if (SurrogateAwareString.isSurrogatePair(ch)) {\n     // Surrogate pair character codes can not be defined by char.def\n     return classes;\n     }*/\n    var code = ch.charCodeAt(0);\n    var integer;\n    if (code < this.compatible_category_map.length) {\n        integer = this.compatible_category_map[code];  // Bitset\n    }\n\n    if (integer == null || integer === 0) {\n        return classes;\n    }\n\n    for (var bit = 0; bit < 32; bit++) {  // Treat \"bit\" as a class ID\n        if (((integer << (31 - bit)) >>> 31) === 1) {\n            var character_class = this.invoke_definition_map.getCharacterClass(bit);\n            if (character_class == null) {\n                continue;\n            }\n            classes.push(character_class);\n        }\n    }\n    return classes;\n};\n\n\n/**\n * Lookup category for a character\n * @param {string} ch UCS2 character (just 1st character is effective)\n * @returns {CharacterClass} character class\n */\nCharacterDefinition.prototype.lookup = function (ch) {\n\n    var class_id;\n\n    var code = ch.charCodeAt(0);\n    if (SurrogateAwareString.isSurrogatePair(ch)) {\n        // Surrogate pair character codes can not be defined by char.def, so set DEFAULT category\n        class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n    } else if (code < this.character_category_map.length) {\n        class_id = this.character_category_map[code];  // Read as integer value\n    }\n\n    if (class_id == null) {\n        class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n    }\n\n    return this.invoke_definition_map.getCharacterClass(class_id);\n};\n\nmodule.exports = CharacterDefinition;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,mBAAmB,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AAC1D,IAAIC,cAAc,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAChD,IAAIE,oBAAoB,GAAGF,OAAO,CAAC,8BAA8B,CAAC;AAElE,IAAIG,gBAAgB,GAAG,SAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAAA,EAAG;EAC3B,IAAI,CAACC,sBAAsB,GAAG,IAAIC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAE;EACtD,IAAI,CAACC,uBAAuB,GAAG,IAAIC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAE;EACxD,IAAI,CAACC,qBAAqB,GAAG,IAAI;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,mBAAmB,CAACM,IAAI,GAAG,UAAUC,cAAc,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAE;EAC3F,IAAIC,QAAQ,GAAG,IAAIV,mBAAmB,CAAC,CAAC;EACxCU,QAAQ,CAACT,sBAAsB,GAAGM,cAAc;EAChDG,QAAQ,CAACP,uBAAuB,GAAGK,qBAAqB;EACxDE,QAAQ,CAACL,qBAAqB,GAAGV,mBAAmB,CAACW,IAAI,CAACG,iBAAiB,CAAC;EAC5E,OAAOC,QAAQ;AACnB,CAAC;AAEDV,mBAAmB,CAACW,iBAAiB,GAAG,UAAUC,QAAQ,EAAEC,mBAAmB,EAAE;EAC7E,IAAIC,QAAQ,GAAGD,mBAAmB,CAAC,CAAC,CAAC;EACrC,IAAIE,MAAM,GAAGC,QAAQ,CAACH,mBAAmB,CAAC,CAAC,CAAC,CAAC;EAC7C,IAAII,QAAQ,GAAGD,QAAQ,CAACH,mBAAmB,CAAC,CAAC,CAAC,CAAC;EAC/C,IAAIK,UAAU,GAAGF,QAAQ,CAACH,mBAAmB,CAAC,CAAC,CAAC,CAAC;EACjD,IAAI,CAACM,QAAQ,CAACJ,MAAM,CAAC,IAAKA,MAAM,KAAK,CAAC,IAAIA,MAAM,KAAK,CAAE,EAAE;IACrDK,OAAO,CAACC,GAAG,CAAC,4CAA4C,GAAGN,MAAM,CAAC;IAClE,OAAO,IAAI;EACf;EACA,IAAI,CAACI,QAAQ,CAACF,QAAQ,CAAC,IAAKA,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAE,EAAE;IAC3DG,OAAO,CAACC,GAAG,CAAC,2CAA2C,GAAGJ,QAAQ,CAAC;IACnE,OAAO,IAAI;EACf;EACA,IAAI,CAACE,QAAQ,CAACD,UAAU,CAAC,IAAIA,UAAU,GAAG,CAAC,EAAE;IACzCE,OAAO,CAACC,GAAG,CAAC,yCAAyC,GAAGH,UAAU,CAAC;IACnE,OAAO,IAAI;EACf;EACA,IAAII,SAAS,GAAIP,MAAM,KAAK,CAAE;EAC9B,IAAIQ,WAAW,GAAIN,QAAQ,KAAK,CAAE;EAElC,OAAO,IAAIpB,cAAc,CAACe,QAAQ,EAAEE,QAAQ,EAAEQ,SAAS,EAAEC,WAAW,EAAEL,UAAU,CAAC;AACrF,CAAC;AAEDlB,mBAAmB,CAACwB,oBAAoB,GAAG,UAAUC,uBAAuB,EAAE;EAC1E,IAAIC,KAAK,GAAGV,QAAQ,CAACS,uBAAuB,CAAC,CAAC,CAAC,CAAC;EAChD,IAAIE,gBAAgB,GAAGF,uBAAuB,CAAC,CAAC,CAAC;EACjD,IAAIG,mBAAmB,GAAI,CAAC,GAAGH,uBAAuB,CAACI,MAAM,GAAIJ,uBAAuB,CAACK,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE;EACtG,IAAI,CAACX,QAAQ,CAACO,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,MAAM,EAAE;IACjDN,OAAO,CAACC,GAAG,CAAC,wCAAwC,GAAGK,KAAK,CAAC;EACjE;EACA,OAAO;IAAEA,KAAK,EAAEA,KAAK;IAAEK,OAAO,EAAEJ,gBAAgB;IAAEK,UAAU,EAAEJ;EAAmB,CAAC;AACtF,CAAC;AAED5B,mBAAmB,CAACiC,yBAAyB,GAAG,UAAUR,uBAAuB,EAAE;EAC/E,IAAIC,KAAK,GAAGV,QAAQ,CAACS,uBAAuB,CAAC,CAAC,CAAC,CAAC;EAChD,IAAIS,GAAG,GAAGlB,QAAQ,CAACS,uBAAuB,CAAC,CAAC,CAAC,CAAC;EAC9C,IAAIE,gBAAgB,GAAGF,uBAAuB,CAAC,CAAC,CAAC;EACjD,IAAIG,mBAAmB,GAAI,CAAC,GAAGH,uBAAuB,CAACI,MAAM,GAAIJ,uBAAuB,CAACK,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE;EACtG,IAAI,CAACX,QAAQ,CAACO,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,MAAM,EAAE;IACjDN,OAAO,CAACC,GAAG,CAAC,wCAAwC,GAAGK,KAAK,CAAC;EACjE;EACA,IAAI,CAACP,QAAQ,CAACe,GAAG,CAAC,IAAIA,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAG,MAAM,EAAE;IAC3Cd,OAAO,CAACC,GAAG,CAAC,wCAAwC,GAAGa,GAAG,CAAC;EAC/D;EACA,OAAO;IAAER,KAAK,EAAEA,KAAK;IAAEQ,GAAG,EAAEA,GAAG;IAAEH,OAAO,EAAEJ,gBAAgB;IAAEK,UAAU,EAAEJ;EAAmB,CAAC;AAChG,CAAC;;AAED;AACA;AACA;AACA;AACA5B,mBAAmB,CAACmC,SAAS,CAACC,oBAAoB,GAAG,UAAUC,gBAAgB,EAAE;EAC7E;EACA,IAAIC,UAAU;EACd,IAAID,gBAAgB,IAAI,IAAI,EAAE;IAC1B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,gBAAgB,CAACR,MAAM,EAAEU,CAAC,EAAE,EAAE;MAC9C,IAAIC,OAAO,GAAGH,gBAAgB,CAACE,CAAC,CAAC;MACjC,IAAIL,GAAG,GAAGM,OAAO,CAACN,GAAG,IAAIM,OAAO,CAACd,KAAK;MACtC,KAAKY,UAAU,GAAGE,OAAO,CAACd,KAAK,EAAEY,UAAU,IAAIJ,GAAG,EAAEI,UAAU,EAAE,EAAE;QAE9D;QACA,IAAI,CAACrC,sBAAsB,CAACqC,UAAU,CAAC,GAAG,IAAI,CAACjC,qBAAqB,CAACoC,MAAM,CAACD,OAAO,CAACT,OAAO,CAAC;QAE5F,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,OAAO,CAACR,UAAU,CAACH,MAAM,EAAEa,CAAC,EAAE,EAAE;UAChD,IAAIC,MAAM,GAAG,IAAI,CAACxC,uBAAuB,CAACmC,UAAU,CAAC;UACrD,IAAIV,mBAAmB,GAAGY,OAAO,CAACR,UAAU,CAACU,CAAC,CAAC;UAC/C,IAAId,mBAAmB,IAAI,IAAI,EAAE;YAC7B;UACJ;UACA,IAAIhB,QAAQ,GAAG,IAAI,CAACP,qBAAqB,CAACoC,MAAM,CAACb,mBAAmB,CAAC,CAAC,CAAE;UACxE,IAAIhB,QAAQ,IAAI,IAAI,EAAE;YAClB;UACJ;UACA,IAAIgC,YAAY,GAAG,CAAC,IAAIhC,QAAQ;UAChC+B,MAAM,GAAGA,MAAM,GAAGC,YAAY,CAAC,CAAE;UACjC,IAAI,CAACzC,uBAAuB,CAACmC,UAAU,CAAC,GAAGK,MAAM;QACrD;MACJ;IACJ;EACJ;EACA,IAAIE,UAAU,GAAG,IAAI,CAACxC,qBAAqB,CAACoC,MAAM,CAAC1C,gBAAgB,CAAC;EACpE,IAAI8C,UAAU,IAAI,IAAI,EAAE;IACpB;EACJ;EACA,KAAKP,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAG,IAAI,CAACrC,sBAAsB,CAAC4B,MAAM,EAAES,UAAU,EAAE,EAAE;IAChF;IACA,IAAI,IAAI,CAACrC,sBAAsB,CAACqC,UAAU,CAAC,KAAK,CAAC,EAAE;MAC/C;MACA,IAAI,CAACrC,sBAAsB,CAACqC,UAAU,CAAC,GAAG,CAAC,IAAIO,UAAU;IAC7D;EACJ;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA7C,mBAAmB,CAACmC,SAAS,CAACW,wBAAwB,GAAG,UAAUC,EAAE,EAAE;EACnE,IAAIC,OAAO,GAAG,EAAE;;EAEhB;AACJ;AACA;AACA;AACA;EACI,IAAIC,IAAI,GAAGF,EAAE,CAACG,UAAU,CAAC,CAAC,CAAC;EAC3B,IAAIC,OAAO;EACX,IAAIF,IAAI,GAAG,IAAI,CAAC9C,uBAAuB,CAAC0B,MAAM,EAAE;IAC5CsB,OAAO,GAAG,IAAI,CAAChD,uBAAuB,CAAC8C,IAAI,CAAC,CAAC,CAAE;EACnD;EAEA,IAAIE,OAAO,IAAI,IAAI,IAAIA,OAAO,KAAK,CAAC,EAAE;IAClC,OAAOH,OAAO;EAClB;EAEA,KAAK,IAAII,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,EAAE,EAAEA,GAAG,EAAE,EAAE;IAAG;IAClC,IAAMD,OAAO,IAAK,EAAE,GAAGC,GAAI,KAAM,EAAE,KAAM,CAAC,EAAE;MACxC,IAAIC,eAAe,GAAG,IAAI,CAAChD,qBAAqB,CAACiD,iBAAiB,CAACF,GAAG,CAAC;MACvE,IAAIC,eAAe,IAAI,IAAI,EAAE;QACzB;MACJ;MACAL,OAAO,CAACO,IAAI,CAACF,eAAe,CAAC;IACjC;EACJ;EACA,OAAOL,OAAO;AAClB,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACAhD,mBAAmB,CAACmC,SAAS,CAACM,MAAM,GAAG,UAAUM,EAAE,EAAE;EAEjD,IAAInC,QAAQ;EAEZ,IAAIqC,IAAI,GAAGF,EAAE,CAACG,UAAU,CAAC,CAAC,CAAC;EAC3B,IAAIpD,oBAAoB,CAAC0D,eAAe,CAACT,EAAE,CAAC,EAAE;IAC1C;IACAnC,QAAQ,GAAG,IAAI,CAACP,qBAAqB,CAACoC,MAAM,CAAC1C,gBAAgB,CAAC;EAClE,CAAC,MAAM,IAAIkD,IAAI,GAAG,IAAI,CAAChD,sBAAsB,CAAC4B,MAAM,EAAE;IAClDjB,QAAQ,GAAG,IAAI,CAACX,sBAAsB,CAACgD,IAAI,CAAC,CAAC,CAAE;EACnD;EAEA,IAAIrC,QAAQ,IAAI,IAAI,EAAE;IAClBA,QAAQ,GAAG,IAAI,CAACP,qBAAqB,CAACoC,MAAM,CAAC1C,gBAAgB,CAAC;EAClE;EAEA,OAAO,IAAI,CAACM,qBAAqB,CAACiD,iBAAiB,CAAC1C,QAAQ,CAAC;AACjE,CAAC;AAED6C,MAAM,CAACC,OAAO,GAAG1D,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}