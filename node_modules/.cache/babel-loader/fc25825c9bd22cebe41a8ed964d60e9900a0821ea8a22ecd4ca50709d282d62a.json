{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  generate: unparse\n} = require('escodegen');\nconst {\n  parse\n} = require('esprima');\nclass JavascriptCompiler {\n  constructor(container) {\n    this.container = container.container || container;\n    this.name = 'javascript';\n    this.failResult = {};\n  }\n  compile(pipeline) {\n    const header = '(async () => {\\n';\n    const footer = '\\n})();';\n    const code = pipeline.join('\\n');\n    return header + code + footer;\n  }\n  log(msg) {\n    const logger = this.container.get('logger') || console;\n    logger.info(msg);\n  }\n  walkLiteral(node) {\n    return node.value;\n  }\n  async walkUnary(node, context) {\n    switch (node.operator) {\n      case '+':\n        return +(await this.walk(node.argument, context));\n      case '-':\n        return -(await this.walk(node.argument, context));\n      case '~':\n        /* eslint-disable no-bitwise */\n        return ~(await this.walk(node.argument, context));\n      case '!':\n        return !(await this.walk(node.argument, context));\n      default:\n        return this.failResult;\n    }\n  }\n  async walkArray(node, context) {\n    const result = [];\n    for (let i = 0, l = node.elements.length; i < l; i += 1) {\n      const x = await this.walk(node.elements[i], context);\n      if (x === this.failResult) {\n        return this.failResult;\n      }\n      result.push(x);\n    }\n    return result;\n  }\n  async walkObject(node, context) {\n    const result = {};\n    for (let i = 0, l = node.properties.length; i < l; i += 1) {\n      const prop = node.properties[i];\n      const value = await this.walk(prop.value, context);\n      if (value === this.failResult) {\n        return this.failResult;\n      }\n      result[prop.key.value || prop.key.name] = value;\n    }\n    return result;\n  }\n  async walkBinary(node, context) {\n    const left = await this.walk(node.left, context);\n    if (left === this.failResult) {\n      return this.failResult;\n    }\n    if (node.operator === '&&' && !left) {\n      return false;\n    }\n    if (node.operator === '||' && left) {\n      return true;\n    }\n    const right = await this.walk(node.right, context);\n    if (right === this.failResult) {\n      return this.failResult;\n    }\n    switch (node.operator) {\n      case '==':\n        /* eslint-disable eqeqeq */\n        return left == right;\n      case '===':\n        return left === right;\n      case '!=':\n        /* eslint-disable eqeqeq */\n        return left != right;\n      case '!==':\n        return left !== right;\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        return left / right;\n      case '%':\n        return left % right;\n      case '<':\n        return left < right;\n      case '<=':\n        return left <= right;\n      case '>':\n        return left > right;\n      case '>=':\n        return left >= right;\n      case '|':\n        /* eslint-disable no-bitwise */\n        return left | right;\n      case '&':\n        /* eslint-disable no-bitwise */\n        return left & right;\n      case '^':\n        /* eslint-disable no-bitwise */\n        return left ^ right;\n      case '||':\n        return left || right;\n      case '&&':\n        return left && right;\n      default:\n        return this.failResult;\n    }\n  }\n  async walkIdentifier(node, context) {\n    if ({}.hasOwnProperty.call(context, node.name)) {\n      return context[node.name];\n    }\n    if (context.input && {}.hasOwnProperty.call(context.input, node.name)) {\n      return context.input[node.name];\n    }\n    if (context.globalFuncs && context.globalFuncs[node.name]) {\n      const result = context.globalFuncs[node.name];\n      node.name = `globalFuncs.${node.name}`;\n      return result;\n    }\n    if (context.this && context.this.container) {\n      const item = context.this.container.get(node.name);\n      if (item) {\n        return item;\n      }\n    }\n    return undefined;\n  }\n  async walkThis(node, context) {\n    if ({}.hasOwnProperty.call(context, 'this')) {\n      // eslint-disable-next-line\n      return context[\"this\"];\n    }\n    return undefined;\n  }\n  async walkCall(node, context) {\n    let callee;\n    if (node.callee && node.callee.type === 'Identifier' && node.callee.name === 'run') {\n      if (context && context.this && context.this.container) {\n        callee = context.this.container.runPipeline.bind(context.this.container);\n      } else {\n        return this.failResult;\n      }\n    } else {\n      callee = await this.walk(node.callee, context);\n      if (callee === this.failResult || typeof callee !== 'function') {\n        return this.failResult;\n      }\n    }\n    let ctx = node.callee.object ? await this.walk(node.callee.object, context) : {};\n    if (ctx === this.failResult) {\n      ctx = null;\n    }\n    const args = [];\n    for (let i = 0, l = node.arguments.length; i < l; i += 1) {\n      const x = await this.walk(node.arguments[i], context);\n      if (x === this.failResult) {\n        return this.failResult;\n      }\n      args.push(x);\n    }\n    if (args.length === 0) {\n      args.push(context.input);\n    }\n    if (node.callee && node.callee.type === 'Identifier' && node.callee.name === 'run') {\n      if (args.length === 1) {\n        args.push(context.input);\n      }\n      if (args.length === 2) {\n        args.push(context.this);\n      }\n    }\n    return callee.apply(ctx, args);\n  }\n  async walkMember(node, context) {\n    const obj = await this.walk(node.object, context);\n    if (obj === this.failResult || typeof obj === 'function') {\n      return this.failResult;\n    }\n    if (node.property.type === 'Identifier' && node.object.type !== 'ObjectExpression') {\n      return obj[node.property.name];\n    }\n    const prop = await this.walk(node.property, context);\n    if (prop === this.failResult) {\n      return this.failResult;\n    }\n    return obj ? obj[prop] : undefined;\n  }\n  async walkConditional(node, context) {\n    const value = await this.walk(node.test, context);\n    if (value === this.failResult) {\n      return this.failResult;\n    }\n    if (value) {\n      return this.walk(node.consequent, context);\n    }\n    if (!node.alternate) {\n      return undefined;\n    }\n    return this.walk(node.alternate, context);\n  }\n  async walkExpression(node, context) {\n    const value = await this.walk(node.expression, context);\n    if (value === this.failResult) {\n      return this.failResult;\n    }\n    return value;\n  }\n  async walkReturn(node, context) {\n    return this.walk(node.argument, context);\n  }\n  async walkFunction(node, context) {\n    const newContext = {};\n    const keys = Object.keys(context).filter(x => x !== 'this');\n    keys.forEach(element => {\n      newContext[element] = context[element];\n    });\n    node.params.forEach(key => {\n      if (key.type === 'Identifier') {\n        newContext[key.name] = null;\n      }\n    });\n    const bodies = node.body.body;\n    for (let i = 0, l = bodies.length; i < l; i += 1) {\n      if ((await this.walk(bodies[i], newContext)) === this.failResult) {\n        return this.failResult;\n      }\n    }\n    const vals = keys.map(key => context[key]);\n    // eslint-disable-next-line\n    const result = Function(keys.join(', '), 'return ' + unparse(node)).apply(null, vals);\n    return result;\n  }\n  async walkTemplateLiteral(node, context) {\n    let str = '';\n    for (let i = 0; i < node.expressions.length; i += 1) {\n      str += await this.walk(node.quasis[i], context);\n      str += await this.walk(node.expressions[i], context);\n    }\n    return str;\n  }\n  walkTemplateElement(node) {\n    return node.value.cooked;\n  }\n  async walkTaggedTemplate(node, context) {\n    const tag = await this.walk(node.tag, context);\n    const {\n      quasi\n    } = node;\n    const strings = [];\n    for (let i = 0; i < quasi.quasis.length; i += 1) {\n      const q = quasi.quasis[i];\n      const value = await this.walk(q, context);\n      strings.push(value);\n    }\n    const values = [];\n    for (let i = 0; i < quasi.expressions.length; i += 1) {\n      const q = quasi.expressions[i];\n      const value = await this.walk(q, context);\n      values.push(value);\n    }\n    // eslint-disable-next-line\n    return tag.apply(null, [strings].concat(values));\n  }\n  async walkUpdateExpression(node, context) {\n    let value = await this.walk(node.argument, context);\n    if (value === this.failResult) {\n      return this.failResult;\n    }\n    switch (node.operator) {\n      case '++':\n        value += 1;\n        return this.walkSet(node.argument, context, value);\n      case '--':\n        value -= 1;\n        return this.walkSet(node.argument, context, value);\n      default:\n        return this.failResult;\n    }\n  }\n  async walkVariableDeclaration(node, context) {\n    let value;\n    for (let i = 0; i < node.declarations.length; i += 1) {\n      const declaration = node.declarations[i];\n      value = declaration.init ? await this.walk(declaration.init, context) : undefined;\n      if (value === this.failResult) {\n        return this.failResult;\n      }\n      await this.walkSet(declaration.id, context, value);\n    }\n    return value;\n  }\n  async walkAssignmentExpression(node, context) {\n    const value = await this.walk(node.right, context);\n    if (value === this.failResult) {\n      return this.failResult;\n    }\n    let leftValue = await this.walk(node.left, context);\n    if (leftValue === this.failResult) {\n      leftValue = 0;\n    }\n    switch (node.operator) {\n      case '=':\n        await this.walkSet(node.left, context, value);\n        return value;\n      case '+=':\n        leftValue += value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '-=':\n        leftValue -= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '*=':\n        leftValue *= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '/=':\n        leftValue /= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '%=':\n        leftValue %= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '|=':\n        // eslint-disable-next-line\n        leftValue |= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '&=':\n        // eslint-disable-next-line\n        leftValue &= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '^=':\n        // eslint-disable-next-line\n        leftValue ^= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      default:\n        return this.failResult;\n    }\n  }\n  async walkBlock(node, context) {\n    if (Array.isArray(node.body)) {\n      let result;\n      for (let i = 0; i < node.body.length; i += 1) {\n        result = await this.walk(node.body[i], context);\n      }\n      return result;\n    }\n    return this.walk(node.body, context);\n  }\n  async walk(node, context) {\n    switch (node.type) {\n      case 'Literal':\n        return this.walkLiteral(node, context);\n      case 'UnaryExpression':\n        return this.walkUnary(node, context);\n      case 'ArrayExpression':\n        return this.walkArray(node, context);\n      case 'ObjectExpression':\n        return this.walkObject(node, context);\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        return this.walkBinary(node, context);\n      case 'Identifier':\n        return this.walkIdentifier(node, context);\n      case 'ThisExpression':\n        return this.walkThis(node, context);\n      case 'CallExpression':\n        return this.walkCall(node, context);\n      case 'MemberExpression':\n        return this.walkMember(node, context);\n      case 'ConditionalExpression':\n        return this.walkConditional(node, context);\n      case 'ExpressionStatement':\n        return this.walkExpression(node, context);\n      case 'ReturnStatement':\n        return this.walkReturn(node, context);\n      case 'FunctionExpression':\n        return this.walkFunction(node, context);\n      case 'TemplateLiteral':\n        return this.walkTemplateLiteral(node, context);\n      case 'TemplateElement':\n        return this.walkTemplateElement(node, context);\n      case 'TaggedTemplateExpression':\n        return this.walkTaggedTemplate(node, context);\n      case 'UpdateExpression':\n        return this.walkUpdateExpression(node, context);\n      case 'AssignmentExpression':\n        return this.walkAssignmentExpression(node, context);\n      case 'IfStatement':\n        return this.walkConditional(node, context);\n      case 'BlockStatement':\n        return this.walkBlock(node, context);\n      case 'VariableDeclaration':\n        return this.walkVariableDeclaration(node, context);\n      default:\n        return this.failResult;\n    }\n  }\n  walkSetIdentifier(node, context, value) {\n    const newContext = context;\n    if ({}.hasOwnProperty.call(context, node.name)) {\n      context[node.name] = value;\n    } else if (context.input && {}.hasOwnProperty.call(context.input, node.name)) {\n      context.input[node.name] = value;\n    } else {\n      newContext[node.name] = value;\n    }\n    return value;\n  }\n  async walkSetMember(node, context, value) {\n    const obj = await this.walk(node.object, context);\n    if (obj === this.failResult || typeof obj === 'function') {\n      return this.failResult;\n    }\n    if (node.property.type === 'Identifier') {\n      obj[node.property.name] = value;\n      return value;\n    }\n    const prop = await this.walk(node.property, context);\n    if (prop === this.failResult) {\n      return this.failResult;\n    }\n    if (!obj) {\n      return this.failResult;\n    }\n    obj[prop] = value;\n    return value;\n  }\n  async walkSet(node, context, value) {\n    switch (node.type) {\n      case 'Identifier':\n        return this.walkSetIdentifier(node, context, value);\n      case 'MemberExpression':\n        return this.walkSetMember(node, context, value);\n      default:\n        return this.failResult;\n    }\n  }\n  async evaluateAll(str, context) {\n    const result = [];\n    const newContext = context || this.context;\n    const compiled = parse(str);\n    for (let i = 0; i < compiled.body.length; i += 1) {\n      let expression = compiled.body[i].expression ? compiled.body[i].expression : compiled.body[i];\n      if (expression.callee && expression.callee.type === 'ArrowFunctionExpression') {\n        expression = expression.callee.body;\n      }\n      const value = await this.walk(expression, newContext);\n      result.push(value === this.failResult ? undefined : value);\n    }\n    return result;\n  }\n  async evaluate(str, context) {\n    const result = await this.evaluateAll(str, context);\n    if (!result || result.length === 0) {\n      return undefined;\n    }\n    return result[result.length - 1];\n  }\n  async execute(compiled, srcInput, srcObject) {\n    const context = {\n      this: srcObject,\n      input: srcInput\n    };\n    await this.evaluate(compiled, context);\n  }\n}\nmodule.exports = JavascriptCompiler;","map":{"version":3,"names":["generate","unparse","require","parse","JavascriptCompiler","constructor","container","name","failResult","compile","pipeline","header","footer","code","join","log","msg","logger","get","console","info","walkLiteral","node","value","walkUnary","context","operator","walk","argument","walkArray","result","i","l","elements","length","x","push","walkObject","properties","prop","key","walkBinary","left","right","walkIdentifier","hasOwnProperty","call","input","globalFuncs","this","item","undefined","walkThis","walkCall","callee","type","runPipeline","bind","ctx","object","args","arguments","apply","walkMember","obj","property","walkConditional","test","consequent","alternate","walkExpression","expression","walkReturn","walkFunction","newContext","keys","Object","filter","forEach","element","params","bodies","body","vals","map","Function","walkTemplateLiteral","str","expressions","quasis","walkTemplateElement","cooked","walkTaggedTemplate","tag","quasi","strings","q","values","concat","walkUpdateExpression","walkSet","walkVariableDeclaration","declarations","declaration","init","id","walkAssignmentExpression","leftValue","walkBlock","Array","isArray","walkSetIdentifier","walkSetMember","evaluateAll","compiled","evaluate","execute","srcInput","srcObject","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/evaluator/src/javascript-compiler.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { generate: unparse } = require('escodegen');\nconst { parse } = require('esprima');\n\nclass JavascriptCompiler {\n  constructor(container) {\n    this.container = container.container || container;\n    this.name = 'javascript';\n    this.failResult = {};\n  }\n\n  compile(pipeline) {\n    const header = '(async () => {\\n';\n    const footer = '\\n})();';\n    const code = pipeline.join('\\n');\n    return header + code + footer;\n  }\n\n  log(msg) {\n    const logger = this.container.get('logger') || console;\n    logger.info(msg);\n  }\n\n  walkLiteral(node) {\n    return node.value;\n  }\n\n  async walkUnary(node, context) {\n    switch (node.operator) {\n      case '+':\n        return +(await this.walk(node.argument, context));\n      case '-':\n        return -(await this.walk(node.argument, context));\n      case '~':\n        /* eslint-disable no-bitwise */\n        return ~(await this.walk(node.argument, context));\n      case '!':\n        return !(await this.walk(node.argument, context));\n      default:\n        return this.failResult;\n    }\n  }\n\n  async walkArray(node, context) {\n    const result = [];\n    for (let i = 0, l = node.elements.length; i < l; i += 1) {\n      const x = await this.walk(node.elements[i], context);\n      if (x === this.failResult) {\n        return this.failResult;\n      }\n      result.push(x);\n    }\n    return result;\n  }\n\n  async walkObject(node, context) {\n    const result = {};\n    for (let i = 0, l = node.properties.length; i < l; i += 1) {\n      const prop = node.properties[i];\n      const value = await this.walk(prop.value, context);\n      if (value === this.failResult) {\n        return this.failResult;\n      }\n      result[prop.key.value || prop.key.name] = value;\n    }\n    return result;\n  }\n\n  async walkBinary(node, context) {\n    const left = await this.walk(node.left, context);\n    if (left === this.failResult) {\n      return this.failResult;\n    }\n    if (node.operator === '&&' && !left) {\n      return false;\n    }\n    if (node.operator === '||' && left) {\n      return true;\n    }\n    const right = await this.walk(node.right, context);\n    if (right === this.failResult) {\n      return this.failResult;\n    }\n    switch (node.operator) {\n      case '==':\n        /* eslint-disable eqeqeq */\n        return left == right;\n      case '===':\n        return left === right;\n      case '!=':\n        /* eslint-disable eqeqeq */\n        return left != right;\n      case '!==':\n        return left !== right;\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        return left / right;\n      case '%':\n        return left % right;\n      case '<':\n        return left < right;\n      case '<=':\n        return left <= right;\n      case '>':\n        return left > right;\n      case '>=':\n        return left >= right;\n      case '|':\n        /* eslint-disable no-bitwise */\n        return left | right;\n      case '&':\n        /* eslint-disable no-bitwise */\n        return left & right;\n      case '^':\n        /* eslint-disable no-bitwise */\n        return left ^ right;\n      case '||':\n        return left || right;\n      case '&&':\n        return left && right;\n      default:\n        return this.failResult;\n    }\n  }\n\n  async walkIdentifier(node, context) {\n    if ({}.hasOwnProperty.call(context, node.name)) {\n      return context[node.name];\n    }\n    if (context.input && {}.hasOwnProperty.call(context.input, node.name)) {\n      return context.input[node.name];\n    }\n    if (context.globalFuncs && context.globalFuncs[node.name]) {\n      const result = context.globalFuncs[node.name];\n      node.name = `globalFuncs.${node.name}`;\n      return result;\n    }\n    if (context.this && context.this.container) {\n      const item = context.this.container.get(node.name);\n      if (item) {\n        return item;\n      }\n    }\n    return undefined;\n  }\n\n  async walkThis(node, context) {\n    if ({}.hasOwnProperty.call(context, 'this')) {\n      // eslint-disable-next-line\n      return context[\"this\"];\n    }\n    return undefined;\n  }\n\n  async walkCall(node, context) {\n    let callee;\n    if (\n      node.callee &&\n      node.callee.type === 'Identifier' &&\n      node.callee.name === 'run'\n    ) {\n      if (context && context.this && context.this.container) {\n        callee = context.this.container.runPipeline.bind(\n          context.this.container\n        );\n      } else {\n        return this.failResult;\n      }\n    } else {\n      callee = await this.walk(node.callee, context);\n      if (callee === this.failResult || typeof callee !== 'function') {\n        return this.failResult;\n      }\n    }\n    let ctx = node.callee.object\n      ? await this.walk(node.callee.object, context)\n      : {};\n    if (ctx === this.failResult) {\n      ctx = null;\n    }\n    const args = [];\n    for (let i = 0, l = node.arguments.length; i < l; i += 1) {\n      const x = await this.walk(node.arguments[i], context);\n      if (x === this.failResult) {\n        return this.failResult;\n      }\n      args.push(x);\n    }\n    if (args.length === 0) {\n      args.push(context.input);\n    }\n    if (\n      node.callee &&\n      node.callee.type === 'Identifier' &&\n      node.callee.name === 'run'\n    ) {\n      if (args.length === 1) {\n        args.push(context.input);\n      }\n      if (args.length === 2) {\n        args.push(context.this);\n      }\n    }\n    return callee.apply(ctx, args);\n  }\n\n  async walkMember(node, context) {\n    const obj = await this.walk(node.object, context);\n    if (obj === this.failResult || typeof obj === 'function') {\n      return this.failResult;\n    }\n    if (\n      node.property.type === 'Identifier' &&\n      node.object.type !== 'ObjectExpression'\n    ) {\n      return obj[node.property.name];\n    }\n    const prop = await this.walk(node.property, context);\n    if (prop === this.failResult) {\n      return this.failResult;\n    }\n    return obj ? obj[prop] : undefined;\n  }\n\n  async walkConditional(node, context) {\n    const value = await this.walk(node.test, context);\n    if (value === this.failResult) {\n      return this.failResult;\n    }\n    if (value) {\n      return this.walk(node.consequent, context);\n    }\n    if (!node.alternate) {\n      return undefined;\n    }\n    return this.walk(node.alternate, context);\n  }\n\n  async walkExpression(node, context) {\n    const value = await this.walk(node.expression, context);\n    if (value === this.failResult) {\n      return this.failResult;\n    }\n    return value;\n  }\n\n  async walkReturn(node, context) {\n    return this.walk(node.argument, context);\n  }\n\n  async walkFunction(node, context) {\n    const newContext = {};\n    const keys = Object.keys(context).filter((x) => x !== 'this');\n    keys.forEach((element) => {\n      newContext[element] = context[element];\n    });\n    node.params.forEach((key) => {\n      if (key.type === 'Identifier') {\n        newContext[key.name] = null;\n      }\n    });\n    const bodies = node.body.body;\n    for (let i = 0, l = bodies.length; i < l; i += 1) {\n      if ((await this.walk(bodies[i], newContext)) === this.failResult) {\n        return this.failResult;\n      }\n    }\n    const vals = keys.map((key) => context[key]);\n    // eslint-disable-next-line\n    const result = Function(keys.join(', '), 'return ' + unparse(node)).apply(\n      null,\n      vals\n    );\n    return result;\n  }\n\n  async walkTemplateLiteral(node, context) {\n    let str = '';\n    for (let i = 0; i < node.expressions.length; i += 1) {\n      str += await this.walk(node.quasis[i], context);\n      str += await this.walk(node.expressions[i], context);\n    }\n    return str;\n  }\n\n  walkTemplateElement(node) {\n    return node.value.cooked;\n  }\n\n  async walkTaggedTemplate(node, context) {\n    const tag = await this.walk(node.tag, context);\n    const { quasi } = node;\n    const strings = [];\n    for (let i = 0; i < quasi.quasis.length; i += 1) {\n      const q = quasi.quasis[i];\n      const value = await this.walk(q, context);\n      strings.push(value);\n    }\n    const values = [];\n    for (let i = 0; i < quasi.expressions.length; i += 1) {\n      const q = quasi.expressions[i];\n      const value = await this.walk(q, context);\n      values.push(value);\n    }\n    // eslint-disable-next-line\n    return tag.apply(null, [strings].concat(values));\n  }\n\n  async walkUpdateExpression(node, context) {\n    let value = await this.walk(node.argument, context);\n    if (value === this.failResult) {\n      return this.failResult;\n    }\n    switch (node.operator) {\n      case '++':\n        value += 1;\n        return this.walkSet(node.argument, context, value);\n      case '--':\n        value -= 1;\n        return this.walkSet(node.argument, context, value);\n      default:\n        return this.failResult;\n    }\n  }\n\n  async walkVariableDeclaration(node, context) {\n    let value;\n    for (let i = 0; i < node.declarations.length; i += 1) {\n      const declaration = node.declarations[i];\n      value = declaration.init\n        ? await this.walk(declaration.init, context)\n        : undefined;\n      if (value === this.failResult) {\n        return this.failResult;\n      }\n      await this.walkSet(declaration.id, context, value);\n    }\n    return value;\n  }\n\n  async walkAssignmentExpression(node, context) {\n    const value = await this.walk(node.right, context);\n    if (value === this.failResult) {\n      return this.failResult;\n    }\n    let leftValue = await this.walk(node.left, context);\n    if (leftValue === this.failResult) {\n      leftValue = 0;\n    }\n    switch (node.operator) {\n      case '=':\n        await this.walkSet(node.left, context, value);\n        return value;\n      case '+=':\n        leftValue += value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '-=':\n        leftValue -= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '*=':\n        leftValue *= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '/=':\n        leftValue /= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '%=':\n        leftValue %= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '|=':\n        // eslint-disable-next-line\n        leftValue |= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '&=':\n        // eslint-disable-next-line\n        leftValue &= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      case '^=':\n        // eslint-disable-next-line\n        leftValue ^= value;\n        await this.walkSet(node.left, context, leftValue);\n        return leftValue;\n      default:\n        return this.failResult;\n    }\n  }\n\n  async walkBlock(node, context) {\n    if (Array.isArray(node.body)) {\n      let result;\n      for (let i = 0; i < node.body.length; i += 1) {\n        result = await this.walk(node.body[i], context);\n      }\n      return result;\n    }\n    return this.walk(node.body, context);\n  }\n\n  async walk(node, context) {\n    switch (node.type) {\n      case 'Literal':\n        return this.walkLiteral(node, context);\n      case 'UnaryExpression':\n        return this.walkUnary(node, context);\n      case 'ArrayExpression':\n        return this.walkArray(node, context);\n      case 'ObjectExpression':\n        return this.walkObject(node, context);\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        return this.walkBinary(node, context);\n      case 'Identifier':\n        return this.walkIdentifier(node, context);\n      case 'ThisExpression':\n        return this.walkThis(node, context);\n      case 'CallExpression':\n        return this.walkCall(node, context);\n      case 'MemberExpression':\n        return this.walkMember(node, context);\n      case 'ConditionalExpression':\n        return this.walkConditional(node, context);\n      case 'ExpressionStatement':\n        return this.walkExpression(node, context);\n      case 'ReturnStatement':\n        return this.walkReturn(node, context);\n      case 'FunctionExpression':\n        return this.walkFunction(node, context);\n      case 'TemplateLiteral':\n        return this.walkTemplateLiteral(node, context);\n      case 'TemplateElement':\n        return this.walkTemplateElement(node, context);\n      case 'TaggedTemplateExpression':\n        return this.walkTaggedTemplate(node, context);\n      case 'UpdateExpression':\n        return this.walkUpdateExpression(node, context);\n      case 'AssignmentExpression':\n        return this.walkAssignmentExpression(node, context);\n      case 'IfStatement':\n        return this.walkConditional(node, context);\n      case 'BlockStatement':\n        return this.walkBlock(node, context);\n      case 'VariableDeclaration':\n        return this.walkVariableDeclaration(node, context);\n      default:\n        return this.failResult;\n    }\n  }\n\n  walkSetIdentifier(node, context, value) {\n    const newContext = context;\n    if ({}.hasOwnProperty.call(context, node.name)) {\n      context[node.name] = value;\n    } else if (\n      context.input &&\n      {}.hasOwnProperty.call(context.input, node.name)\n    ) {\n      context.input[node.name] = value;\n    } else {\n      newContext[node.name] = value;\n    }\n    return value;\n  }\n\n  async walkSetMember(node, context, value) {\n    const obj = await this.walk(node.object, context);\n    if (obj === this.failResult || typeof obj === 'function') {\n      return this.failResult;\n    }\n    if (node.property.type === 'Identifier') {\n      obj[node.property.name] = value;\n      return value;\n    }\n    const prop = await this.walk(node.property, context);\n    if (prop === this.failResult) {\n      return this.failResult;\n    }\n    if (!obj) {\n      return this.failResult;\n    }\n    obj[prop] = value;\n    return value;\n  }\n\n  async walkSet(node, context, value) {\n    switch (node.type) {\n      case 'Identifier':\n        return this.walkSetIdentifier(node, context, value);\n      case 'MemberExpression':\n        return this.walkSetMember(node, context, value);\n      default:\n        return this.failResult;\n    }\n  }\n\n  async evaluateAll(str, context) {\n    const result = [];\n    const newContext = context || this.context;\n    const compiled = parse(str);\n    for (let i = 0; i < compiled.body.length; i += 1) {\n      let expression = compiled.body[i].expression\n        ? compiled.body[i].expression\n        : compiled.body[i];\n      if (\n        expression.callee &&\n        expression.callee.type === 'ArrowFunctionExpression'\n      ) {\n        expression = expression.callee.body;\n      }\n      const value = await this.walk(expression, newContext);\n      result.push(value === this.failResult ? undefined : value);\n    }\n    return result;\n  }\n\n  async evaluate(str, context) {\n    const result = await this.evaluateAll(str, context);\n    if (!result || result.length === 0) {\n      return undefined;\n    }\n    return result[result.length - 1];\n  }\n\n  async execute(compiled, srcInput, srcObject) {\n    const context = {\n      this: srcObject,\n      input: srcInput,\n    };\n    await this.evaluate(compiled, context);\n  }\n}\n\nmodule.exports = JavascriptCompiler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}