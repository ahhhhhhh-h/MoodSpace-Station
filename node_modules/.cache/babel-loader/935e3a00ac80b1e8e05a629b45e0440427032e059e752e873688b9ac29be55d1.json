{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  KoreanPos\n} = require('./korean-pos');\nconst {\n  KoreanToken\n} = require('./korean-token');\nconst ChunkMatch = require('./chunk-match');\nconst POS_PATTERNS = {\n  [KoreanPos.Email]: /([A-Za-z0-9.\\-_]+@[A-Za-z0-9.]+)/,\n  [KoreanPos.Number]: /(\\$?[0-9]+(,[0-9]{3})*([/~:.-][0-9]+)?(천|만|억|조)*(%|원|달러|위안|옌|엔|유로|등|년|월|일|회|시간|시|분|초)?)/,\n  [KoreanPos.Korean]: /([가-힣]+)/,\n  [KoreanPos.KoreanParticle]: /([ㄱ-ㅣ]+)/,\n  [KoreanPos.Alpha]: /([A-Za-z]+)/,\n  [KoreanPos.Punctuation]: /([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~·…’]+)/,\n  [KoreanPos.Space]: /\\s+/\n};\nconst CHUNKING_ORDER = [KoreanPos.Email, KoreanPos.Number, KoreanPos.Korean, KoreanPos.KoreanParticle, KoreanPos.Alpha, KoreanPos.Punctuation];\nfunction splitBySpace(s) {\n  const space = /\\s+/g;\n  const tokens = [];\n  let m = space.exec(s);\n  let index = 0;\n  while (m) {\n    if (index < m.index) {\n      tokens.push(s.substring(index, m.index));\n    }\n    tokens.push(m[0]);\n    index = m.index + m[0].length;\n    m = space.exec(s);\n  }\n  tokens.push(s.substring(index, s.length));\n  return tokens;\n}\nfunction fillInUnmatched(text, chunks) {\n  const chunksWithForeign = [];\n  let prevEnd = 0;\n  for (let i = 0; i < chunks.length; i += 1) {\n    const cm = chunks[i];\n    if (cm.start === prevEnd) {\n      chunksWithForeign.push(cm);\n    } else if (cm.start > prevEnd) {\n      chunksWithForeign.push(new ChunkMatch(prevEnd, cm.start, text.substring(prevEnd, cm.start), KoreanPos.Foreign));\n      chunksWithForeign.push(cm);\n    }\n    prevEnd = cm.end;\n  }\n  if (prevEnd < text.length) {\n    chunksWithForeign.push(new ChunkMatch(prevEnd, text.length, text.substring(prevEnd, text.length), KoreanPos.Foreign));\n  }\n  return chunksWithForeign;\n}\nfunction splitChunks(text) {\n  if (/\\s/.test(text[0])) {\n    return [new ChunkMatch(0, text.length, text, KoreanPos.Space)];\n  }\n  const chunksMatched = [];\n  let matchedLen = 0;\n  for (let i = 0; i < CHUNKING_ORDER.length; i += 1) {\n    if (matchedLen < text.length) {\n      const pos = CHUNKING_ORDER[i];\n      const r = new RegExp(POS_PATTERNS[pos].source, 'gi');\n      let m = r.exec(text);\n      while (m) {\n        const cm = new ChunkMatch(m.index, m.index + m[0].length, m[0], pos);\n        if (chunksMatched.filter(c => cm.disjoint(c) === false).length === 0) {\n          chunksMatched.push(cm);\n          matchedLen += m[0].length;\n        }\n        m = r.exec(text);\n      }\n    }\n  }\n  chunksMatched.sort((a, b) => a.start - b.start);\n  return fillInUnmatched(text, chunksMatched);\n}\nfunction chunk(input) {\n  const l = [].concat(...splitBySpace(input).map(splitChunks));\n  let segStart = 0;\n  const tokens = l.map(m => {\n    segStart = input.indexOf(m.text, segStart);\n    return new KoreanToken(m.text, m.pos, segStart, m.text.length);\n  });\n  return tokens;\n}\nfunction getChunks(input) {\n  return chunk(input).map(c => c.text);\n}\nfunction getChunksByPos(input, pos) {\n  return chunk(input).filter(x => x.pos === pos);\n}\nmodule.exports = {\n  chunk,\n  getChunks,\n  getChunksByPos\n};","map":{"version":3,"names":["KoreanPos","require","KoreanToken","ChunkMatch","POS_PATTERNS","Email","Number","Korean","KoreanParticle","Alpha","Punctuation","Space","CHUNKING_ORDER","splitBySpace","s","space","tokens","m","exec","index","push","substring","length","fillInUnmatched","text","chunks","chunksWithForeign","prevEnd","i","cm","start","Foreign","end","splitChunks","test","chunksMatched","matchedLen","pos","r","RegExp","source","filter","c","disjoint","sort","a","b","chunk","input","l","concat","map","segStart","indexOf","getChunks","getChunksByPos","x","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/lang-ko/src/korean-chunker.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { KoreanPos } = require('./korean-pos');\nconst { KoreanToken } = require('./korean-token');\nconst ChunkMatch = require('./chunk-match');\n\nconst POS_PATTERNS = {\n  [KoreanPos.Email]: /([A-Za-z0-9.\\-_]+@[A-Za-z0-9.]+)/,\n  [KoreanPos.Number]:\n    /(\\$?[0-9]+(,[0-9]{3})*([/~:.-][0-9]+)?(천|만|억|조)*(%|원|달러|위안|옌|엔|유로|등|년|월|일|회|시간|시|분|초)?)/,\n  [KoreanPos.Korean]: /([가-힣]+)/,\n  [KoreanPos.KoreanParticle]: /([ㄱ-ㅣ]+)/,\n  [KoreanPos.Alpha]: /([A-Za-z]+)/,\n  [KoreanPos.Punctuation]: /([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~·…’]+)/,\n  [KoreanPos.Space]: /\\s+/,\n};\n\nconst CHUNKING_ORDER = [\n  KoreanPos.Email,\n  KoreanPos.Number,\n  KoreanPos.Korean,\n  KoreanPos.KoreanParticle,\n  KoreanPos.Alpha,\n  KoreanPos.Punctuation,\n];\n\nfunction splitBySpace(s) {\n  const space = /\\s+/g;\n  const tokens = [];\n  let m = space.exec(s);\n  let index = 0;\n  while (m) {\n    if (index < m.index) {\n      tokens.push(s.substring(index, m.index));\n    }\n    tokens.push(m[0]);\n    index = m.index + m[0].length;\n    m = space.exec(s);\n  }\n  tokens.push(s.substring(index, s.length));\n  return tokens;\n}\n\nfunction fillInUnmatched(text, chunks) {\n  const chunksWithForeign = [];\n  let prevEnd = 0;\n  for (let i = 0; i < chunks.length; i += 1) {\n    const cm = chunks[i];\n    if (cm.start === prevEnd) {\n      chunksWithForeign.push(cm);\n    } else if (cm.start > prevEnd) {\n      chunksWithForeign.push(\n        new ChunkMatch(\n          prevEnd,\n          cm.start,\n          text.substring(prevEnd, cm.start),\n          KoreanPos.Foreign\n        )\n      );\n      chunksWithForeign.push(cm);\n    }\n    prevEnd = cm.end;\n  }\n  if (prevEnd < text.length) {\n    chunksWithForeign.push(\n      new ChunkMatch(\n        prevEnd,\n        text.length,\n        text.substring(prevEnd, text.length),\n        KoreanPos.Foreign\n      )\n    );\n  }\n  return chunksWithForeign;\n}\n\nfunction splitChunks(text) {\n  if (/\\s/.test(text[0])) {\n    return [new ChunkMatch(0, text.length, text, KoreanPos.Space)];\n  }\n  const chunksMatched = [];\n  let matchedLen = 0;\n  for (let i = 0; i < CHUNKING_ORDER.length; i += 1) {\n    if (matchedLen < text.length) {\n      const pos = CHUNKING_ORDER[i];\n      const r = new RegExp(POS_PATTERNS[pos].source, 'gi');\n      let m = r.exec(text);\n      while (m) {\n        const cm = new ChunkMatch(m.index, m.index + m[0].length, m[0], pos);\n        if (\n          chunksMatched.filter((c) => cm.disjoint(c) === false).length === 0\n        ) {\n          chunksMatched.push(cm);\n          matchedLen += m[0].length;\n        }\n        m = r.exec(text);\n      }\n    }\n  }\n  chunksMatched.sort((a, b) => a.start - b.start);\n  return fillInUnmatched(text, chunksMatched);\n}\n\nfunction chunk(input) {\n  const l = [].concat(...splitBySpace(input).map(splitChunks));\n  let segStart = 0;\n  const tokens = l.map((m) => {\n    segStart = input.indexOf(m.text, segStart);\n    return new KoreanToken(m.text, m.pos, segStart, m.text.length);\n  });\n  return tokens;\n}\n\nfunction getChunks(input) {\n  return chunk(input).map((c) => c.text);\n}\n\nfunction getChunksByPos(input, pos) {\n  return chunk(input).filter((x) => x.pos === pos);\n}\n\nmodule.exports = {\n  chunk,\n  getChunks,\n  getChunksByPos,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}