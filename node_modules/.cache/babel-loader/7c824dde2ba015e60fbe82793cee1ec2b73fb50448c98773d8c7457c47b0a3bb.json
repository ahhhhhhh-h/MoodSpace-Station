{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst XLSX = require('xlsx');\nconst XTable = require('./xtable');\nconst XTableUtils = require('./xtable-utils');\nclass XDoc {\n  constructor() {\n    this.tables = [];\n    this.tablesByName = {};\n  }\n  getRect(sheet) {\n    const keys = Object.keys(sheet);\n    let minRow;\n    let maxRow;\n    let minColumn;\n    let maxColumn;\n    for (let i = 0, l = keys.length; i < l; i += 1) {\n      const key = keys[i];\n      if (key[0] !== '!') {\n        const coord = XTableUtils.excel2coord(key);\n        if (minColumn === undefined || minColumn > coord.column) {\n          minColumn = coord.column;\n        }\n        if (maxColumn === undefined || maxColumn < coord.column) {\n          maxColumn = coord.column;\n        }\n        if (minRow === undefined || minRow > coord.row) {\n          minRow = coord.row;\n        }\n        if (maxRow === undefined || maxRow < coord.row) {\n          maxRow = coord.row;\n        }\n      }\n    }\n    return {\n      top: minRow,\n      bottom: maxRow,\n      left: minColumn,\n      right: maxColumn\n    };\n  }\n  isEmptyRow(block, index) {\n    const row = block[index];\n    if (!row) {\n      return true;\n    }\n    for (let i = 0; i < row.length; i += 1) {\n      if (row[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  findEmptyRow(block) {\n    for (let i = 0; i < block.length; i += 1) {\n      if (this.isEmptyRow(block, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  isEmptyColum(block, index) {\n    for (let i = 0; i < block.length; i += 1) {\n      if (block[i][index]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  findEmptyColumn(block) {\n    if (!block || block.length === 0) {\n      return -1;\n    }\n    const l = block[0].length;\n    for (let i = 0; i < l; i += 1) {\n      if (this.isEmptyColum(block, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  splitByRow(block, emptyRowIndex, nextEmptyRowIndex) {\n    const block1 = [];\n    const block2 = [];\n    for (let i = 0; i < block.length; i += 1) {\n      if (i < emptyRowIndex) {\n        block1.push(block[i]);\n      } else if (i > nextEmptyRowIndex) {\n        block2.push(block[i]);\n      }\n    }\n    return [block1, block2];\n  }\n  splitByColumn(block, emptyColumnIndex, nextEmptyColumnIndex) {\n    const block1 = [];\n    const block2 = [];\n    for (let i = 0; i < block.length; i += 1) {\n      const row = block[i];\n      const row1 = [];\n      const row2 = [];\n      block1.push(row1);\n      block2.push(row2);\n      for (let j = 0; j < row.length; j += 1) {\n        if (j < emptyColumnIndex) {\n          row1.push(row[j]);\n        } else if (j > nextEmptyColumnIndex) {\n          row2.push(row[j]);\n        }\n      }\n    }\n    if (block2[0].length === 0) {\n      return [block1];\n    }\n    if (block1[0].length === 0) {\n      return [block2];\n    }\n    return [block1, block2];\n  }\n  splitBlock(block) {\n    const emptyRowIndex = this.findEmptyRow(block);\n    if (emptyRowIndex > -1) {\n      let nextEmptyRowIndex = emptyRowIndex;\n      while (nextEmptyRowIndex < block.length && this.isEmptyRow(block, nextEmptyRowIndex + 1)) {\n        nextEmptyRowIndex += 1;\n      }\n      return this.splitByRow(block, emptyRowIndex, nextEmptyRowIndex);\n    }\n    const emptyColumnIndex = this.findEmptyColumn(block);\n    if (emptyColumnIndex > -1) {\n      let nextEmptyColumnIndex = emptyColumnIndex;\n      while (nextEmptyColumnIndex < block[0].length && this.isEmptyColum(block, nextEmptyColumnIndex + 1)) {\n        nextEmptyColumnIndex += 1;\n      }\n      return this.splitByColumn(block, emptyColumnIndex, nextEmptyColumnIndex);\n    }\n    return [block];\n  }\n  processSheet(sheet) {\n    const rect = this.getRect(sheet);\n    let pendingBlocks = [];\n    let currentBlock = [];\n    for (let j = rect.top; j <= rect.bottom; j += 1) {\n      const currentRow = [];\n      currentBlock.push(currentRow);\n      for (let i = rect.left; i <= rect.right; i += 1) {\n        const cellRef = XTableUtils.coord2excel({\n          row: j,\n          column: i\n        });\n        currentRow.push(sheet[cellRef]);\n      }\n    }\n    pendingBlocks.push(currentBlock);\n    let modified = true;\n    while (modified) {\n      modified = false;\n      const oldBlocks = pendingBlocks;\n      pendingBlocks = [];\n      for (let i = 0; i < oldBlocks.length; i += 1) {\n        currentBlock = oldBlocks[i];\n        const newBlocks = this.splitBlock(currentBlock);\n        if (newBlocks.length > 1 && !modified) {\n          modified = true;\n        }\n        for (let j = 0; j < newBlocks.length; j += 1) {\n          pendingBlocks.push(newBlocks[j]);\n        }\n      }\n    }\n    for (let i = 0; i < pendingBlocks.length; i += 1) {\n      const table = new XTable(pendingBlocks[i]);\n      this.tables.push(table);\n      this.tablesByName[table.name] = table;\n    }\n  }\n  read(filename) {\n    const wb = XLSX.readFile(filename);\n    for (let i = 0, l = wb.SheetNames.length; i < l; i += 1) {\n      this.processSheet(wb.Sheets[wb.SheetNames[i]]);\n    }\n  }\n  getTable(name) {\n    return this.tablesByName[name];\n  }\n  find(name, query) {\n    const table = this.tablesByName[name];\n    if (!table) {\n      return [];\n    }\n    return table.find(query);\n  }\n  findOne(name, query) {\n    const table = this.tablesByName[name];\n    if (!table) {\n      return undefined;\n    }\n    return table.findOne(query);\n  }\n}\nmodule.exports = XDoc;","map":{"version":3,"names":["XLSX","require","XTable","XTableUtils","XDoc","constructor","tables","tablesByName","getRect","sheet","keys","Object","minRow","maxRow","minColumn","maxColumn","i","l","length","key","coord","excel2coord","undefined","column","row","top","bottom","left","right","isEmptyRow","block","index","findEmptyRow","isEmptyColum","findEmptyColumn","splitByRow","emptyRowIndex","nextEmptyRowIndex","block1","block2","push","splitByColumn","emptyColumnIndex","nextEmptyColumnIndex","row1","row2","j","splitBlock","processSheet","rect","pendingBlocks","currentBlock","currentRow","cellRef","coord2excel","modified","oldBlocks","newBlocks","table","name","read","filename","wb","readFile","SheetNames","Sheets","getTable","find","query","findOne","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/xtables/src/xdoc.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst XLSX = require('xlsx');\nconst XTable = require('./xtable');\nconst XTableUtils = require('./xtable-utils');\n\nclass XDoc {\n  constructor() {\n    this.tables = [];\n    this.tablesByName = {};\n  }\n\n  getRect(sheet) {\n    const keys = Object.keys(sheet);\n    let minRow;\n    let maxRow;\n    let minColumn;\n    let maxColumn;\n    for (let i = 0, l = keys.length; i < l; i += 1) {\n      const key = keys[i];\n      if (key[0] !== '!') {\n        const coord = XTableUtils.excel2coord(key);\n        if (minColumn === undefined || minColumn > coord.column) {\n          minColumn = coord.column;\n        }\n        if (maxColumn === undefined || maxColumn < coord.column) {\n          maxColumn = coord.column;\n        }\n        if (minRow === undefined || minRow > coord.row) {\n          minRow = coord.row;\n        }\n        if (maxRow === undefined || maxRow < coord.row) {\n          maxRow = coord.row;\n        }\n      }\n    }\n    return {\n      top: minRow,\n      bottom: maxRow,\n      left: minColumn,\n      right: maxColumn,\n    };\n  }\n\n  isEmptyRow(block, index) {\n    const row = block[index];\n    if (!row) {\n      return true;\n    }\n    for (let i = 0; i < row.length; i += 1) {\n      if (row[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  findEmptyRow(block) {\n    for (let i = 0; i < block.length; i += 1) {\n      if (this.isEmptyRow(block, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  isEmptyColum(block, index) {\n    for (let i = 0; i < block.length; i += 1) {\n      if (block[i][index]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  findEmptyColumn(block) {\n    if (!block || block.length === 0) {\n      return -1;\n    }\n    const l = block[0].length;\n    for (let i = 0; i < l; i += 1) {\n      if (this.isEmptyColum(block, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  splitByRow(block, emptyRowIndex, nextEmptyRowIndex) {\n    const block1 = [];\n    const block2 = [];\n    for (let i = 0; i < block.length; i += 1) {\n      if (i < emptyRowIndex) {\n        block1.push(block[i]);\n      } else if (i > nextEmptyRowIndex) {\n        block2.push(block[i]);\n      }\n    }\n    return [block1, block2];\n  }\n\n  splitByColumn(block, emptyColumnIndex, nextEmptyColumnIndex) {\n    const block1 = [];\n    const block2 = [];\n    for (let i = 0; i < block.length; i += 1) {\n      const row = block[i];\n      const row1 = [];\n      const row2 = [];\n      block1.push(row1);\n      block2.push(row2);\n      for (let j = 0; j < row.length; j += 1) {\n        if (j < emptyColumnIndex) {\n          row1.push(row[j]);\n        } else if (j > nextEmptyColumnIndex) {\n          row2.push(row[j]);\n        }\n      }\n    }\n    if (block2[0].length === 0) {\n      return [block1];\n    }\n    if (block1[0].length === 0) {\n      return [block2];\n    }\n    return [block1, block2];\n  }\n\n  splitBlock(block) {\n    const emptyRowIndex = this.findEmptyRow(block);\n    if (emptyRowIndex > -1) {\n      let nextEmptyRowIndex = emptyRowIndex;\n      while (\n        nextEmptyRowIndex < block.length &&\n        this.isEmptyRow(block, nextEmptyRowIndex + 1)\n      ) {\n        nextEmptyRowIndex += 1;\n      }\n      return this.splitByRow(block, emptyRowIndex, nextEmptyRowIndex);\n    }\n    const emptyColumnIndex = this.findEmptyColumn(block);\n    if (emptyColumnIndex > -1) {\n      let nextEmptyColumnIndex = emptyColumnIndex;\n      while (\n        nextEmptyColumnIndex < block[0].length &&\n        this.isEmptyColum(block, nextEmptyColumnIndex + 1)\n      ) {\n        nextEmptyColumnIndex += 1;\n      }\n      return this.splitByColumn(block, emptyColumnIndex, nextEmptyColumnIndex);\n    }\n    return [block];\n  }\n\n  processSheet(sheet) {\n    const rect = this.getRect(sheet);\n    let pendingBlocks = [];\n    let currentBlock = [];\n    for (let j = rect.top; j <= rect.bottom; j += 1) {\n      const currentRow = [];\n      currentBlock.push(currentRow);\n      for (let i = rect.left; i <= rect.right; i += 1) {\n        const cellRef = XTableUtils.coord2excel({ row: j, column: i });\n        currentRow.push(sheet[cellRef]);\n      }\n    }\n    pendingBlocks.push(currentBlock);\n    let modified = true;\n    while (modified) {\n      modified = false;\n      const oldBlocks = pendingBlocks;\n      pendingBlocks = [];\n      for (let i = 0; i < oldBlocks.length; i += 1) {\n        currentBlock = oldBlocks[i];\n        const newBlocks = this.splitBlock(currentBlock);\n        if (newBlocks.length > 1 && !modified) {\n          modified = true;\n        }\n        for (let j = 0; j < newBlocks.length; j += 1) {\n          pendingBlocks.push(newBlocks[j]);\n        }\n      }\n    }\n    for (let i = 0; i < pendingBlocks.length; i += 1) {\n      const table = new XTable(pendingBlocks[i]);\n      this.tables.push(table);\n      this.tablesByName[table.name] = table;\n    }\n  }\n\n  read(filename) {\n    const wb = XLSX.readFile(filename);\n    for (let i = 0, l = wb.SheetNames.length; i < l; i += 1) {\n      this.processSheet(wb.Sheets[wb.SheetNames[i]]);\n    }\n  }\n\n  getTable(name) {\n    return this.tablesByName[name];\n  }\n\n  find(name, query) {\n    const table = this.tablesByName[name];\n    if (!table) {\n      return [];\n    }\n    return table.find(query);\n  }\n\n  findOne(name, query) {\n    const table = this.tablesByName[name];\n    if (!table) {\n      return undefined;\n    }\n    return table.findOne(query);\n  }\n}\n\nmodule.exports = XDoc;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}