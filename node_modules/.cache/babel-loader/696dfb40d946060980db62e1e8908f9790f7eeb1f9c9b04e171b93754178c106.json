{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Class for a Slot Manager that takes care of the slot information.\n */\nclass SlotManager {\n  /**\n   * Constructor of the class.\n   */\n  constructor() {\n    this.intents = {};\n    this.isEmpty = true;\n  }\n\n  /**\n   * Returns an slot given the intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @returns {Object} Slot or undefined if not found.\n   */\n  getSlot(intent, entity) {\n    if (!this.intents[intent]) {\n      return undefined;\n    }\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Indicates if a given slot exists, given the intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @returns {boolean} True if the slot exists, false otherwise.\n   */\n  existsSlot(intent, entity) {\n    return this.getSlot(intent, entity) !== undefined;\n  }\n\n  /**\n   * Adds a new slot for a given intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @param {boolean} [mandatory=false] Flag indicating if is mandatory or optional.\n   * @param {Object} [questions] Question to ask when is mandatory, by locale.\n   * @returns {Object} New slot instance.\n   */\n  addSlot(intent, entity, mandatory = false, questions) {\n    this.isEmpty = false;\n    if (!this.intents[intent]) {\n      this.intents[intent] = {};\n    }\n    this.intents[intent][entity] = {\n      intent,\n      entity,\n      mandatory,\n      locales: questions || {}\n    };\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Adds/modifies the parameter of a slot for a given intent and entity.\n   * Slot questions for same locales as already existing will be overwritten.\n   * If the slot for the intent and entity does not exist it fill be created.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @param {boolean} mandatory Flag indicating if is mandatory or optional.\n   * @param {Object} [questions] Question to ask when is mandatory, by locale.\n   * @returns {Object} New/Modified slot instance or undefined if not existing\n   */\n  updateSlot(intent, entity, mandatory, questions) {\n    if (!this.intents[intent] || !this.intents[intent][entity]) {\n      return this.addSlot(intent, entity, mandatory, questions);\n    }\n    const slot = this.intents[intent][entity];\n    if (mandatory !== undefined) {\n      // Update mandatory flag only if provided\n      slot.mandatory = mandatory;\n    }\n    slot.locales = Object.assign(slot.locales, questions);\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Remove an slot given the intent and the entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   */\n  removeSlot(intent, entity) {\n    if (this.intents[intent]) {\n      delete this.intents[intent][entity];\n    }\n  }\n\n  /**\n   * Add several entities if they don't exists.\n   * @param {String} intent Name of the intent.\n   * @param {String[]} entities List of entities.\n   * @returns {Object[]} Array of resulting entities.\n   */\n  addBatch(intent, entities) {\n    const result = [];\n    if (entities && entities.length > 0) {\n      entities.forEach(entity => {\n        let slot = this.getSlot(intent, entity);\n        if (!slot) {\n          slot = this.addSlot(intent, entity);\n        }\n        result.push(slot);\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Given an intent, return the array of entity names of this intent.\n   * @param {String} intent Name of the intent.\n   * @returns {String[]} Array of entity names of the intent.\n   */\n  getIntentEntityNames(intent) {\n    if (!this.intents[intent]) {\n      return undefined;\n    }\n    return Object.keys(this.intents[intent]);\n  }\n\n  /**\n   * Given an intent return the information if the intent has entities defined\n   *\n   * @param {String} intent Name of the intent.\n   * @returns {boolean} true if intent has defined entities, else false\n   */\n  hasIntentEntities(intent) {\n    return this.getIntentEntityNames(intent).length > 0;\n  }\n\n  /**\n   * Clear the slot manager.\n   */\n  clear() {\n    this.intents = {};\n  }\n\n  /**\n   * Loads the slot manager content.\n   * @param {Object} src Source content.\n   */\n  load(src) {\n    this.intents = src || {};\n    this.isEmpty = Object.keys(this.intents).length === 0;\n  }\n\n  /**\n   * Returns the slot manager content.\n   * @returns {Object} Slot manager content.\n   */\n  save() {\n    return this.intents;\n  }\n\n  /**\n   * Given an intent return the mandatory slots.\n   * @param {String} intent Name of the intent\n   * @returns {Object} Object with the mandatory slots.\n   */\n  getMandatorySlots(intent) {\n    const result = {};\n    const intentSlots = this.intents[intent];\n    if (intentSlots) {\n      const keys = Object.keys(intentSlots);\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const slot = intentSlots[keys[i]];\n        if (slot.mandatory) {\n          result[slot.entity] = slot;\n        }\n      }\n    }\n    return result;\n  }\n  cleanContextEntities(intent, srcContext) {\n    const context = srcContext;\n    if (context.slotFill) {\n      return;\n    }\n    const mandatorySlots = this.getMandatorySlots(intent);\n    const keys = Object.keys(mandatorySlots);\n    if (keys.length === 0) {\n      return;\n    }\n    keys.forEach(key => {\n      delete context[key];\n    });\n  }\n  generateEntityAliases(entities) {\n    const aliases = [];\n    const dict = {};\n    for (let i = 0; i < entities.length; i += 1) {\n      const entity = entities[i];\n      if (!dict[entity.entity]) {\n        dict[entity.entity] = [];\n      }\n      aliases[i] = `${entity.entity}_${dict[entity.entity].length}`;\n      dict[entity.entity].push(true);\n    }\n    return aliases;\n  }\n  process(srcResult, srcContext) {\n    const result = srcResult;\n    const context = srcContext;\n    this.cleanContextEntities(result.intent, context);\n    if (context.slotFill) {\n      // if we have slotFill values we set the context to be the same as before\n      result.intent = context.slotFill.intent;\n      result.answer = context.slotFill.answer;\n      result.srcAnswer = context.slotFill.srcAnswer;\n    }\n    if (!result.intent || result.intent === 'None') {\n      // No intent found, we repeat the answer from last time\n      return false;\n    }\n    if (context.slotFill && context.slotFill.intent === result.intent) {\n      result.entities = [...context.slotFill.entities, ...result.entities];\n    }\n    const mandatorySlots = this.getMandatorySlots(result.intent);\n    let keys = Object.keys(mandatorySlots);\n    if (keys.length === 0) {\n      // No mandatory entities defined, we repeat the answer from last time\n      return false;\n    }\n    const aliases = this.generateEntityAliases(result.entities);\n    for (let i = 0, l = result.entities.length; i < l; i += 1) {\n      const entity = result.entities[i];\n      // Remove existing mandatory entities to see what's left\n      delete mandatorySlots[entity.entity];\n      delete mandatorySlots[aliases[i]];\n    }\n    if (context.slotFill && mandatorySlots[context.slotFill.currentSlot]) {\n      // Last time requested slot was not filled by current answer automatically,\n      // so add whole utterance as answer for the requested slow\n      // Do this because automatically parsed entities by builtins like \"duration\" are\n      // added automatically, and we don't want to have duplicated entries in the list\n      result.entities.push({\n        entity: context.slotFill.currentSlot,\n        utteranceText: result.utterance,\n        sourceText: result.utterance,\n        accuracy: 0.95,\n        start: 0,\n        end: result.utterance.length - 1,\n        len: result.utterance.length,\n        isSlotFillingFallback: true\n      });\n      delete mandatorySlots[context.slotFill.currentSlot];\n    }\n    keys = Object.keys(mandatorySlots);\n    if (context.slotFill && context.slotFill.currentSlot) {\n      context.slotFill.latestSlot = context.slotFill.currentSlot;\n    }\n    if (!keys || keys.length === 0) {\n      // All mandatory slots are filled, so we are done. No further questions needed\n      delete result.srcAnswer;\n      return true;\n    }\n    if (context.slotFill && context.slotFill.intent === result.intent) {\n      result.localeIso2 = context.slotFill.localeIso2;\n    }\n    result.slotFill = {\n      localeIso2: result.localeIso2,\n      intent: result.intent,\n      entities: result.entities,\n      answer: result.answer,\n      srcAnswer: result.srcAnswer\n    };\n    if (context.slotFill && context.slotFill.latestSlot) {\n      result.slotFill.latestSlot = context.slotFill.latestSlot;\n    }\n    const currentSlot = mandatorySlots[keys[0]];\n    result.slotFill.currentSlot = currentSlot.entity;\n    result.srcAnswer = currentSlot.locales[result.localeIso2];\n    context.slotFill = result.slotFill;\n    return true;\n  }\n}\nmodule.exports = SlotManager;","map":{"version":3,"names":["SlotManager","constructor","intents","isEmpty","getSlot","intent","entity","undefined","existsSlot","addSlot","mandatory","questions","locales","updateSlot","slot","Object","assign","removeSlot","addBatch","entities","result","length","forEach","push","getIntentEntityNames","keys","hasIntentEntities","clear","load","src","save","getMandatorySlots","intentSlots","i","l","cleanContextEntities","srcContext","context","slotFill","mandatorySlots","key","generateEntityAliases","aliases","dict","process","srcResult","answer","srcAnswer","currentSlot","utteranceText","utterance","sourceText","accuracy","start","end","len","isSlotFillingFallback","latestSlot","localeIso2","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/slot/src/slot-manager.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Class for a Slot Manager that takes care of the slot information.\n */\nclass SlotManager {\n  /**\n   * Constructor of the class.\n   */\n  constructor() {\n    this.intents = {};\n    this.isEmpty = true;\n  }\n\n  /**\n   * Returns an slot given the intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @returns {Object} Slot or undefined if not found.\n   */\n  getSlot(intent, entity) {\n    if (!this.intents[intent]) {\n      return undefined;\n    }\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Indicates if a given slot exists, given the intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @returns {boolean} True if the slot exists, false otherwise.\n   */\n  existsSlot(intent, entity) {\n    return this.getSlot(intent, entity) !== undefined;\n  }\n\n  /**\n   * Adds a new slot for a given intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @param {boolean} [mandatory=false] Flag indicating if is mandatory or optional.\n   * @param {Object} [questions] Question to ask when is mandatory, by locale.\n   * @returns {Object} New slot instance.\n   */\n  addSlot(intent, entity, mandatory = false, questions) {\n    this.isEmpty = false;\n    if (!this.intents[intent]) {\n      this.intents[intent] = {};\n    }\n    this.intents[intent][entity] = {\n      intent,\n      entity,\n      mandatory,\n      locales: questions || {},\n    };\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Adds/modifies the parameter of a slot for a given intent and entity.\n   * Slot questions for same locales as already existing will be overwritten.\n   * If the slot for the intent and entity does not exist it fill be created.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @param {boolean} mandatory Flag indicating if is mandatory or optional.\n   * @param {Object} [questions] Question to ask when is mandatory, by locale.\n   * @returns {Object} New/Modified slot instance or undefined if not existing\n   */\n  updateSlot(intent, entity, mandatory, questions) {\n    if (!this.intents[intent] || !this.intents[intent][entity]) {\n      return this.addSlot(intent, entity, mandatory, questions);\n    }\n    const slot = this.intents[intent][entity];\n    if (mandatory !== undefined) {\n      // Update mandatory flag only if provided\n      slot.mandatory = mandatory;\n    }\n    slot.locales = Object.assign(slot.locales, questions);\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Remove an slot given the intent and the entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   */\n  removeSlot(intent, entity) {\n    if (this.intents[intent]) {\n      delete this.intents[intent][entity];\n    }\n  }\n\n  /**\n   * Add several entities if they don't exists.\n   * @param {String} intent Name of the intent.\n   * @param {String[]} entities List of entities.\n   * @returns {Object[]} Array of resulting entities.\n   */\n  addBatch(intent, entities) {\n    const result = [];\n    if (entities && entities.length > 0) {\n      entities.forEach((entity) => {\n        let slot = this.getSlot(intent, entity);\n        if (!slot) {\n          slot = this.addSlot(intent, entity);\n        }\n        result.push(slot);\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Given an intent, return the array of entity names of this intent.\n   * @param {String} intent Name of the intent.\n   * @returns {String[]} Array of entity names of the intent.\n   */\n  getIntentEntityNames(intent) {\n    if (!this.intents[intent]) {\n      return undefined;\n    }\n    return Object.keys(this.intents[intent]);\n  }\n\n  /**\n   * Given an intent return the information if the intent has entities defined\n   *\n   * @param {String} intent Name of the intent.\n   * @returns {boolean} true if intent has defined entities, else false\n   */\n  hasIntentEntities(intent) {\n    return this.getIntentEntityNames(intent).length > 0;\n  }\n\n  /**\n   * Clear the slot manager.\n   */\n  clear() {\n    this.intents = {};\n  }\n\n  /**\n   * Loads the slot manager content.\n   * @param {Object} src Source content.\n   */\n  load(src) {\n    this.intents = src || {};\n    this.isEmpty = Object.keys(this.intents).length === 0;\n  }\n\n  /**\n   * Returns the slot manager content.\n   * @returns {Object} Slot manager content.\n   */\n  save() {\n    return this.intents;\n  }\n\n  /**\n   * Given an intent return the mandatory slots.\n   * @param {String} intent Name of the intent\n   * @returns {Object} Object with the mandatory slots.\n   */\n  getMandatorySlots(intent) {\n    const result = {};\n    const intentSlots = this.intents[intent];\n    if (intentSlots) {\n      const keys = Object.keys(intentSlots);\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const slot = intentSlots[keys[i]];\n        if (slot.mandatory) {\n          result[slot.entity] = slot;\n        }\n      }\n    }\n    return result;\n  }\n\n  cleanContextEntities(intent, srcContext) {\n    const context = srcContext;\n    if (context.slotFill) {\n      return;\n    }\n    const mandatorySlots = this.getMandatorySlots(intent);\n    const keys = Object.keys(mandatorySlots);\n    if (keys.length === 0) {\n      return;\n    }\n    keys.forEach((key) => {\n      delete context[key];\n    });\n  }\n\n  generateEntityAliases(entities) {\n    const aliases = [];\n    const dict = {};\n    for (let i = 0; i < entities.length; i += 1) {\n      const entity = entities[i];\n      if (!dict[entity.entity]) {\n        dict[entity.entity] = [];\n      }\n      aliases[i] = `${entity.entity}_${dict[entity.entity].length}`;\n      dict[entity.entity].push(true);\n    }\n    return aliases;\n  }\n\n  process(srcResult, srcContext) {\n    const result = srcResult;\n    const context = srcContext;\n    this.cleanContextEntities(result.intent, context);\n    if (context.slotFill) {\n      // if we have slotFill values we set the context to be the same as before\n      result.intent = context.slotFill.intent;\n      result.answer = context.slotFill.answer;\n      result.srcAnswer = context.slotFill.srcAnswer;\n    }\n    if (!result.intent || result.intent === 'None') {\n      // No intent found, we repeat the answer from last time\n      return false;\n    }\n    if (context.slotFill && context.slotFill.intent === result.intent) {\n      result.entities = [...context.slotFill.entities, ...result.entities];\n    }\n    const mandatorySlots = this.getMandatorySlots(result.intent);\n    let keys = Object.keys(mandatorySlots);\n    if (keys.length === 0) {\n      // No mandatory entities defined, we repeat the answer from last time\n      return false;\n    }\n    const aliases = this.generateEntityAliases(result.entities);\n    for (let i = 0, l = result.entities.length; i < l; i += 1) {\n      const entity = result.entities[i];\n      // Remove existing mandatory entities to see what's left\n      delete mandatorySlots[entity.entity];\n      delete mandatorySlots[aliases[i]];\n    }\n    if (context.slotFill && mandatorySlots[context.slotFill.currentSlot]) {\n      // Last time requested slot was not filled by current answer automatically,\n      // so add whole utterance as answer for the requested slow\n      // Do this because automatically parsed entities by builtins like \"duration\" are\n      // added automatically, and we don't want to have duplicated entries in the list\n      result.entities.push({\n        entity: context.slotFill.currentSlot,\n        utteranceText: result.utterance,\n        sourceText: result.utterance,\n        accuracy: 0.95,\n        start: 0,\n        end: result.utterance.length - 1,\n        len: result.utterance.length,\n        isSlotFillingFallback: true,\n      });\n      delete mandatorySlots[context.slotFill.currentSlot];\n    }\n    keys = Object.keys(mandatorySlots);\n    if (context.slotFill && context.slotFill.currentSlot) {\n      context.slotFill.latestSlot = context.slotFill.currentSlot;\n    }\n    if (!keys || keys.length === 0) {\n      // All mandatory slots are filled, so we are done. No further questions needed\n      delete result.srcAnswer;\n      return true;\n    }\n    if (context.slotFill && context.slotFill.intent === result.intent) {\n      result.localeIso2 = context.slotFill.localeIso2;\n    }\n    result.slotFill = {\n      localeIso2: result.localeIso2,\n      intent: result.intent,\n      entities: result.entities,\n      answer: result.answer,\n      srcAnswer: result.srcAnswer,\n    };\n    if (context.slotFill && context.slotFill.latestSlot) {\n      result.slotFill.latestSlot = context.slotFill.latestSlot;\n    }\n    const currentSlot = mandatorySlots[keys[0]];\n    result.slotFill.currentSlot = currentSlot.entity;\n    result.srcAnswer = currentSlot.locales[result.localeIso2];\n    context.slotFill = result.slotFill;\n    return true;\n  }\n}\n\nmodule.exports = SlotManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}