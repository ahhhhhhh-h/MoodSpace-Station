{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nclass DefaultCompiler {\n  constructor(container) {\n    this.container = container.container || container;\n    this.name = 'default';\n  }\n  getTokenFromWord(word) {\n    if (word.startsWith('//')) {\n      return {\n        type: 'comment',\n        value: word\n      };\n    }\n    if (['set', 'delete', 'get', 'inc', 'dec', 'eq', 'neq', 'gt', 'ge', 'lt', 'le', 'label', 'goto', 'jne', 'je'].includes(word)) {\n      return {\n        type: word,\n        arguments: []\n      };\n    }\n    if (word.startsWith('$')) {\n      return {\n        type: 'call',\n        value: word.slice(1)\n      };\n    }\n    return {\n      type: 'reference',\n      value: word\n    };\n  }\n  compile(pipeline) {\n    const result = [];\n    for (let i = 0; i < pipeline.length; i += 1) {\n      const line = pipeline[i].trim();\n      const words = line.split(' ');\n      const tokens = [];\n      let currentString = '';\n      let currentQuote;\n      for (let j = 0; j < words.length; j += 1) {\n        const word = words[j];\n        let processed = false;\n        if (!currentQuote) {\n          if (word.startsWith('\"')) {\n            currentString = word;\n            processed = true;\n            currentQuote = '\"';\n            if (word.endsWith('\"')) {\n              currentQuote = undefined;\n              tokens.push(this.getTokenFromWord(currentString));\n            }\n          } else if (word.startsWith(\"'\")) {\n            currentString = word;\n            processed = true;\n            currentQuote = \"'\";\n            if (word.endsWith(\"'\")) {\n              currentQuote = undefined;\n              tokens.push(this.getTokenFromWord(currentString));\n            }\n          }\n        } else {\n          currentString = `${currentString} ${word}`;\n          processed = true;\n          if (word.endsWith(currentQuote)) {\n            currentQuote = undefined;\n            tokens.push(this.getTokenFromWord(currentString));\n          }\n        }\n        if (!processed) {\n          tokens.push(this.getTokenFromWord(word));\n        }\n      }\n      result.push(tokens);\n    }\n    return result;\n  }\n  executeCall(firstToken, context, input, srcObject, depth) {\n    const pipeline = this.container.getPipeline(firstToken.value);\n    if (!pipeline) {\n      throw new Error(`Pipeline $${firstToken.value} not found.`);\n    }\n    return this.container.runPipeline(pipeline, input, srcObject, depth + 1);\n  }\n  executeReference(step, firstToken, context, input, srcObject) {\n    const currentObject = this.container.resolvePath(firstToken.value, context, input, srcObject);\n    const args = [];\n    for (let i = 1; i < step.length; i += 1) {\n      args.push(this.container.resolvePathWithType(step[i].value, context, input, srcObject));\n    }\n    if (!currentObject) {\n      throw new Error(`Method not found for step ${JSON.stringify(step)}`);\n    }\n    const method = currentObject.run || currentObject;\n    if (typeof method === 'function') {\n      return typeof currentObject === 'function' ? method(input, ...args) : method.bind(currentObject)(input, ...args);\n    }\n    return method;\n  }\n  doGoto(label, srcContext) {\n    const context = srcContext;\n    const index = context.labels[label];\n    context.cursor = index;\n  }\n  async executeAction(step, context, input, srcObject, depth) {\n    let firstToken = step[0];\n    if (firstToken && firstToken.value && firstToken.value.startsWith('->')) {\n      if (depth > 0) {\n        return input;\n      }\n      firstToken = {\n        ...firstToken\n      };\n      firstToken.value = firstToken.value.slice(2);\n    }\n    switch (firstToken.type) {\n      case 'set':\n        this.container.setValue(step[1].value, step[2] ? step[2].value : undefined, context, input, srcObject);\n        break;\n      case 'delete':\n        this.container.deleteValue(step[1].value, context, input, srcObject);\n        break;\n      case 'get':\n        return this.container.getValue(step[1] ? step[1].value : undefined, context, input, srcObject);\n      case 'inc':\n        this.container.incValue(step[1] ? step[1].value : undefined, step[2] ? step[2].value : '1', context, input, srcObject);\n        break;\n      case 'dec':\n        this.container.decValue(step[1] ? step[1].value : undefined, step[2] ? step[2].value : '1', context, input, srcObject);\n        break;\n      case 'eq':\n        this.container.eqValue(step[1] ? step[1].value : undefined, step[2] ? step[2].value : undefined, context, input, srcObject);\n        break;\n      case 'neq':\n        this.container.neqValue(step[1] ? step[1].value : undefined, step[2] ? step[2].value : undefined, context, input, srcObject);\n        break;\n      case 'gt':\n        this.container.gtValue(step[1] ? step[1].value : undefined, step[2] ? step[2].value : undefined, context, input, srcObject);\n        break;\n      case 'ge':\n        this.container.geValue(step[1] ? step[1].value : undefined, step[2] ? step[2].value : undefined, context, input, srcObject);\n        break;\n      case 'lt':\n        this.container.ltValue(step[1] ? step[1].value : undefined, step[2] ? step[2].value : undefined, context, input, srcObject);\n        break;\n      case 'le':\n        this.container.leValue(step[1] ? step[1].value : undefined, step[2] ? step[2].value : undefined, context, input, srcObject);\n        break;\n      case 'goto':\n        this.doGoto(step[1].value, context);\n        break;\n      case 'jne':\n        if (!context.floating) {\n          this.doGoto(step[1].value, context);\n        }\n        break;\n      case 'je':\n        if (context.floating) {\n          this.doGoto(step[1].value, context);\n        }\n        break;\n      case 'call':\n        return this.executeCall(firstToken, context, input, srcObject, depth);\n      case 'reference':\n        return this.executeReference(step, firstToken, context, input, srcObject);\n      default:\n        break;\n    }\n    return input;\n  }\n  findLabels(compiled, srcLabels) {\n    const labels = srcLabels;\n    for (let i = 0; i < compiled.length; i += 1) {\n      const current = compiled[i];\n      if (current[0].type === 'label') {\n        labels[current[1].value] = i;\n      }\n    }\n  }\n  async execute(compiled, srcInput, srcObject, depth) {\n    let input = srcInput;\n    const context = {\n      cursor: 0,\n      labels: {}\n    };\n    this.findLabels(compiled, context.labels);\n    while (context.cursor < compiled.length) {\n      input = await this.executeAction(compiled[context.cursor], context, input, srcObject, depth);\n      context.cursor += 1;\n    }\n    return input;\n  }\n}\nmodule.exports = DefaultCompiler;","map":{"version":3,"names":["DefaultCompiler","constructor","container","name","getTokenFromWord","word","startsWith","type","value","includes","arguments","slice","compile","pipeline","result","i","length","line","trim","words","split","tokens","currentString","currentQuote","j","processed","endsWith","undefined","push","executeCall","firstToken","context","input","srcObject","depth","getPipeline","Error","runPipeline","executeReference","step","currentObject","resolvePath","args","resolvePathWithType","JSON","stringify","method","run","bind","doGoto","label","srcContext","index","labels","cursor","executeAction","setValue","deleteValue","getValue","incValue","decValue","eqValue","neqValue","gtValue","geValue","ltValue","leValue","floating","findLabels","compiled","srcLabels","current","execute","srcInput","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/core/src/default-compiler.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nclass DefaultCompiler {\n  constructor(container) {\n    this.container = container.container || container;\n    this.name = 'default';\n  }\n\n  getTokenFromWord(word) {\n    if (word.startsWith('//')) {\n      return {\n        type: 'comment',\n        value: word,\n      };\n    }\n    if (\n      [\n        'set',\n        'delete',\n        'get',\n        'inc',\n        'dec',\n        'eq',\n        'neq',\n        'gt',\n        'ge',\n        'lt',\n        'le',\n        'label',\n        'goto',\n        'jne',\n        'je',\n      ].includes(word)\n    ) {\n      return {\n        type: word,\n        arguments: [],\n      };\n    }\n    if (word.startsWith('$')) {\n      return {\n        type: 'call',\n        value: word.slice(1),\n      };\n    }\n    return {\n      type: 'reference',\n      value: word,\n    };\n  }\n\n  compile(pipeline) {\n    const result = [];\n    for (let i = 0; i < pipeline.length; i += 1) {\n      const line = pipeline[i].trim();\n      const words = line.split(' ');\n      const tokens = [];\n      let currentString = '';\n      let currentQuote;\n      for (let j = 0; j < words.length; j += 1) {\n        const word = words[j];\n        let processed = false;\n        if (!currentQuote) {\n          if (word.startsWith('\"')) {\n            currentString = word;\n            processed = true;\n            currentQuote = '\"';\n            if (word.endsWith('\"')) {\n              currentQuote = undefined;\n              tokens.push(this.getTokenFromWord(currentString));\n            }\n          } else if (word.startsWith(\"'\")) {\n            currentString = word;\n            processed = true;\n            currentQuote = \"'\";\n            if (word.endsWith(\"'\")) {\n              currentQuote = undefined;\n              tokens.push(this.getTokenFromWord(currentString));\n            }\n          }\n        } else {\n          currentString = `${currentString} ${word}`;\n          processed = true;\n          if (word.endsWith(currentQuote)) {\n            currentQuote = undefined;\n            tokens.push(this.getTokenFromWord(currentString));\n          }\n        }\n        if (!processed) {\n          tokens.push(this.getTokenFromWord(word));\n        }\n      }\n      result.push(tokens);\n    }\n    return result;\n  }\n\n  executeCall(firstToken, context, input, srcObject, depth) {\n    const pipeline = this.container.getPipeline(firstToken.value);\n    if (!pipeline) {\n      throw new Error(`Pipeline $${firstToken.value} not found.`);\n    }\n    return this.container.runPipeline(pipeline, input, srcObject, depth + 1);\n  }\n\n  executeReference(step, firstToken, context, input, srcObject) {\n    const currentObject = this.container.resolvePath(\n      firstToken.value,\n      context,\n      input,\n      srcObject\n    );\n    const args = [];\n    for (let i = 1; i < step.length; i += 1) {\n      args.push(\n        this.container.resolvePathWithType(\n          step[i].value,\n          context,\n          input,\n          srcObject\n        )\n      );\n    }\n    if (!currentObject) {\n      throw new Error(`Method not found for step ${JSON.stringify(step)}`);\n    }\n    const method = currentObject.run || currentObject;\n    if (typeof method === 'function') {\n      return typeof currentObject === 'function'\n        ? method(input, ...args)\n        : method.bind(currentObject)(input, ...args);\n    }\n    return method;\n  }\n\n  doGoto(label, srcContext) {\n    const context = srcContext;\n    const index = context.labels[label];\n    context.cursor = index;\n  }\n\n  async executeAction(step, context, input, srcObject, depth) {\n    let firstToken = step[0];\n    if (firstToken && firstToken.value && firstToken.value.startsWith('->')) {\n      if (depth > 0) {\n        return input;\n      }\n      firstToken = { ...firstToken };\n      firstToken.value = firstToken.value.slice(2);\n    }\n    switch (firstToken.type) {\n      case 'set':\n        this.container.setValue(\n          step[1].value,\n          step[2] ? step[2].value : undefined,\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'delete':\n        this.container.deleteValue(step[1].value, context, input, srcObject);\n        break;\n      case 'get':\n        return this.container.getValue(\n          step[1] ? step[1].value : undefined,\n          context,\n          input,\n          srcObject\n        );\n      case 'inc':\n        this.container.incValue(\n          step[1] ? step[1].value : undefined,\n          step[2] ? step[2].value : '1',\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'dec':\n        this.container.decValue(\n          step[1] ? step[1].value : undefined,\n          step[2] ? step[2].value : '1',\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'eq':\n        this.container.eqValue(\n          step[1] ? step[1].value : undefined,\n          step[2] ? step[2].value : undefined,\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'neq':\n        this.container.neqValue(\n          step[1] ? step[1].value : undefined,\n          step[2] ? step[2].value : undefined,\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'gt':\n        this.container.gtValue(\n          step[1] ? step[1].value : undefined,\n          step[2] ? step[2].value : undefined,\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'ge':\n        this.container.geValue(\n          step[1] ? step[1].value : undefined,\n          step[2] ? step[2].value : undefined,\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'lt':\n        this.container.ltValue(\n          step[1] ? step[1].value : undefined,\n          step[2] ? step[2].value : undefined,\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'le':\n        this.container.leValue(\n          step[1] ? step[1].value : undefined,\n          step[2] ? step[2].value : undefined,\n          context,\n          input,\n          srcObject\n        );\n        break;\n      case 'goto':\n        this.doGoto(step[1].value, context);\n        break;\n      case 'jne':\n        if (!context.floating) {\n          this.doGoto(step[1].value, context);\n        }\n        break;\n      case 'je':\n        if (context.floating) {\n          this.doGoto(step[1].value, context);\n        }\n        break;\n      case 'call':\n        return this.executeCall(firstToken, context, input, srcObject, depth);\n      case 'reference':\n        return this.executeReference(\n          step,\n          firstToken,\n          context,\n          input,\n          srcObject\n        );\n      default:\n        break;\n    }\n    return input;\n  }\n\n  findLabels(compiled, srcLabels) {\n    const labels = srcLabels;\n    for (let i = 0; i < compiled.length; i += 1) {\n      const current = compiled[i];\n      if (current[0].type === 'label') {\n        labels[current[1].value] = i;\n      }\n    }\n  }\n\n  async execute(compiled, srcInput, srcObject, depth) {\n    let input = srcInput;\n    const context = { cursor: 0, labels: {} };\n    this.findLabels(compiled, context.labels);\n    while (context.cursor < compiled.length) {\n      input = await this.executeAction(\n        compiled[context.cursor],\n        context,\n        input,\n        srcObject,\n        depth\n      );\n      context.cursor += 1;\n    }\n    return input;\n  }\n}\n\nmodule.exports = DefaultCompiler;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,eAAe,CAAC;EACpBC,WAAWA,CAACC,SAAS,EAAE;IACrB,IAAI,CAACA,SAAS,GAAGA,SAAS,CAACA,SAAS,IAAIA,SAAS;IACjD,IAAI,CAACC,IAAI,GAAG,SAAS;EACvB;EAEAC,gBAAgBA,CAACC,IAAI,EAAE;IACrB,IAAIA,IAAI,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;MACzB,OAAO;QACLC,IAAI,EAAE,SAAS;QACfC,KAAK,EAAEH;MACT,CAAC;IACH;IACA,IACE,CACE,KAAK,EACL,QAAQ,EACR,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,OAAO,EACP,MAAM,EACN,KAAK,EACL,IAAI,CACL,CAACI,QAAQ,CAACJ,IAAI,CAAC,EAChB;MACA,OAAO;QACLE,IAAI,EAAEF,IAAI;QACVK,SAAS,EAAE;MACb,CAAC;IACH;IACA,IAAIL,IAAI,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;MACxB,OAAO;QACLC,IAAI,EAAE,MAAM;QACZC,KAAK,EAAEH,IAAI,CAACM,KAAK,CAAC,CAAC;MACrB,CAAC;IACH;IACA,OAAO;MACLJ,IAAI,EAAE,WAAW;MACjBC,KAAK,EAAEH;IACT,CAAC;EACH;EAEAO,OAAOA,CAACC,QAAQ,EAAE;IAChB,MAAMC,MAAM,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MAC3C,MAAME,IAAI,GAAGJ,QAAQ,CAACE,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC;MAC/B,MAAMC,KAAK,GAAGF,IAAI,CAACG,KAAK,CAAC,GAAG,CAAC;MAC7B,MAAMC,MAAM,GAAG,EAAE;MACjB,IAAIC,aAAa,GAAG,EAAE;MACtB,IAAIC,YAAY;MAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACH,MAAM,EAAEQ,CAAC,IAAI,CAAC,EAAE;QACxC,MAAMnB,IAAI,GAAGc,KAAK,CAACK,CAAC,CAAC;QACrB,IAAIC,SAAS,GAAG,KAAK;QACrB,IAAI,CAACF,YAAY,EAAE;UACjB,IAAIlB,IAAI,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;YACxBgB,aAAa,GAAGjB,IAAI;YACpBoB,SAAS,GAAG,IAAI;YAChBF,YAAY,GAAG,GAAG;YAClB,IAAIlB,IAAI,CAACqB,QAAQ,CAAC,GAAG,CAAC,EAAE;cACtBH,YAAY,GAAGI,SAAS;cACxBN,MAAM,CAACO,IAAI,CAAC,IAAI,CAACxB,gBAAgB,CAACkB,aAAa,CAAC,CAAC;YACnD;UACF,CAAC,MAAM,IAAIjB,IAAI,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;YAC/BgB,aAAa,GAAGjB,IAAI;YACpBoB,SAAS,GAAG,IAAI;YAChBF,YAAY,GAAG,GAAG;YAClB,IAAIlB,IAAI,CAACqB,QAAQ,CAAC,GAAG,CAAC,EAAE;cACtBH,YAAY,GAAGI,SAAS;cACxBN,MAAM,CAACO,IAAI,CAAC,IAAI,CAACxB,gBAAgB,CAACkB,aAAa,CAAC,CAAC;YACnD;UACF;QACF,CAAC,MAAM;UACLA,aAAa,GAAG,GAAGA,aAAa,IAAIjB,IAAI,EAAE;UAC1CoB,SAAS,GAAG,IAAI;UAChB,IAAIpB,IAAI,CAACqB,QAAQ,CAACH,YAAY,CAAC,EAAE;YAC/BA,YAAY,GAAGI,SAAS;YACxBN,MAAM,CAACO,IAAI,CAAC,IAAI,CAACxB,gBAAgB,CAACkB,aAAa,CAAC,CAAC;UACnD;QACF;QACA,IAAI,CAACG,SAAS,EAAE;UACdJ,MAAM,CAACO,IAAI,CAAC,IAAI,CAACxB,gBAAgB,CAACC,IAAI,CAAC,CAAC;QAC1C;MACF;MACAS,MAAM,CAACc,IAAI,CAACP,MAAM,CAAC;IACrB;IACA,OAAOP,MAAM;EACf;EAEAe,WAAWA,CAACC,UAAU,EAAEC,OAAO,EAAEC,KAAK,EAAEC,SAAS,EAAEC,KAAK,EAAE;IACxD,MAAMrB,QAAQ,GAAG,IAAI,CAACX,SAAS,CAACiC,WAAW,CAACL,UAAU,CAACtB,KAAK,CAAC;IAC7D,IAAI,CAACK,QAAQ,EAAE;MACb,MAAM,IAAIuB,KAAK,CAAC,aAAaN,UAAU,CAACtB,KAAK,aAAa,CAAC;IAC7D;IACA,OAAO,IAAI,CAACN,SAAS,CAACmC,WAAW,CAACxB,QAAQ,EAAEmB,KAAK,EAAEC,SAAS,EAAEC,KAAK,GAAG,CAAC,CAAC;EAC1E;EAEAI,gBAAgBA,CAACC,IAAI,EAAET,UAAU,EAAEC,OAAO,EAAEC,KAAK,EAAEC,SAAS,EAAE;IAC5D,MAAMO,aAAa,GAAG,IAAI,CAACtC,SAAS,CAACuC,WAAW,CAC9CX,UAAU,CAACtB,KAAK,EAChBuB,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;IACD,MAAMS,IAAI,GAAG,EAAE;IACf,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwB,IAAI,CAACvB,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MACvC2B,IAAI,CAACd,IAAI,CACP,IAAI,CAAC1B,SAAS,CAACyC,mBAAmB,CAChCJ,IAAI,CAACxB,CAAC,CAAC,CAACP,KAAK,EACbuB,OAAO,EACPC,KAAK,EACLC,SACF,CACF,CAAC;IACH;IACA,IAAI,CAACO,aAAa,EAAE;MAClB,MAAM,IAAIJ,KAAK,CAAC,6BAA6BQ,IAAI,CAACC,SAAS,CAACN,IAAI,CAAC,EAAE,CAAC;IACtE;IACA,MAAMO,MAAM,GAAGN,aAAa,CAACO,GAAG,IAAIP,aAAa;IACjD,IAAI,OAAOM,MAAM,KAAK,UAAU,EAAE;MAChC,OAAO,OAAON,aAAa,KAAK,UAAU,GACtCM,MAAM,CAACd,KAAK,EAAE,GAAGU,IAAI,CAAC,GACtBI,MAAM,CAACE,IAAI,CAACR,aAAa,CAAC,CAACR,KAAK,EAAE,GAAGU,IAAI,CAAC;IAChD;IACA,OAAOI,MAAM;EACf;EAEAG,MAAMA,CAACC,KAAK,EAAEC,UAAU,EAAE;IACxB,MAAMpB,OAAO,GAAGoB,UAAU;IAC1B,MAAMC,KAAK,GAAGrB,OAAO,CAACsB,MAAM,CAACH,KAAK,CAAC;IACnCnB,OAAO,CAACuB,MAAM,GAAGF,KAAK;EACxB;EAEA,MAAMG,aAAaA,CAAChB,IAAI,EAAER,OAAO,EAAEC,KAAK,EAAEC,SAAS,EAAEC,KAAK,EAAE;IAC1D,IAAIJ,UAAU,GAAGS,IAAI,CAAC,CAAC,CAAC;IACxB,IAAIT,UAAU,IAAIA,UAAU,CAACtB,KAAK,IAAIsB,UAAU,CAACtB,KAAK,CAACF,UAAU,CAAC,IAAI,CAAC,EAAE;MACvE,IAAI4B,KAAK,GAAG,CAAC,EAAE;QACb,OAAOF,KAAK;MACd;MACAF,UAAU,GAAG;QAAE,GAAGA;MAAW,CAAC;MAC9BA,UAAU,CAACtB,KAAK,GAAGsB,UAAU,CAACtB,KAAK,CAACG,KAAK,CAAC,CAAC,CAAC;IAC9C;IACA,QAAQmB,UAAU,CAACvB,IAAI;MACrB,KAAK,KAAK;QACR,IAAI,CAACL,SAAS,CAACsD,QAAQ,CACrBjB,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,EACb+B,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCI,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,QAAQ;QACX,IAAI,CAAC/B,SAAS,CAACuD,WAAW,CAAClB,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,EAAEuB,OAAO,EAAEC,KAAK,EAAEC,SAAS,CAAC;QACpE;MACF,KAAK,KAAK;QACR,OAAO,IAAI,CAAC/B,SAAS,CAACwD,QAAQ,CAC5BnB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCI,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;MACH,KAAK,KAAK;QACR,IAAI,CAAC/B,SAAS,CAACyD,QAAQ,CACrBpB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCY,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAG,GAAG,EAC7BuB,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,KAAK;QACR,IAAI,CAAC/B,SAAS,CAAC0D,QAAQ,CACrBrB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCY,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAG,GAAG,EAC7BuB,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,IAAI;QACP,IAAI,CAAC/B,SAAS,CAAC2D,OAAO,CACpBtB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCY,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCI,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,KAAK;QACR,IAAI,CAAC/B,SAAS,CAAC4D,QAAQ,CACrBvB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCY,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCI,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,IAAI;QACP,IAAI,CAAC/B,SAAS,CAAC6D,OAAO,CACpBxB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCY,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCI,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,IAAI;QACP,IAAI,CAAC/B,SAAS,CAAC8D,OAAO,CACpBzB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCY,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCI,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,IAAI;QACP,IAAI,CAAC/B,SAAS,CAAC+D,OAAO,CACpB1B,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCY,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCI,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,IAAI;QACP,IAAI,CAAC/B,SAAS,CAACgE,OAAO,CACpB3B,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCY,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,GAAGmB,SAAS,EACnCI,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;QACD;MACF,KAAK,MAAM;QACT,IAAI,CAACgB,MAAM,CAACV,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,EAAEuB,OAAO,CAAC;QACnC;MACF,KAAK,KAAK;QACR,IAAI,CAACA,OAAO,CAACoC,QAAQ,EAAE;UACrB,IAAI,CAAClB,MAAM,CAACV,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,EAAEuB,OAAO,CAAC;QACrC;QACA;MACF,KAAK,IAAI;QACP,IAAIA,OAAO,CAACoC,QAAQ,EAAE;UACpB,IAAI,CAAClB,MAAM,CAACV,IAAI,CAAC,CAAC,CAAC,CAAC/B,KAAK,EAAEuB,OAAO,CAAC;QACrC;QACA;MACF,KAAK,MAAM;QACT,OAAO,IAAI,CAACF,WAAW,CAACC,UAAU,EAAEC,OAAO,EAAEC,KAAK,EAAEC,SAAS,EAAEC,KAAK,CAAC;MACvE,KAAK,WAAW;QACd,OAAO,IAAI,CAACI,gBAAgB,CAC1BC,IAAI,EACJT,UAAU,EACVC,OAAO,EACPC,KAAK,EACLC,SACF,CAAC;MACH;QACE;IACJ;IACA,OAAOD,KAAK;EACd;EAEAoC,UAAUA,CAACC,QAAQ,EAAEC,SAAS,EAAE;IAC9B,MAAMjB,MAAM,GAAGiB,SAAS;IACxB,KAAK,IAAIvD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsD,QAAQ,CAACrD,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MAC3C,MAAMwD,OAAO,GAAGF,QAAQ,CAACtD,CAAC,CAAC;MAC3B,IAAIwD,OAAO,CAAC,CAAC,CAAC,CAAChE,IAAI,KAAK,OAAO,EAAE;QAC/B8C,MAAM,CAACkB,OAAO,CAAC,CAAC,CAAC,CAAC/D,KAAK,CAAC,GAAGO,CAAC;MAC9B;IACF;EACF;EAEA,MAAMyD,OAAOA,CAACH,QAAQ,EAAEI,QAAQ,EAAExC,SAAS,EAAEC,KAAK,EAAE;IAClD,IAAIF,KAAK,GAAGyC,QAAQ;IACpB,MAAM1C,OAAO,GAAG;MAAEuB,MAAM,EAAE,CAAC;MAAED,MAAM,EAAE,CAAC;IAAE,CAAC;IACzC,IAAI,CAACe,UAAU,CAACC,QAAQ,EAAEtC,OAAO,CAACsB,MAAM,CAAC;IACzC,OAAOtB,OAAO,CAACuB,MAAM,GAAGe,QAAQ,CAACrD,MAAM,EAAE;MACvCgB,KAAK,GAAG,MAAM,IAAI,CAACuB,aAAa,CAC9Bc,QAAQ,CAACtC,OAAO,CAACuB,MAAM,CAAC,EACxBvB,OAAO,EACPC,KAAK,EACLC,SAAS,EACTC,KACF,CAAC;MACDH,OAAO,CAACuB,MAAM,IAAI,CAAC;IACrB;IACA,OAAOtB,KAAK;EACd;AACF;AAEA0C,MAAM,CAACC,OAAO,GAAG3E,eAAe","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}