{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  Clonable\n} = require('@nlpjs/core');\nconst ExtractorEnum = require('./extractor-enum');\nconst ExtractorRegex = require('./extractor-regex');\nconst ExtractorTrim = require('./extractor-trim');\nconst ExtractorBuiltin = require('./extractor-builtin');\nconst {\n  TrimType\n} = require('./trim-types');\nfunction isObject(obj) {\n  return obj !== undefined && obj !== null && obj.constructor === Object;\n}\nclass Ner extends Clonable {\n  constructor(settings = {}, container = undefined) {\n    super({\n      settings: {},\n      container: settings.container || container\n    }, container);\n    this.applySettings(this.settings, settings);\n    this.applySettings(this.settings);\n    if (!this.settings.tag) {\n      this.settings.tag = `ner`;\n    }\n    this.registerDefault();\n    this.applySettings(this.settings, this.container.getConfiguration(this.settings.tag));\n    this.rules = {};\n    this.applySettings(this, {\n      pipelineProcess: this.getPipeline(`${this.settings.tag}-process`)\n    });\n  }\n  registerDefault() {}\n  getRulesByName(locale = '*', name = '', force = false) {\n    if (!this.rules[locale]) {\n      if (!force) {\n        return undefined;\n      }\n      this.rules[locale] = {};\n    }\n    if (!this.rules[locale][name]) {\n      if (!force) {\n        return undefined;\n      }\n      this.rules[locale][name] = {\n        name,\n        type: 'enum',\n        rules: []\n      };\n    }\n    return this.rules[locale][name];\n  }\n  addRule(locale = '*', name, type, rule) {\n    if (Array.isArray(locale)) {\n      for (let i = 0; i < locale.length; i += 1) {\n        this.addRule(locale[i], name, type, rule);\n      }\n    } else {\n      if (!this.rules[locale]) {\n        this.rules[locale] = {};\n      }\n      if (!this.rules[locale][name]) {\n        this.rules[locale][name] = {\n          name,\n          type,\n          rules: []\n        };\n      }\n      this.rules[locale][name].rules.push(rule);\n    }\n  }\n  asString(item) {\n    if (item) {\n      if (isObject(item)) {\n        return JSON.stringify(item);\n      }\n      if (item.toString) {\n        return item.toString();\n      }\n    }\n    return '';\n  }\n  findRule(rules, rule) {\n    const str = this.asString(rule);\n    for (let i = 0; i < rules.length; i += 1) {\n      if (this.asString(rules[i]) === str) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  removeRule(locale = '*', name, rule) {\n    if (this.rules[locale]) {\n      if (this.rules[locale][name]) {\n        if (!rule) {\n          delete this.rules[locale][name];\n        } else {\n          const index = this.findRule(this.rules[locale][name].rules, rule);\n          if (index > -1) {\n            this.rules[locale][name].rules.splice(index, 1);\n          }\n        }\n      }\n    }\n  }\n  getRules(locale = '*') {\n    const result = [];\n    if (this.rules[locale]) {\n      const keys = Object.keys(this.rules[locale]);\n      for (let i = 0; i < keys.length; i += 1) {\n        result.push(this.rules[locale][keys[i]]);\n      }\n    }\n    if (locale !== '*' && this.rules['*']) {\n      const keys = Object.keys(this.rules['*']);\n      for (let i = 0; i < keys.length; i += 1) {\n        result.push(this.rules['*'][keys[i]]);\n      }\n    }\n    return result;\n  }\n  decideRules(srcInput, intentEntities) {\n    const input = srcInput;\n    let nerRules = this.getRules(input.locale || 'en');\n    if (intentEntities && this.settings.considerOnlyIntentEntities) {\n      nerRules = nerRules.filter(rule => intentEntities.includes(rule.name));\n    } else if (intentEntities) {\n      // entities in the current intent get a higher priority when\n      // sorting out overlapping matches\n      const intentRelevantRule = [];\n      const nonIntentRelevantRule = [];\n      nerRules.forEach(rule => {\n        if (intentEntities.includes(rule.name)) {\n          intentRelevantRule.push(rule);\n        } else {\n          nonIntentRelevantRule.push(rule);\n        }\n      });\n      nerRules = intentRelevantRule.concat(nonIntentRelevantRule);\n    }\n    input.nerRules = nerRules;\n    input.nerLimitToEntities = this.settings.considerOnlyIntentEntities;\n    input.intentEntities = intentEntities;\n    return input;\n  }\n  getRuleOption(rules, option) {\n    for (let i = 0; i < rules.length; i += 1) {\n      if (rules[i].option === option) {\n        return rules[i];\n      }\n    }\n    return undefined;\n  }\n  addRuleOptionTexts(locale, name, option, srcTexts) {\n    if (Array.isArray(locale)) {\n      for (let i = 0; i < locale.length; i += 1) {\n        this.addRuleOptionTexts(locale[i], name, option, srcTexts);\n      }\n    } else {\n      let texts = srcTexts || option;\n      if (!Array.isArray(texts)) {\n        texts = [texts];\n      }\n      const rules = this.getRulesByName(locale, name, true);\n      let ruleOption = this.getRuleOption(rules.rules, option);\n      if (!ruleOption) {\n        ruleOption = {\n          option,\n          texts\n        };\n        rules.rules.push(ruleOption);\n      } else {\n        const dict = {};\n        for (let i = 0; i < ruleOption.texts.length; i += 1) {\n          dict[ruleOption.texts[i]] = 1;\n        }\n        for (let i = 0; i < texts.length; i += 1) {\n          dict[texts[i]] = 1;\n        }\n        ruleOption.texts = Object.keys(dict);\n      }\n    }\n  }\n  removeRuleOptionTexts(locale, name, option, srcTexts) {\n    if (Array.isArray(locale)) {\n      for (let i = 0; i < locale.length; i += 1) {\n        this.removeRuleOptionTexts(locale[i], name, option, srcTexts);\n      }\n    } else {\n      let texts = srcTexts || option;\n      if (!Array.isArray(texts)) {\n        texts = [texts];\n      }\n      const rules = this.getRulesByName(locale, name, false);\n      if (rules) {\n        const ruleOption = this.getRuleOption(rules.rules, option);\n        if (ruleOption) {\n          const dict = {};\n          for (let i = 0; i < ruleOption.texts.length; i += 1) {\n            dict[ruleOption.texts[i]] = 1;\n          }\n          for (let i = 0; i < texts.length; i += 1) {\n            delete dict[texts[i]];\n          }\n          ruleOption.texts = Object.keys(dict);\n        }\n      }\n    }\n  }\n  static str2regex(str) {\n    const index = str.lastIndexOf('/');\n    return new RegExp(str.slice(1, index), str.slice(index + 1));\n  }\n  static regex2str(regex) {\n    return regex.toString();\n  }\n  addRegexRule(locale, name, srcRegex) {\n    const regex = typeof srcRegex === 'string' ? Ner.str2regex(srcRegex) : srcRegex;\n    const globalFlag = 'g';\n    const fixedRegex = regex.flags.includes(globalFlag) ? regex : new RegExp(regex.source, `${regex.flags}${globalFlag}`);\n    this.addRule(locale, name, 'regex', fixedRegex);\n  }\n  addBetweenLastCondition(locale, name, srcLeftWords, srcRightWords, srcOptions = {}) {\n    const options = {\n      ...srcOptions,\n      closest: true\n    };\n    this.addBetweenCondition(locale, name, srcLeftWords, srcRightWords, options);\n  }\n  addBetweenCondition(locale, name, srcLeftWords, srcRightWords, srcOptions) {\n    const options = srcOptions || {};\n    const leftWords = Array.isArray(srcLeftWords) ? srcLeftWords : [srcLeftWords];\n    const rightWords = Array.isArray(srcRightWords) ? srcRightWords : [srcRightWords];\n    const conditions = [];\n    for (let i = 0; i < leftWords.length; i += 1) {\n      for (let j = 0; j < rightWords.length; j += 1) {\n        const leftWord = options.noSpaces === true ? leftWords[i] : ` ${leftWords[i]} `;\n        const rightWord = options.noSpaces === true ? rightWords[j] : ` ${rightWords[j]} `;\n        let regex;\n        if (options.closest === true) {\n          regex = `${leftWord}(?!.*${leftWord}.*)(.*)${rightWord}`;\n        } else {\n          regex = `(?<=${leftWord})(.*)(?=${rightWord})`;\n        }\n        conditions.push(regex);\n      }\n    }\n    let regex = `/${conditions.join('|')}/g`;\n    if (options.caseSensitive !== true) {\n      regex += 'i';\n    }\n    const rule = {\n      type: 'between',\n      leftWords,\n      rightWords,\n      regex: Ner.str2regex(regex),\n      options\n    };\n    this.addRule(locale, name, 'trim', rule);\n  }\n  addPositionCondition(locale, name, position, srcWords, srcOptions) {\n    const options = srcOptions || {};\n    const words = Array.isArray(srcWords) ? srcWords : [srcWords];\n    const rule = {\n      type: position,\n      words,\n      options\n    };\n    this.addRule(locale, name, 'trim', rule);\n  }\n  addAfterCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.After, words, opts);\n  }\n  addAfterFirstCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.AfterFirst, words, opts);\n  }\n  addAfterLastCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.AfterLast, words, opts);\n  }\n  addBeforeCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.Before, words, opts);\n  }\n  addBeforeFirstCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.BeforeFirst, words, opts);\n  }\n  addBeforeLastCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.BeforeLast, words, opts);\n  }\n  reduceEdges(input) {\n    input.entities = input.edges;\n    delete input.edges;\n    delete input.nerRules;\n    delete input.nerLimitToEntities;\n    delete input.intentEntities;\n    return input;\n  }\n  async defaultPipelineProcess(input, intentEntities) {\n    if (!this.cache) {\n      this.cache = {\n        extractEnum: this.container.get('extract-enum'),\n        extractRegex: this.container.get('extract-regex'),\n        extractTrim: this.container.get('extract-trim'),\n        extractBuiltin: this.container.get('extract-builtin')\n      };\n      if (!this.cache.extractEnum) {\n        this.container.use(ExtractorEnum);\n        this.cache.extractEnum = this.container.get('extract-enum');\n      }\n      if (!this.cache.extractRegex) {\n        this.container.use(ExtractorRegex);\n        this.cache.extractRegex = this.container.get('extract-regex');\n      }\n      if (!this.cache.extractTrim) {\n        this.container.use(ExtractorTrim);\n        this.cache.extractTrim = this.container.get('extract-trim');\n      }\n      if (!this.cache.extractBuiltin) {\n        this.container.use(ExtractorBuiltin);\n        this.cache.extractBuiltin = this.container.get('extract-builtin');\n      }\n    }\n    let output = await this.decideRules(input, intentEntities);\n    if (this.cache.extractEnum) {\n      output = await this.cache.extractEnum.run(output);\n    }\n    if (this.cache.extractRegex) {\n      output = await this.cache.extractRegex.run(output);\n    }\n    if (this.cache.extractTrim) {\n      output = await this.cache.extractTrim.run(output);\n    }\n    if (this.cache.extractBuiltin) {\n      output = await this.cache.extractBuiltin.run(output);\n    }\n    output = await this.reduceEdges(output);\n    return output;\n  }\n  async process(srcInput, consideredEntities) {\n    const input = {\n      threshold: this.settings.threshold || 0.8,\n      ...srcInput\n    };\n    let result;\n    if (input.locale) {\n      const pipeline = this.container.getPipeline(`${this.settings.tag}-${input.locale}-process`);\n      if (pipeline) {\n        result = await this.runPipeline(input, pipeline);\n      }\n    } else if (this.pipelineProcess) {\n      result = await this.runPipeline(input, this.pipelineProcess);\n    }\n    if (!result) {\n      result = await this.defaultPipelineProcess(input, consideredEntities);\n    } else if (consideredEntities) {\n      // when custom pipeline is used then we can not be sure it is handled correctly\n      result.entities = result.entities.filter(entity => consideredEntities.includes(entity.entity));\n    }\n    delete result.threshold;\n    return result;\n  }\n  nameToEntity(name) {\n    const preffix = this.settings.entityPreffix === undefined ? '@' : this.settings.entityPreffix;\n    const suffix = this.settings.entitySuffix === undefined ? '' : this.settings.entitySuffix;\n    return `${preffix}${name}${suffix}`;\n  }\n  entityToName(entity) {\n    if (!entity) {\n      return entity;\n    }\n    let name = entity;\n    const preffix = this.settings.entityPreffix === undefined ? '@' : this.settings.entityPreffix;\n    const suffix = this.settings.entitySuffix === undefined ? '' : this.settings.entitySuffix;\n    if (preffix) {\n      if (!name.startsWith(preffix)) {\n        return entity;\n      }\n      name = name.slice(preffix.length);\n    }\n    if (suffix) {\n      if (!name.endsWith(suffix)) {\n        return entity;\n      }\n      name = name.slice(0, -suffix.length);\n    }\n    return name;\n  }\n  isEntity(entity) {\n    const name = this.entityToName(entity);\n    return name !== entity;\n  }\n  getEntitiesFromUtterance(locale, utterance) {\n    if (!utterance) {\n      utterance = locale;\n      locale = 'es';\n    }\n    const tokens = utterance.split(/[\\s,.!?;:([\\]'\"¡¿)/]+/).filter(x => x);\n    const result = [];\n    for (let i = 0; i < tokens.length; i += 1) {\n      const token = tokens[i];\n      if (this.isEntity(token)) {\n        result.push(this.entityToName(token));\n      }\n    }\n    return result;\n  }\n  async generateEntityUtterance(locale, utterance) {\n    let input = {\n      locale,\n      utterance\n    };\n    input = await this.process(input);\n    const {\n      entities\n    } = input;\n    if (!entities || !entities.length) {\n      return utterance;\n    }\n    entities.sort((a, b) => a.start - b.start);\n    let index = 0;\n    let result = '';\n    for (let i = 0; i < entities.length; i += 1) {\n      const entity = entities[i];\n      const left = utterance.slice(index, entity.start);\n      index = entity.end + 1;\n      result += left;\n      result += this.nameToEntity(entity.entity);\n    }\n    const right = utterance.slice(entities[entities.length - 1].end + 1);\n    result += right;\n    return result;\n  }\n  toJSON() {\n    // easy RegExp serialization: https://stackoverflow.com/questions/12075927/serialization-of-regexp\n    // eslint-disable-next-line no-extend-native\n    RegExp.prototype.toJSON = RegExp.prototype.toString;\n    const result = {\n      settings: {\n        ...this.settings\n      },\n      rules: {\n        ...this.rules\n      }\n    };\n    delete result.settings.container;\n    return result;\n  }\n  fromJSON(json) {\n    this.applySettings(this.settings, json.settings);\n    const rulesKeys = Object.keys(json.rules);\n    rulesKeys.forEach(rKey => {\n      const entityKeys = Object.keys(json.rules[rKey]);\n      entityKeys.forEach(eKey => {\n        json.rules[rKey][eKey].rules = json.rules[rKey][eKey].type === 'regex' ? json.rules[rKey][eKey].rules.map(rule => Ner.str2regex(rule)) : json.rules[rKey][eKey].rules.map(rule => typeof rule.regex === 'string' ? {\n          ...rule,\n          regex: Ner.str2regex(rule.regex)\n        } : rule);\n      });\n    });\n    this.rules = json.rules;\n  }\n}\nmodule.exports = Ner;","map":{"version":3,"names":["Clonable","require","ExtractorEnum","ExtractorRegex","ExtractorTrim","ExtractorBuiltin","TrimType","isObject","obj","undefined","constructor","Object","Ner","settings","container","applySettings","tag","registerDefault","getConfiguration","rules","pipelineProcess","getPipeline","getRulesByName","locale","name","force","type","addRule","rule","Array","isArray","i","length","push","asString","item","JSON","stringify","toString","findRule","str","removeRule","index","splice","getRules","result","keys","decideRules","srcInput","intentEntities","input","nerRules","considerOnlyIntentEntities","filter","includes","intentRelevantRule","nonIntentRelevantRule","forEach","concat","nerLimitToEntities","getRuleOption","option","addRuleOptionTexts","srcTexts","texts","ruleOption","dict","removeRuleOptionTexts","str2regex","lastIndexOf","RegExp","slice","regex2str","regex","addRegexRule","srcRegex","globalFlag","fixedRegex","flags","source","addBetweenLastCondition","srcLeftWords","srcRightWords","srcOptions","options","closest","addBetweenCondition","leftWords","rightWords","conditions","j","leftWord","noSpaces","rightWord","join","caseSensitive","addPositionCondition","position","srcWords","words","addAfterCondition","opts","After","addAfterFirstCondition","AfterFirst","addAfterLastCondition","AfterLast","addBeforeCondition","Before","addBeforeFirstCondition","BeforeFirst","addBeforeLastCondition","BeforeLast","reduceEdges","entities","edges","defaultPipelineProcess","cache","extractEnum","get","extractRegex","extractTrim","extractBuiltin","use","output","run","process","consideredEntities","threshold","pipeline","runPipeline","entity","nameToEntity","preffix","entityPreffix","suffix","entitySuffix","entityToName","startsWith","endsWith","isEntity","getEntitiesFromUtterance","utterance","tokens","split","x","token","generateEntityUtterance","sort","a","b","start","left","end","right","toJSON","prototype","fromJSON","json","rulesKeys","rKey","entityKeys","eKey","map","module","exports"],"sources":["/Users/zyq/Desktop/大二下/暑期实习/moonshot project/node_modules/@nlpjs/ner/src/ner.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { Clonable } = require('@nlpjs/core');\nconst ExtractorEnum = require('./extractor-enum');\nconst ExtractorRegex = require('./extractor-regex');\nconst ExtractorTrim = require('./extractor-trim');\nconst ExtractorBuiltin = require('./extractor-builtin');\n\nconst { TrimType } = require('./trim-types');\n\nfunction isObject(obj) {\n  return obj !== undefined && obj !== null && obj.constructor === Object;\n}\n\nclass Ner extends Clonable {\n  constructor(settings = {}, container = undefined) {\n    super(\n      {\n        settings: {},\n        container: settings.container || container,\n      },\n      container\n    );\n    this.applySettings(this.settings, settings);\n    this.applySettings(this.settings);\n    if (!this.settings.tag) {\n      this.settings.tag = `ner`;\n    }\n    this.registerDefault();\n    this.applySettings(\n      this.settings,\n      this.container.getConfiguration(this.settings.tag)\n    );\n    this.rules = {};\n    this.applySettings(this, {\n      pipelineProcess: this.getPipeline(`${this.settings.tag}-process`),\n    });\n  }\n\n  registerDefault() {}\n\n  getRulesByName(locale = '*', name = '', force = false) {\n    if (!this.rules[locale]) {\n      if (!force) {\n        return undefined;\n      }\n      this.rules[locale] = {};\n    }\n    if (!this.rules[locale][name]) {\n      if (!force) {\n        return undefined;\n      }\n      this.rules[locale][name] = {\n        name,\n        type: 'enum',\n        rules: [],\n      };\n    }\n    return this.rules[locale][name];\n  }\n\n  addRule(locale = '*', name, type, rule) {\n    if (Array.isArray(locale)) {\n      for (let i = 0; i < locale.length; i += 1) {\n        this.addRule(locale[i], name, type, rule);\n      }\n    } else {\n      if (!this.rules[locale]) {\n        this.rules[locale] = {};\n      }\n      if (!this.rules[locale][name]) {\n        this.rules[locale][name] = {\n          name,\n          type,\n          rules: [],\n        };\n      }\n      this.rules[locale][name].rules.push(rule);\n    }\n  }\n\n  asString(item) {\n    if (item) {\n      if (isObject(item)) {\n        return JSON.stringify(item);\n      }\n      if (item.toString) {\n        return item.toString();\n      }\n    }\n    return '';\n  }\n\n  findRule(rules, rule) {\n    const str = this.asString(rule);\n    for (let i = 0; i < rules.length; i += 1) {\n      if (this.asString(rules[i]) === str) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  removeRule(locale = '*', name, rule) {\n    if (this.rules[locale]) {\n      if (this.rules[locale][name]) {\n        if (!rule) {\n          delete this.rules[locale][name];\n        } else {\n          const index = this.findRule(this.rules[locale][name].rules, rule);\n          if (index > -1) {\n            this.rules[locale][name].rules.splice(index, 1);\n          }\n        }\n      }\n    }\n  }\n\n  getRules(locale = '*') {\n    const result = [];\n    if (this.rules[locale]) {\n      const keys = Object.keys(this.rules[locale]);\n      for (let i = 0; i < keys.length; i += 1) {\n        result.push(this.rules[locale][keys[i]]);\n      }\n    }\n    if (locale !== '*' && this.rules['*']) {\n      const keys = Object.keys(this.rules['*']);\n      for (let i = 0; i < keys.length; i += 1) {\n        result.push(this.rules['*'][keys[i]]);\n      }\n    }\n    return result;\n  }\n\n  decideRules(srcInput, intentEntities) {\n    const input = srcInput;\n    let nerRules = this.getRules(input.locale || 'en');\n    if (intentEntities && this.settings.considerOnlyIntentEntities) {\n      nerRules = nerRules.filter((rule) => intentEntities.includes(rule.name));\n    } else if (intentEntities) {\n      // entities in the current intent get a higher priority when\n      // sorting out overlapping matches\n      const intentRelevantRule = [];\n      const nonIntentRelevantRule = [];\n      nerRules.forEach((rule) => {\n        if (intentEntities.includes(rule.name)) {\n          intentRelevantRule.push(rule);\n        } else {\n          nonIntentRelevantRule.push(rule);\n        }\n      });\n      nerRules = intentRelevantRule.concat(nonIntentRelevantRule);\n    }\n    input.nerRules = nerRules;\n    input.nerLimitToEntities = this.settings.considerOnlyIntentEntities;\n    input.intentEntities = intentEntities;\n    return input;\n  }\n\n  getRuleOption(rules, option) {\n    for (let i = 0; i < rules.length; i += 1) {\n      if (rules[i].option === option) {\n        return rules[i];\n      }\n    }\n    return undefined;\n  }\n\n  addRuleOptionTexts(locale, name, option, srcTexts) {\n    if (Array.isArray(locale)) {\n      for (let i = 0; i < locale.length; i += 1) {\n        this.addRuleOptionTexts(locale[i], name, option, srcTexts);\n      }\n    } else {\n      let texts = srcTexts || option;\n      if (!Array.isArray(texts)) {\n        texts = [texts];\n      }\n      const rules = this.getRulesByName(locale, name, true);\n      let ruleOption = this.getRuleOption(rules.rules, option);\n      if (!ruleOption) {\n        ruleOption = {\n          option,\n          texts,\n        };\n        rules.rules.push(ruleOption);\n      } else {\n        const dict = {};\n        for (let i = 0; i < ruleOption.texts.length; i += 1) {\n          dict[ruleOption.texts[i]] = 1;\n        }\n        for (let i = 0; i < texts.length; i += 1) {\n          dict[texts[i]] = 1;\n        }\n        ruleOption.texts = Object.keys(dict);\n      }\n    }\n  }\n\n  removeRuleOptionTexts(locale, name, option, srcTexts) {\n    if (Array.isArray(locale)) {\n      for (let i = 0; i < locale.length; i += 1) {\n        this.removeRuleOptionTexts(locale[i], name, option, srcTexts);\n      }\n    } else {\n      let texts = srcTexts || option;\n      if (!Array.isArray(texts)) {\n        texts = [texts];\n      }\n      const rules = this.getRulesByName(locale, name, false);\n      if (rules) {\n        const ruleOption = this.getRuleOption(rules.rules, option);\n        if (ruleOption) {\n          const dict = {};\n          for (let i = 0; i < ruleOption.texts.length; i += 1) {\n            dict[ruleOption.texts[i]] = 1;\n          }\n          for (let i = 0; i < texts.length; i += 1) {\n            delete dict[texts[i]];\n          }\n          ruleOption.texts = Object.keys(dict);\n        }\n      }\n    }\n  }\n\n  static str2regex(str) {\n    const index = str.lastIndexOf('/');\n    return new RegExp(str.slice(1, index), str.slice(index + 1));\n  }\n\n  static regex2str(regex) {\n    return regex.toString();\n  }\n\n  addRegexRule(locale, name, srcRegex) {\n    const regex =\n      typeof srcRegex === 'string' ? Ner.str2regex(srcRegex) : srcRegex;\n    const globalFlag = 'g';\n    const fixedRegex = regex.flags.includes(globalFlag)\n      ? regex\n      : new RegExp(regex.source, `${regex.flags}${globalFlag}`);\n    this.addRule(locale, name, 'regex', fixedRegex);\n  }\n\n  addBetweenLastCondition(\n    locale,\n    name,\n    srcLeftWords,\n    srcRightWords,\n    srcOptions = {}\n  ) {\n    const options = {\n      ...srcOptions,\n      closest: true,\n    };\n    this.addBetweenCondition(\n      locale,\n      name,\n      srcLeftWords,\n      srcRightWords,\n      options\n    );\n  }\n\n  addBetweenCondition(locale, name, srcLeftWords, srcRightWords, srcOptions) {\n    const options = srcOptions || {};\n    const leftWords = Array.isArray(srcLeftWords)\n      ? srcLeftWords\n      : [srcLeftWords];\n    const rightWords = Array.isArray(srcRightWords)\n      ? srcRightWords\n      : [srcRightWords];\n    const conditions = [];\n    for (let i = 0; i < leftWords.length; i += 1) {\n      for (let j = 0; j < rightWords.length; j += 1) {\n        const leftWord =\n          options.noSpaces === true ? leftWords[i] : ` ${leftWords[i]} `;\n        const rightWord =\n          options.noSpaces === true ? rightWords[j] : ` ${rightWords[j]} `;\n        let regex;\n        if (options.closest === true) {\n          regex = `${leftWord}(?!.*${leftWord}.*)(.*)${rightWord}`;\n        } else {\n          regex = `(?<=${leftWord})(.*)(?=${rightWord})`;\n        }\n        conditions.push(regex);\n      }\n    }\n    let regex = `/${conditions.join('|')}/g`;\n    if (options.caseSensitive !== true) {\n      regex += 'i';\n    }\n    const rule = {\n      type: 'between',\n      leftWords,\n      rightWords,\n      regex: Ner.str2regex(regex),\n      options,\n    };\n    this.addRule(locale, name, 'trim', rule);\n  }\n\n  addPositionCondition(locale, name, position, srcWords, srcOptions) {\n    const options = srcOptions || {};\n    const words = Array.isArray(srcWords) ? srcWords : [srcWords];\n    const rule = {\n      type: position,\n      words,\n      options,\n    };\n    this.addRule(locale, name, 'trim', rule);\n  }\n\n  addAfterCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.After, words, opts);\n  }\n\n  addAfterFirstCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.AfterFirst, words, opts);\n  }\n\n  addAfterLastCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.AfterLast, words, opts);\n  }\n\n  addBeforeCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.Before, words, opts);\n  }\n\n  addBeforeFirstCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.BeforeFirst, words, opts);\n  }\n\n  addBeforeLastCondition(locale, name, words, opts) {\n    this.addPositionCondition(locale, name, TrimType.BeforeLast, words, opts);\n  }\n\n  reduceEdges(input) {\n    input.entities = input.edges;\n    delete input.edges;\n    delete input.nerRules;\n    delete input.nerLimitToEntities;\n    delete input.intentEntities;\n    return input;\n  }\n\n  async defaultPipelineProcess(input, intentEntities) {\n    if (!this.cache) {\n      this.cache = {\n        extractEnum: this.container.get('extract-enum'),\n        extractRegex: this.container.get('extract-regex'),\n        extractTrim: this.container.get('extract-trim'),\n        extractBuiltin: this.container.get('extract-builtin'),\n      };\n      if (!this.cache.extractEnum) {\n        this.container.use(ExtractorEnum);\n        this.cache.extractEnum = this.container.get('extract-enum');\n      }\n      if (!this.cache.extractRegex) {\n        this.container.use(ExtractorRegex);\n        this.cache.extractRegex = this.container.get('extract-regex');\n      }\n      if (!this.cache.extractTrim) {\n        this.container.use(ExtractorTrim);\n        this.cache.extractTrim = this.container.get('extract-trim');\n      }\n      if (!this.cache.extractBuiltin) {\n        this.container.use(ExtractorBuiltin);\n        this.cache.extractBuiltin = this.container.get('extract-builtin');\n      }\n    }\n    let output = await this.decideRules(input, intentEntities);\n    if (this.cache.extractEnum) {\n      output = await this.cache.extractEnum.run(output);\n    }\n    if (this.cache.extractRegex) {\n      output = await this.cache.extractRegex.run(output);\n    }\n    if (this.cache.extractTrim) {\n      output = await this.cache.extractTrim.run(output);\n    }\n    if (this.cache.extractBuiltin) {\n      output = await this.cache.extractBuiltin.run(output);\n    }\n    output = await this.reduceEdges(output);\n    return output;\n  }\n\n  async process(srcInput, consideredEntities) {\n    const input = {\n      threshold: this.settings.threshold || 0.8,\n      ...srcInput,\n    };\n    let result;\n    if (input.locale) {\n      const pipeline = this.container.getPipeline(\n        `${this.settings.tag}-${input.locale}-process`\n      );\n      if (pipeline) {\n        result = await this.runPipeline(input, pipeline);\n      }\n    } else if (this.pipelineProcess) {\n      result = await this.runPipeline(input, this.pipelineProcess);\n    }\n    if (!result) {\n      result = await this.defaultPipelineProcess(input, consideredEntities);\n    } else if (consideredEntities) {\n      // when custom pipeline is used then we can not be sure it is handled correctly\n      result.entities = result.entities.filter((entity) =>\n        consideredEntities.includes(entity.entity)\n      );\n    }\n    delete result.threshold;\n    return result;\n  }\n\n  nameToEntity(name) {\n    const preffix =\n      this.settings.entityPreffix === undefined\n        ? '@'\n        : this.settings.entityPreffix;\n    const suffix =\n      this.settings.entitySuffix === undefined\n        ? ''\n        : this.settings.entitySuffix;\n    return `${preffix}${name}${suffix}`;\n  }\n\n  entityToName(entity) {\n    if (!entity) {\n      return entity;\n    }\n    let name = entity;\n    const preffix =\n      this.settings.entityPreffix === undefined\n        ? '@'\n        : this.settings.entityPreffix;\n    const suffix =\n      this.settings.entitySuffix === undefined\n        ? ''\n        : this.settings.entitySuffix;\n    if (preffix) {\n      if (!name.startsWith(preffix)) {\n        return entity;\n      }\n      name = name.slice(preffix.length);\n    }\n    if (suffix) {\n      if (!name.endsWith(suffix)) {\n        return entity;\n      }\n      name = name.slice(0, -suffix.length);\n    }\n    return name;\n  }\n\n  isEntity(entity) {\n    const name = this.entityToName(entity);\n    return name !== entity;\n  }\n\n  getEntitiesFromUtterance(locale, utterance) {\n    if (!utterance) {\n      utterance = locale;\n      locale = 'es';\n    }\n    const tokens = utterance.split(/[\\s,.!?;:([\\]'\"¡¿)/]+/).filter((x) => x);\n    const result = [];\n    for (let i = 0; i < tokens.length; i += 1) {\n      const token = tokens[i];\n      if (this.isEntity(token)) {\n        result.push(this.entityToName(token));\n      }\n    }\n    return result;\n  }\n\n  async generateEntityUtterance(locale, utterance) {\n    let input = {\n      locale,\n      utterance,\n    };\n    input = await this.process(input);\n    const { entities } = input;\n    if (!entities || !entities.length) {\n      return utterance;\n    }\n    entities.sort((a, b) => a.start - b.start);\n    let index = 0;\n    let result = '';\n    for (let i = 0; i < entities.length; i += 1) {\n      const entity = entities[i];\n      const left = utterance.slice(index, entity.start);\n      index = entity.end + 1;\n      result += left;\n      result += this.nameToEntity(entity.entity);\n    }\n    const right = utterance.slice(entities[entities.length - 1].end + 1);\n    result += right;\n    return result;\n  }\n\n  toJSON() {\n    // easy RegExp serialization: https://stackoverflow.com/questions/12075927/serialization-of-regexp\n    // eslint-disable-next-line no-extend-native\n    RegExp.prototype.toJSON = RegExp.prototype.toString;\n\n    const result = {\n      settings: { ...this.settings },\n      rules: { ...this.rules },\n    };\n\n    delete result.settings.container;\n    return result;\n  }\n\n  fromJSON(json) {\n    this.applySettings(this.settings, json.settings);\n\n    const rulesKeys = Object.keys(json.rules);\n\n    rulesKeys.forEach((rKey) => {\n      const entityKeys = Object.keys(json.rules[rKey]);\n\n      entityKeys.forEach((eKey) => {\n        json.rules[rKey][eKey].rules =\n          json.rules[rKey][eKey].type === 'regex'\n            ? json.rules[rKey][eKey].rules.map((rule) => Ner.str2regex(rule))\n            : json.rules[rKey][eKey].rules.map((rule) =>\n                typeof rule.regex === 'string'\n                  ? {\n                      ...rule,\n                      regex: Ner.str2regex(rule.regex),\n                    }\n                  : rule\n              );\n      });\n    });\n\n    this.rules = json.rules;\n  }\n}\n\nmodule.exports = Ner;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}